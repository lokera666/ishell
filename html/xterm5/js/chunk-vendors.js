/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkxterm5_ishell"] = self["webpackChunkxterm5_ishell"] || []).push([["chunk-vendors"],{

/***/ "./node_modules/.store/xterm-addon-canvas@0.2.0/node_modules/xterm-addon-canvas/lib/xterm-addon-canvas.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.store/xterm-addon-canvas@0.2.0/node_modules/xterm-addon-canvas/lib/xterm-addon-canvas.js ***!
  \****************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("__webpack_require__(/*! core-js/modules/es.array.push.js */ \"./node_modules/core-js/modules/es.array.push.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.to-reversed.js */ \"./node_modules/core-js/modules/es.typed-array.to-reversed.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.to-sorted.js */ \"./node_modules/core-js/modules/es.typed-array.to-sorted.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.with.js */ \"./node_modules/core-js/modules/es.typed-array.with.js\");\n!function (e, t) {\n   true ? module.exports = t() : 0;\n}(self, function () {\n  return (() => {\n    \"use strict\";\n\n    var e = {\n        903: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.BaseRenderLayer = void 0;\n          const s = i(855),\n            r = i(302),\n            o = i(713),\n            n = i(147),\n            a = i(634),\n            l = i(160),\n            h = i(503),\n            c = i(14);\n          t.BaseRenderLayer = class {\n            constructor(e, t, i, s, r, o, n, a, l, h) {\n              this._container = e, this._alpha = s, this._colors = r, this._rendererId = o, this._bufferService = n, this._optionsService = a, this._decorationService = l, this._coreBrowserService = h, this._scaledCharWidth = 0, this._scaledCharHeight = 0, this._scaledCellWidth = 0, this._scaledCellHeight = 0, this._scaledCharLeft = 0, this._scaledCharTop = 0, this._columnSelectMode = !1, this._currentGlyphIdentifier = {\n                chars: \"\",\n                code: 0,\n                bg: 0,\n                fg: 0,\n                bold: !1,\n                dim: !1,\n                italic: !1\n              }, this._canvas = document.createElement(\"canvas\"), this._canvas.classList.add(`xterm-${t}-layer`), this._canvas.style.zIndex = i.toString(), this._initCanvas(), this._container.appendChild(this._canvas);\n            }\n            get canvas() {\n              return this._canvas;\n            }\n            dispose() {\n              var e;\n              (0, h.removeElementFromParent)(this._canvas), null === (e = this._charAtlas) || void 0 === e || e.dispose();\n            }\n            _initCanvas() {\n              this._ctx = (0, a.throwIfFalsy)(this._canvas.getContext(\"2d\", {\n                alpha: this._alpha\n              })), this._alpha || this._clearAll();\n            }\n            onOptionsChanged() {}\n            onBlur() {}\n            onFocus() {}\n            onCursorMove() {}\n            onGridChanged(e, t) {}\n            onSelectionChanged(e, t, i = !1) {\n              this._selectionStart = e, this._selectionEnd = t, this._columnSelectMode = i;\n            }\n            setColors(e) {\n              this._refreshCharAtlas(e);\n            }\n            _setTransparency(e) {\n              if (e === this._alpha) return;\n              const t = this._canvas;\n              this._alpha = e, this._canvas = this._canvas.cloneNode(), this._initCanvas(), this._container.replaceChild(this._canvas, t), this._refreshCharAtlas(this._colors), this.onGridChanged(0, this._bufferService.rows - 1);\n            }\n            _refreshCharAtlas(e) {\n              this._scaledCharWidth <= 0 && this._scaledCharHeight <= 0 || (this._charAtlas = (0, o.acquireCharAtlas)(this._optionsService.rawOptions, this._rendererId, e, this._scaledCharWidth, this._scaledCharHeight, this._coreBrowserService.dpr), this._charAtlas.warmUp());\n            }\n            resize(e) {\n              this._scaledCellWidth = e.scaledCellWidth, this._scaledCellHeight = e.scaledCellHeight, this._scaledCharWidth = e.scaledCharWidth, this._scaledCharHeight = e.scaledCharHeight, this._scaledCharLeft = e.scaledCharLeft, this._scaledCharTop = e.scaledCharTop, this._canvas.width = e.scaledCanvasWidth, this._canvas.height = e.scaledCanvasHeight, this._canvas.style.width = `${e.canvasWidth}px`, this._canvas.style.height = `${e.canvasHeight}px`, this._alpha || this._clearAll(), this._refreshCharAtlas(this._colors);\n            }\n            clearTextureAtlas() {\n              var e;\n              null === (e = this._charAtlas) || void 0 === e || e.clear();\n            }\n            _fillCells(e, t, i, s) {\n              this._ctx.fillRect(e * this._scaledCellWidth, t * this._scaledCellHeight, i * this._scaledCellWidth, s * this._scaledCellHeight);\n            }\n            _fillMiddleLineAtCells(e, t, i = 1) {\n              const s = Math.ceil(.5 * this._scaledCellHeight);\n              this._ctx.fillRect(e * this._scaledCellWidth, (t + 1) * this._scaledCellHeight - s - this._coreBrowserService.dpr, i * this._scaledCellWidth, this._coreBrowserService.dpr);\n            }\n            _fillBottomLineAtCells(e, t, i = 1, s = 0) {\n              this._ctx.fillRect(e * this._scaledCellWidth, (t + 1) * this._scaledCellHeight + s - this._coreBrowserService.dpr - 1, i * this._scaledCellWidth, this._coreBrowserService.dpr);\n            }\n            _curlyUnderlineAtCell(e, t, i = 1) {\n              this._ctx.save(), this._ctx.beginPath(), this._ctx.strokeStyle = this._ctx.fillStyle;\n              const s = this._coreBrowserService.dpr;\n              this._ctx.lineWidth = s;\n              for (let r = 0; r < i; r++) {\n                const i = (e + r) * this._scaledCellWidth,\n                  o = (e + r + .5) * this._scaledCellWidth,\n                  n = (e + r + 1) * this._scaledCellWidth,\n                  a = (t + 1) * this._scaledCellHeight - s - 1,\n                  l = a - s,\n                  h = a + s;\n                this._ctx.moveTo(i, a), this._ctx.bezierCurveTo(i, l, o, l, o, a), this._ctx.bezierCurveTo(o, h, n, h, n, a);\n              }\n              this._ctx.stroke(), this._ctx.restore();\n            }\n            _dottedUnderlineAtCell(e, t, i = 1) {\n              this._ctx.save(), this._ctx.beginPath(), this._ctx.strokeStyle = this._ctx.fillStyle;\n              const s = this._coreBrowserService.dpr;\n              this._ctx.lineWidth = s, this._ctx.setLineDash([2 * s, s]);\n              const r = e * this._scaledCellWidth,\n                o = (t + 1) * this._scaledCellHeight - s - 1;\n              this._ctx.moveTo(r, o);\n              for (let t = 0; t < i; t++) {\n                const s = (e + i + t) * this._scaledCellWidth;\n                this._ctx.lineTo(s, o);\n              }\n              this._ctx.stroke(), this._ctx.closePath(), this._ctx.restore();\n            }\n            _dashedUnderlineAtCell(e, t, i = 1) {\n              this._ctx.save(), this._ctx.beginPath(), this._ctx.strokeStyle = this._ctx.fillStyle;\n              const s = this._coreBrowserService.dpr;\n              this._ctx.lineWidth = s, this._ctx.setLineDash([4 * s, 3 * s]);\n              const r = e * this._scaledCellWidth,\n                o = (e + i) * this._scaledCellWidth,\n                n = (t + 1) * this._scaledCellHeight - s - 1;\n              this._ctx.moveTo(r, n), this._ctx.lineTo(o, n), this._ctx.stroke(), this._ctx.closePath(), this._ctx.restore();\n            }\n            _fillLeftLineAtCell(e, t, i) {\n              this._ctx.fillRect(e * this._scaledCellWidth, t * this._scaledCellHeight, this._coreBrowserService.dpr * i, this._scaledCellHeight);\n            }\n            _strokeRectAtCell(e, t, i, s) {\n              const r = this._coreBrowserService.dpr;\n              this._ctx.lineWidth = r, this._ctx.strokeRect(e * this._scaledCellWidth + r / 2, t * this._scaledCellHeight + r / 2, i * this._scaledCellWidth - r, s * this._scaledCellHeight - r);\n            }\n            _clearAll() {\n              this._alpha ? this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height) : (this._ctx.fillStyle = this._colors.background.css, this._ctx.fillRect(0, 0, this._canvas.width, this._canvas.height));\n            }\n            _clearCells(e, t, i, s) {\n              this._alpha ? this._ctx.clearRect(e * this._scaledCellWidth, t * this._scaledCellHeight, i * this._scaledCellWidth, s * this._scaledCellHeight) : (this._ctx.fillStyle = this._colors.background.css, this._ctx.fillRect(e * this._scaledCellWidth, t * this._scaledCellHeight, i * this._scaledCellWidth, s * this._scaledCellHeight));\n            }\n            _fillCharTrueColor(e, t, i) {\n              this._ctx.font = this._getFont(!1, !1), this._ctx.textBaseline = r.TEXT_BASELINE, this._clipRow(i);\n              let s = !1;\n              !1 !== this._optionsService.rawOptions.customGlyphs && (s = (0, c.tryDrawCustomChar)(this._ctx, e.getChars(), t * this._scaledCellWidth, i * this._scaledCellHeight, this._scaledCellWidth, this._scaledCellHeight, this._optionsService.rawOptions.fontSize, this._coreBrowserService.dpr)), s || this._ctx.fillText(e.getChars(), t * this._scaledCellWidth + this._scaledCharLeft, i * this._scaledCellHeight + this._scaledCharTop + this._scaledCharHeight);\n            }\n            _drawChars(e, t, i) {\n              var o;\n              const n = this._getContrastColor(e, t, i);\n              if (n || e.isFgRGB() || e.isBgRGB()) return void this._drawUncachedChars(e, t, i, n);\n              let a, l;\n              e.isInverse() ? (a = e.isBgDefault() ? r.INVERTED_DEFAULT_COLOR : e.getBgColor(), l = e.isFgDefault() ? r.INVERTED_DEFAULT_COLOR : e.getFgColor()) : (l = e.isBgDefault() ? s.DEFAULT_COLOR : e.getBgColor(), a = e.isFgDefault() ? s.DEFAULT_COLOR : e.getFgColor()), a += this._optionsService.rawOptions.drawBoldTextInBrightColors && e.isBold() && a < 8 ? 8 : 0, this._currentGlyphIdentifier.chars = e.getChars() || s.WHITESPACE_CELL_CHAR, this._currentGlyphIdentifier.code = e.getCode() || s.WHITESPACE_CELL_CODE, this._currentGlyphIdentifier.bg = l, this._currentGlyphIdentifier.fg = a, this._currentGlyphIdentifier.bold = !!e.isBold(), this._currentGlyphIdentifier.dim = !!e.isDim(), this._currentGlyphIdentifier.italic = !!e.isItalic();\n              let h = !1;\n              this._decorationService.forEachDecorationAtCell(t, i, void 0, e => {\n                (e.backgroundColorRGB || e.foregroundColorRGB) && (h = !0);\n              }), !h && (null === (o = this._charAtlas) || void 0 === o ? void 0 : o.draw(this._ctx, this._currentGlyphIdentifier, t * this._scaledCellWidth + this._scaledCharLeft, i * this._scaledCellHeight + this._scaledCharTop)) || this._drawUncachedChars(e, t, i);\n            }\n            _drawUncachedChars(e, t, i, s) {\n              if (this._ctx.save(), this._ctx.font = this._getFont(!!e.isBold(), !!e.isItalic()), this._ctx.textBaseline = r.TEXT_BASELINE, e.isInverse()) {\n                if (s) this._ctx.fillStyle = s.css;else if (e.isBgDefault()) this._ctx.fillStyle = l.color.opaque(this._colors.background).css;else if (e.isBgRGB()) this._ctx.fillStyle = `rgb(${n.AttributeData.toColorRGB(e.getBgColor()).join(\",\")})`;else {\n                  let t = e.getBgColor();\n                  this._optionsService.rawOptions.drawBoldTextInBrightColors && e.isBold() && t < 8 && (t += 8), this._ctx.fillStyle = this._colors.ansi[t].css;\n                }\n              } else if (s) this._ctx.fillStyle = s.css;else if (e.isFgDefault()) this._ctx.fillStyle = this._colors.foreground.css;else if (e.isFgRGB()) this._ctx.fillStyle = `rgb(${n.AttributeData.toColorRGB(e.getFgColor()).join(\",\")})`;else {\n                let t = e.getFgColor();\n                this._optionsService.rawOptions.drawBoldTextInBrightColors && e.isBold() && t < 8 && (t += 8), this._ctx.fillStyle = this._colors.ansi[t].css;\n              }\n              this._clipRow(i), e.isDim() && (this._ctx.globalAlpha = r.DIM_OPACITY);\n              let o = !1;\n              !1 !== this._optionsService.rawOptions.customGlyphs && (o = (0, c.tryDrawCustomChar)(this._ctx, e.getChars(), t * this._scaledCellWidth, i * this._scaledCellHeight, this._scaledCellWidth, this._scaledCellHeight, this._optionsService.rawOptions.fontSize, this._coreBrowserService.dpr)), o || this._ctx.fillText(e.getChars(), t * this._scaledCellWidth + this._scaledCharLeft, i * this._scaledCellHeight + this._scaledCharTop + this._scaledCharHeight), this._ctx.restore();\n            }\n            _clipRow(e) {\n              this._ctx.beginPath(), this._ctx.rect(0, e * this._scaledCellHeight, this._bufferService.cols * this._scaledCellWidth, this._scaledCellHeight), this._ctx.clip();\n            }\n            _getFont(e, t) {\n              return `${t ? \"italic\" : \"\"} ${e ? this._optionsService.rawOptions.fontWeightBold : this._optionsService.rawOptions.fontWeight} ${this._optionsService.rawOptions.fontSize * this._coreBrowserService.dpr}px ${this._optionsService.rawOptions.fontFamily}`;\n            }\n            _getContrastColor(e, t, i) {\n              let s,\n                r,\n                o = !1;\n              if (this._decorationService.forEachDecorationAtCell(t, i, void 0, e => {\n                \"top\" !== e.options.layer && o || (e.backgroundColorRGB && (s = e.backgroundColorRGB.rgba), e.foregroundColorRGB && (r = e.foregroundColorRGB.rgba), o = \"top\" === e.options.layer);\n              }), o || this._colors.selectionForeground && this._isCellInSelection(t, i) && (r = this._colors.selectionForeground.rgba), !s && !r && (1 === this._optionsService.rawOptions.minimumContrastRatio || (0, a.excludeFromContrastRatioDemands)(e.getCode()))) return;\n              if (!s && !r) {\n                const t = this._colors.contrastCache.getColor(e.bg, e.fg);\n                if (void 0 !== t) return t || void 0;\n              }\n              let n = e.getFgColor(),\n                h = e.getFgColorMode(),\n                c = e.getBgColor(),\n                d = e.getBgColorMode();\n              const _ = !!e.isInverse(),\n                u = !!e.isInverse();\n              if (_) {\n                const e = n;\n                n = c, c = e;\n                const t = h;\n                h = d, d = t;\n              }\n              const f = this._resolveBackgroundRgba(void 0 !== s ? 50331648 : d, null != s ? s : c, _),\n                g = this._resolveForegroundRgba(h, n, _, u);\n              let C = l.rgba.ensureContrastRatio(null != s ? s : f, null != r ? r : g, this._optionsService.rawOptions.minimumContrastRatio);\n              if (!C) {\n                if (!r) return void this._colors.contrastCache.setColor(e.bg, e.fg, null);\n                C = r;\n              }\n              const p = {\n                css: l.channels.toCss(C >> 24 & 255, C >> 16 & 255, C >> 8 & 255),\n                rgba: C\n              };\n              return s || r || this._colors.contrastCache.setColor(e.bg, e.fg, p), p;\n            }\n            _resolveBackgroundRgba(e, t, i) {\n              switch (e) {\n                case 16777216:\n                case 33554432:\n                  return this._colors.ansi[t].rgba;\n                case 50331648:\n                  return t << 8;\n                default:\n                  return i ? this._colors.foreground.rgba : this._colors.background.rgba;\n              }\n            }\n            _resolveForegroundRgba(e, t, i, s) {\n              switch (e) {\n                case 16777216:\n                case 33554432:\n                  return this._optionsService.rawOptions.drawBoldTextInBrightColors && s && t < 8 && (t += 8), this._colors.ansi[t].rgba;\n                case 50331648:\n                  return t << 8;\n                default:\n                  return i ? this._colors.background.rgba : this._colors.foreground.rgba;\n              }\n            }\n            _isCellInSelection(e, t) {\n              const i = this._selectionStart,\n                s = this._selectionEnd;\n              return !(!i || !s) && (this._columnSelectMode ? e >= i[0] && t >= i[1] && e < s[0] && t < s[1] : t > i[1] && t < s[1] || i[1] === s[1] && t === i[1] && e >= i[0] && e < s[0] || i[1] < s[1] && t === s[1] && e < s[0] || i[1] < s[1] && t === i[1] && e >= i[0]);\n            }\n          };\n        },\n        949: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.CanvasRenderer = void 0;\n          const s = i(744),\n            r = i(630),\n            o = i(873),\n            n = i(43),\n            a = i(859),\n            l = i(713),\n            h = i(345),\n            c = i(476);\n          let d = 1;\n          class _ extends a.Disposable {\n            constructor(e, t, i, a, l, _, u, f, g, C) {\n              super(), this._colors = e, this._screenElement = t, this._bufferService = a, this._charSizeService = l, this._optionsService = _, this._coreBrowserService = g, this._id = d++, this._onRequestRedraw = new h.EventEmitter();\n              const p = this._optionsService.rawOptions.allowTransparency;\n              this._renderLayers = [new s.TextRenderLayer(this._screenElement, 0, this._colors, p, this._id, this._bufferService, this._optionsService, u, C, this._coreBrowserService), new r.SelectionRenderLayer(this._screenElement, 1, this._colors, this._id, this._bufferService, this._coreBrowserService, C, this._optionsService), new n.LinkRenderLayer(this._screenElement, 2, this._colors, this._id, i, this._bufferService, this._optionsService, C, this._coreBrowserService), new o.CursorRenderLayer(this._screenElement, 3, this._colors, this._id, this._onRequestRedraw, this._bufferService, this._optionsService, f, this._coreBrowserService, C)], this.dimensions = {\n                scaledCharWidth: 0,\n                scaledCharHeight: 0,\n                scaledCellWidth: 0,\n                scaledCellHeight: 0,\n                scaledCharLeft: 0,\n                scaledCharTop: 0,\n                scaledCanvasWidth: 0,\n                scaledCanvasHeight: 0,\n                canvasWidth: 0,\n                canvasHeight: 0,\n                actualCellWidth: 0,\n                actualCellHeight: 0\n              }, this._devicePixelRatio = this._coreBrowserService.dpr, this._updateDimensions(), this.register((0, c.observeDevicePixelDimensions)(this._renderLayers[0].canvas, this._coreBrowserService.window, (e, t) => this._setCanvasDevicePixelDimensions(e, t))), this.onOptionsChanged();\n            }\n            get onRequestRedraw() {\n              return this._onRequestRedraw.event;\n            }\n            dispose() {\n              for (const e of this._renderLayers) e.dispose();\n              super.dispose(), (0, l.removeTerminalFromCache)(this._id);\n            }\n            onDevicePixelRatioChange() {\n              this._devicePixelRatio !== this._coreBrowserService.dpr && (this._devicePixelRatio = this._coreBrowserService.dpr, this.onResize(this._bufferService.cols, this._bufferService.rows));\n            }\n            setColors(e) {\n              this._colors = e;\n              for (const e of this._renderLayers) e.setColors(this._colors), e.reset();\n            }\n            onResize(e, t) {\n              this._updateDimensions();\n              for (const e of this._renderLayers) e.resize(this.dimensions);\n              this._screenElement.style.width = `${this.dimensions.canvasWidth}px`, this._screenElement.style.height = `${this.dimensions.canvasHeight}px`;\n            }\n            onCharSizeChanged() {\n              this.onResize(this._bufferService.cols, this._bufferService.rows);\n            }\n            onBlur() {\n              this._runOperation(e => e.onBlur());\n            }\n            onFocus() {\n              this._runOperation(e => e.onFocus());\n            }\n            onSelectionChanged(e, t, i = !1) {\n              this._runOperation(s => s.onSelectionChanged(e, t, i)), this._colors.selectionForeground && this._onRequestRedraw.fire({\n                start: 0,\n                end: this._bufferService.rows - 1\n              });\n            }\n            onCursorMove() {\n              this._runOperation(e => e.onCursorMove());\n            }\n            onOptionsChanged() {\n              this._runOperation(e => e.onOptionsChanged());\n            }\n            clear() {\n              this._runOperation(e => e.reset());\n            }\n            _runOperation(e) {\n              for (const t of this._renderLayers) e(t);\n            }\n            renderRows(e, t) {\n              for (const i of this._renderLayers) i.onGridChanged(e, t);\n            }\n            clearTextureAtlas() {\n              for (const e of this._renderLayers) e.clearTextureAtlas();\n            }\n            _updateDimensions() {\n              if (!this._charSizeService.hasValidSize) return;\n              const e = this._coreBrowserService.dpr;\n              this.dimensions.scaledCharWidth = Math.floor(this._charSizeService.width * e), this.dimensions.scaledCharHeight = Math.ceil(this._charSizeService.height * e), this.dimensions.scaledCellHeight = Math.floor(this.dimensions.scaledCharHeight * this._optionsService.rawOptions.lineHeight), this.dimensions.scaledCharTop = 1 === this._optionsService.rawOptions.lineHeight ? 0 : Math.round((this.dimensions.scaledCellHeight - this.dimensions.scaledCharHeight) / 2), this.dimensions.scaledCellWidth = this.dimensions.scaledCharWidth + Math.round(this._optionsService.rawOptions.letterSpacing), this.dimensions.scaledCharLeft = Math.floor(this._optionsService.rawOptions.letterSpacing / 2), this.dimensions.scaledCanvasHeight = this._bufferService.rows * this.dimensions.scaledCellHeight, this.dimensions.scaledCanvasWidth = this._bufferService.cols * this.dimensions.scaledCellWidth, this.dimensions.canvasHeight = Math.round(this.dimensions.scaledCanvasHeight / e), this.dimensions.canvasWidth = Math.round(this.dimensions.scaledCanvasWidth / e), this.dimensions.actualCellHeight = this.dimensions.canvasHeight / this._bufferService.rows, this.dimensions.actualCellWidth = this.dimensions.canvasWidth / this._bufferService.cols;\n            }\n            _setCanvasDevicePixelDimensions(e, t) {\n              this.dimensions.scaledCanvasHeight = t, this.dimensions.scaledCanvasWidth = e;\n              for (const e of this._renderLayers) e.resize(this.dimensions);\n              this._requestRedrawViewport();\n            }\n            _requestRedrawViewport() {\n              this._onRequestRedraw.fire({\n                start: 0,\n                end: this._bufferService.rows - 1\n              });\n            }\n          }\n          t.CanvasRenderer = _;\n        },\n        873: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.CursorRenderLayer = void 0;\n          const s = i(903),\n            r = i(782);\n          class o extends s.BaseRenderLayer {\n            constructor(e, t, i, s, o, n, a, l, h, c) {\n              super(e, \"cursor\", t, !0, i, s, n, a, c, h), this._onRequestRedraw = o, this._coreService = l, this._cell = new r.CellData(), this._state = {\n                x: 0,\n                y: 0,\n                isFocused: !1,\n                style: \"\",\n                width: 0\n              }, this._cursorRenderers = {\n                bar: this._renderBarCursor.bind(this),\n                block: this._renderBlockCursor.bind(this),\n                underline: this._renderUnderlineCursor.bind(this)\n              };\n            }\n            dispose() {\n              this._cursorBlinkStateManager && (this._cursorBlinkStateManager.dispose(), this._cursorBlinkStateManager = void 0), super.dispose();\n            }\n            resize(e) {\n              super.resize(e), this._state = {\n                x: 0,\n                y: 0,\n                isFocused: !1,\n                style: \"\",\n                width: 0\n              };\n            }\n            reset() {\n              var e;\n              this._clearCursor(), null === (e = this._cursorBlinkStateManager) || void 0 === e || e.restartBlinkAnimation(), this.onOptionsChanged();\n            }\n            onBlur() {\n              var e;\n              null === (e = this._cursorBlinkStateManager) || void 0 === e || e.pause(), this._onRequestRedraw.fire({\n                start: this._bufferService.buffer.y,\n                end: this._bufferService.buffer.y\n              });\n            }\n            onFocus() {\n              var e;\n              null === (e = this._cursorBlinkStateManager) || void 0 === e || e.resume(), this._onRequestRedraw.fire({\n                start: this._bufferService.buffer.y,\n                end: this._bufferService.buffer.y\n              });\n            }\n            onOptionsChanged() {\n              var e;\n              this._optionsService.rawOptions.cursorBlink ? this._cursorBlinkStateManager || (this._cursorBlinkStateManager = new n(this._coreBrowserService.isFocused, () => {\n                this._render(!0);\n              }, this._coreBrowserService)) : (null === (e = this._cursorBlinkStateManager) || void 0 === e || e.dispose(), this._cursorBlinkStateManager = void 0), this._onRequestRedraw.fire({\n                start: this._bufferService.buffer.y,\n                end: this._bufferService.buffer.y\n              });\n            }\n            onCursorMove() {\n              var e;\n              null === (e = this._cursorBlinkStateManager) || void 0 === e || e.restartBlinkAnimation();\n            }\n            onGridChanged(e, t) {\n              !this._cursorBlinkStateManager || this._cursorBlinkStateManager.isPaused ? this._render(!1) : this._cursorBlinkStateManager.restartBlinkAnimation();\n            }\n            _render(e) {\n              if (!this._coreService.isCursorInitialized || this._coreService.isCursorHidden) return void this._clearCursor();\n              const t = this._bufferService.buffer.ybase + this._bufferService.buffer.y,\n                i = t - this._bufferService.buffer.ydisp;\n              if (i < 0 || i >= this._bufferService.rows) return void this._clearCursor();\n              const s = Math.min(this._bufferService.buffer.x, this._bufferService.cols - 1);\n              if (this._bufferService.buffer.lines.get(t).loadCell(s, this._cell), void 0 !== this._cell.content) {\n                if (!this._coreBrowserService.isFocused) {\n                  this._clearCursor(), this._ctx.save(), this._ctx.fillStyle = this._colors.cursor.css;\n                  const e = this._optionsService.rawOptions.cursorStyle;\n                  return e && \"block\" !== e ? this._cursorRenderers[e](s, i, this._cell) : this._renderBlurCursor(s, i, this._cell), this._ctx.restore(), this._state.x = s, this._state.y = i, this._state.isFocused = !1, this._state.style = e, void (this._state.width = this._cell.getWidth());\n                }\n                if (!this._cursorBlinkStateManager || this._cursorBlinkStateManager.isCursorVisible) {\n                  if (this._state) {\n                    if (this._state.x === s && this._state.y === i && this._state.isFocused === this._coreBrowserService.isFocused && this._state.style === this._optionsService.rawOptions.cursorStyle && this._state.width === this._cell.getWidth()) return;\n                    this._clearCursor();\n                  }\n                  this._ctx.save(), this._cursorRenderers[this._optionsService.rawOptions.cursorStyle || \"block\"](s, i, this._cell), this._ctx.restore(), this._state.x = s, this._state.y = i, this._state.isFocused = !1, this._state.style = this._optionsService.rawOptions.cursorStyle, this._state.width = this._cell.getWidth();\n                } else this._clearCursor();\n              }\n            }\n            _clearCursor() {\n              this._state && (this._coreBrowserService.dpr < 1 ? this._clearAll() : this._clearCells(this._state.x, this._state.y, this._state.width, 1), this._state = {\n                x: 0,\n                y: 0,\n                isFocused: !1,\n                style: \"\",\n                width: 0\n              });\n            }\n            _renderBarCursor(e, t, i) {\n              this._ctx.save(), this._ctx.fillStyle = this._colors.cursor.css, this._fillLeftLineAtCell(e, t, this._optionsService.rawOptions.cursorWidth), this._ctx.restore();\n            }\n            _renderBlockCursor(e, t, i) {\n              this._ctx.save(), this._ctx.fillStyle = this._colors.cursor.css, this._fillCells(e, t, i.getWidth(), 1), this._ctx.fillStyle = this._colors.cursorAccent.css, this._fillCharTrueColor(i, e, t), this._ctx.restore();\n            }\n            _renderUnderlineCursor(e, t, i) {\n              this._ctx.save(), this._ctx.fillStyle = this._colors.cursor.css, this._fillBottomLineAtCells(e, t), this._ctx.restore();\n            }\n            _renderBlurCursor(e, t, i) {\n              this._ctx.save(), this._ctx.strokeStyle = this._colors.cursor.css, this._strokeRectAtCell(e, t, i.getWidth(), 1), this._ctx.restore();\n            }\n          }\n          t.CursorRenderLayer = o;\n          class n {\n            constructor(e, t, i) {\n              this._renderCallback = t, this._coreBrowserService = i, this.isCursorVisible = !0, e && this._restartInterval();\n            }\n            get isPaused() {\n              return !(this._blinkStartTimeout || this._blinkInterval);\n            }\n            dispose() {\n              this._blinkInterval && (this._coreBrowserService.window.clearInterval(this._blinkInterval), this._blinkInterval = void 0), this._blinkStartTimeout && (this._coreBrowserService.window.clearTimeout(this._blinkStartTimeout), this._blinkStartTimeout = void 0), this._animationFrame && (this._coreBrowserService.window.cancelAnimationFrame(this._animationFrame), this._animationFrame = void 0);\n            }\n            restartBlinkAnimation() {\n              this.isPaused || (this._animationTimeRestarted = Date.now(), this.isCursorVisible = !0, this._animationFrame || (this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(() => {\n                this._renderCallback(), this._animationFrame = void 0;\n              })));\n            }\n            _restartInterval(e = 600) {\n              this._blinkInterval && (this._coreBrowserService.window.clearInterval(this._blinkInterval), this._blinkInterval = void 0), this._blinkStartTimeout = this._coreBrowserService.window.setTimeout(() => {\n                if (this._animationTimeRestarted) {\n                  const e = 600 - (Date.now() - this._animationTimeRestarted);\n                  if (this._animationTimeRestarted = void 0, e > 0) return void this._restartInterval(e);\n                }\n                this.isCursorVisible = !1, this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(() => {\n                  this._renderCallback(), this._animationFrame = void 0;\n                }), this._blinkInterval = this._coreBrowserService.window.setInterval(() => {\n                  if (this._animationTimeRestarted) {\n                    const e = 600 - (Date.now() - this._animationTimeRestarted);\n                    return this._animationTimeRestarted = void 0, void this._restartInterval(e);\n                  }\n                  this.isCursorVisible = !this.isCursorVisible, this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(() => {\n                    this._renderCallback(), this._animationFrame = void 0;\n                  });\n                }, 600);\n              }, e);\n            }\n            pause() {\n              this.isCursorVisible = !0, this._blinkInterval && (this._coreBrowserService.window.clearInterval(this._blinkInterval), this._blinkInterval = void 0), this._blinkStartTimeout && (this._coreBrowserService.window.clearTimeout(this._blinkStartTimeout), this._blinkStartTimeout = void 0), this._animationFrame && (this._coreBrowserService.window.cancelAnimationFrame(this._animationFrame), this._animationFrame = void 0);\n            }\n            resume() {\n              this.pause(), this._animationTimeRestarted = void 0, this._restartInterval(), this.restartBlinkAnimation();\n            }\n          }\n        },\n        574: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.GridCache = void 0, t.GridCache = class {\n            constructor() {\n              this.cache = [];\n            }\n            resize(e, t) {\n              for (let i = 0; i < e; i++) {\n                this.cache.length <= i && this.cache.push([]);\n                for (let e = this.cache[i].length; e < t; e++) this.cache[i].push(void 0);\n                this.cache[i].length = t;\n              }\n              this.cache.length = e;\n            }\n            clear() {\n              for (let e = 0; e < this.cache.length; e++) for (let t = 0; t < this.cache[e].length; t++) this.cache[e][t] = void 0;\n            }\n          };\n        },\n        43: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.LinkRenderLayer = void 0;\n          const s = i(903),\n            r = i(302),\n            o = i(433);\n          class n extends s.BaseRenderLayer {\n            constructor(e, t, i, s, r, o, n, a, l) {\n              super(e, \"link\", t, !0, i, s, o, n, a, l), r.onShowLinkUnderline(e => this._onShowLinkUnderline(e)), r.onHideLinkUnderline(e => this._onHideLinkUnderline(e));\n            }\n            resize(e) {\n              super.resize(e), this._state = void 0;\n            }\n            reset() {\n              this._clearCurrentLink();\n            }\n            _clearCurrentLink() {\n              if (this._state) {\n                this._clearCells(this._state.x1, this._state.y1, this._state.cols - this._state.x1, 1);\n                const e = this._state.y2 - this._state.y1 - 1;\n                e > 0 && this._clearCells(0, this._state.y1 + 1, this._state.cols, e), this._clearCells(0, this._state.y2, this._state.x2, 1), this._state = void 0;\n              }\n            }\n            _onShowLinkUnderline(e) {\n              if (e.fg === r.INVERTED_DEFAULT_COLOR ? this._ctx.fillStyle = this._colors.background.css : e.fg && (0, o.is256Color)(e.fg) ? this._ctx.fillStyle = this._colors.ansi[e.fg].css : this._ctx.fillStyle = this._colors.foreground.css, e.y1 === e.y2) this._fillBottomLineAtCells(e.x1, e.y1, e.x2 - e.x1);else {\n                this._fillBottomLineAtCells(e.x1, e.y1, e.cols - e.x1);\n                for (let t = e.y1 + 1; t < e.y2; t++) this._fillBottomLineAtCells(0, t, e.cols);\n                this._fillBottomLineAtCells(0, e.y2, e.x2);\n              }\n              this._state = e;\n            }\n            _onHideLinkUnderline(e) {\n              this._clearCurrentLink();\n            }\n          }\n          t.LinkRenderLayer = n;\n        },\n        630: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.SelectionRenderLayer = void 0;\n          const s = i(903);\n          class r extends s.BaseRenderLayer {\n            constructor(e, t, i, s, r, o, n, a) {\n              super(e, \"selection\", t, !0, i, s, r, a, n, o), this._clearState();\n            }\n            _clearState() {\n              this._state = {\n                start: void 0,\n                end: void 0,\n                columnSelectMode: void 0,\n                ydisp: void 0\n              };\n            }\n            resize(e) {\n              super.resize(e), this._selectionStart && this._selectionEnd && this._redrawSelection(this._selectionStart, this._selectionEnd, this._columnSelectMode);\n            }\n            reset() {\n              this._state.start && this._state.end && (this._clearState(), this._clearAll());\n            }\n            onBlur() {\n              this.reset(), this._redrawSelection(this._selectionStart, this._selectionEnd, this._columnSelectMode);\n            }\n            onFocus() {\n              this.reset(), this._redrawSelection(this._selectionStart, this._selectionEnd, this._columnSelectMode);\n            }\n            onSelectionChanged(e, t, i) {\n              super.onSelectionChanged(e, t, i), this._redrawSelection(e, t, i);\n            }\n            _redrawSelection(e, t, i) {\n              if (!this._didStateChange(e, t, i, this._bufferService.buffer.ydisp)) return;\n              if (this._clearAll(), !e || !t) return void this._clearState();\n              const s = e[1] - this._bufferService.buffer.ydisp,\n                r = t[1] - this._bufferService.buffer.ydisp,\n                o = Math.max(s, 0),\n                n = Math.min(r, this._bufferService.rows - 1);\n              if (o >= this._bufferService.rows || n < 0) this._state.ydisp = this._bufferService.buffer.ydisp;else {\n                if (this._ctx.fillStyle = (this._coreBrowserService.isFocused ? this._colors.selectionBackgroundTransparent : this._colors.selectionInactiveBackgroundTransparent).css, i) {\n                  const i = e[0],\n                    s = t[0] - i,\n                    r = n - o + 1;\n                  this._fillCells(i, o, s, r);\n                } else {\n                  const i = s === o ? e[0] : 0,\n                    a = o === r ? t[0] : this._bufferService.cols;\n                  this._fillCells(i, o, a - i, 1);\n                  const l = Math.max(n - o - 1, 0);\n                  if (this._fillCells(0, o + 1, this._bufferService.cols, l), o !== n) {\n                    const e = r === n ? t[0] : this._bufferService.cols;\n                    this._fillCells(0, n, e, 1);\n                  }\n                }\n                this._state.start = [e[0], e[1]], this._state.end = [t[0], t[1]], this._state.columnSelectMode = i, this._state.ydisp = this._bufferService.buffer.ydisp;\n              }\n            }\n            _didStateChange(e, t, i, s) {\n              return !this._areCoordinatesEqual(e, this._state.start) || !this._areCoordinatesEqual(t, this._state.end) || i !== this._state.columnSelectMode || s !== this._state.ydisp;\n            }\n            _areCoordinatesEqual(e, t) {\n              return !(!e || !t) && e[0] === t[0] && e[1] === t[1];\n            }\n          }\n          t.SelectionRenderLayer = r;\n        },\n        744: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.TextRenderLayer = void 0;\n          const s = i(574),\n            r = i(903),\n            o = i(147),\n            n = i(855),\n            a = i(782),\n            l = i(577),\n            h = i(160);\n          class c extends r.BaseRenderLayer {\n            constructor(e, t, i, r, o, n, l, h, c, d) {\n              super(e, \"text\", t, r, i, o, n, l, c, d), this._characterJoinerService = h, this._characterWidth = 0, this._characterFont = \"\", this._characterOverlapCache = {}, this._workCell = new a.CellData(), this._state = new s.GridCache();\n            }\n            resize(e) {\n              super.resize(e);\n              const t = this._getFont(!1, !1);\n              this._characterWidth === e.scaledCharWidth && this._characterFont === t || (this._characterWidth = e.scaledCharWidth, this._characterFont = t, this._characterOverlapCache = {}), this._state.clear(), this._state.resize(this._bufferService.cols, this._bufferService.rows);\n            }\n            reset() {\n              this._state.clear(), this._clearAll();\n            }\n            _forEachCell(e, t, i) {\n              for (let s = e; s <= t; s++) {\n                const e = s + this._bufferService.buffer.ydisp,\n                  t = this._bufferService.buffer.lines.get(e),\n                  r = this._characterJoinerService.getJoinedCharacters(e);\n                for (let e = 0; e < this._bufferService.cols; e++) {\n                  t.loadCell(e, this._workCell);\n                  let o = this._workCell,\n                    a = !1,\n                    h = e;\n                  if (0 !== o.getWidth()) {\n                    if (r.length > 0 && e === r[0][0]) {\n                      a = !0;\n                      const e = r.shift();\n                      o = new l.JoinedCellData(this._workCell, t.translateToString(!0, e[0], e[1]), e[1] - e[0]), h = e[1] - 1;\n                    }\n                    !a && this._isOverlapping(o) && h < t.length - 1 && t.getCodePoint(h + 1) === n.NULL_CELL_CODE && (o.content &= -12582913, o.content |= 2 << 22), i(o, e, s), e = h;\n                  }\n                }\n              }\n            }\n            _drawBackground(e, t) {\n              const i = this._ctx,\n                s = this._bufferService.cols;\n              let r = 0,\n                n = 0,\n                a = null;\n              i.save(), this._forEachCell(e, t, (e, t, l) => {\n                let c = null;\n                e.isInverse() ? c = e.isFgDefault() ? this._colors.foreground.css : e.isFgRGB() ? `rgb(${o.AttributeData.toColorRGB(e.getFgColor()).join(\",\")})` : this._colors.ansi[e.getFgColor()].css : e.isBgRGB() ? c = `rgb(${o.AttributeData.toColorRGB(e.getBgColor()).join(\",\")})` : e.isBgPalette() && (c = this._colors.ansi[e.getBgColor()].css), c && e.isDim() && (c = h.color.multiplyOpacity(h.css.toColor(c), .5).css);\n                let d = !1;\n                this._decorationService.forEachDecorationAtCell(t, this._bufferService.buffer.ydisp + l, void 0, e => {\n                  \"top\" !== e.options.layer && d || (e.backgroundColorRGB && (c = e.backgroundColorRGB.css), d = \"top\" === e.options.layer);\n                }), null === a && (r = t, n = l), l !== n ? (i.fillStyle = a || \"\", this._fillCells(r, n, s - r, 1), r = t, n = l) : a !== c && (i.fillStyle = a || \"\", this._fillCells(r, n, t - r, 1), r = t, n = l), a = c;\n              }), null !== a && (i.fillStyle = a, this._fillCells(r, n, s - r, 1)), i.restore();\n            }\n            _drawForeground(e, t) {\n              this._forEachCell(e, t, (e, t, i) => {\n                if (!e.isInvisible() && (this._drawChars(e, t, i), e.isUnderline() || e.isStrikethrough())) {\n                  if (this._ctx.save(), e.isInverse()) {\n                    if (e.isBgDefault()) this._ctx.fillStyle = this._colors.background.css;else if (e.isBgRGB()) this._ctx.fillStyle = `rgb(${o.AttributeData.toColorRGB(e.getBgColor()).join(\",\")})`;else {\n                      let t = e.getBgColor();\n                      this._optionsService.rawOptions.drawBoldTextInBrightColors && e.isBold() && t < 8 && (t += 8), this._ctx.fillStyle = this._colors.ansi[t].css;\n                    }\n                  } else if (e.isFgDefault()) this._ctx.fillStyle = this._colors.foreground.css;else if (e.isFgRGB()) this._ctx.fillStyle = `rgb(${o.AttributeData.toColorRGB(e.getFgColor()).join(\",\")})`;else {\n                    let t = e.getFgColor();\n                    this._optionsService.rawOptions.drawBoldTextInBrightColors && e.isBold() && t < 8 && (t += 8), this._ctx.fillStyle = this._colors.ansi[t].css;\n                  }\n                  if (e.isStrikethrough() && this._fillMiddleLineAtCells(t, i, e.getWidth()), e.isUnderline()) {\n                    if (!e.isUnderlineColorDefault()) if (e.isUnderlineColorRGB()) this._ctx.fillStyle = `rgb(${o.AttributeData.toColorRGB(e.getUnderlineColor()).join(\",\")})`;else {\n                      let t = e.getUnderlineColor();\n                      this._optionsService.rawOptions.drawBoldTextInBrightColors && e.isBold() && t < 8 && (t += 8), this._ctx.fillStyle = this._colors.ansi[t].css;\n                    }\n                    switch (e.extended.underlineStyle) {\n                      case 2:\n                        this._fillBottomLineAtCells(t, i, e.getWidth(), -this._coreBrowserService.dpr), this._fillBottomLineAtCells(t, i, e.getWidth(), this._coreBrowserService.dpr);\n                        break;\n                      case 3:\n                        this._curlyUnderlineAtCell(t, i, e.getWidth());\n                        break;\n                      case 4:\n                        this._dottedUnderlineAtCell(t, i, e.getWidth());\n                        break;\n                      case 5:\n                        this._dashedUnderlineAtCell(t, i, e.getWidth());\n                        break;\n                      default:\n                        this._fillBottomLineAtCells(t, i, e.getWidth());\n                    }\n                  }\n                  this._ctx.restore();\n                }\n              });\n            }\n            onGridChanged(e, t) {\n              0 !== this._state.cache.length && (this._charAtlas && this._charAtlas.beginFrame(), this._clearCells(0, e, this._bufferService.cols, t - e + 1), this._drawBackground(e, t), this._drawForeground(e, t));\n            }\n            onOptionsChanged() {\n              this._setTransparency(this._optionsService.rawOptions.allowTransparency);\n            }\n            _isOverlapping(e) {\n              if (1 !== e.getWidth()) return !1;\n              if (e.getCode() < 256) return !1;\n              const t = e.getChars();\n              if (this._characterOverlapCache.hasOwnProperty(t)) return this._characterOverlapCache[t];\n              this._ctx.save(), this._ctx.font = this._characterFont;\n              const i = Math.floor(this._ctx.measureText(t).width) > this._characterWidth;\n              return this._ctx.restore(), this._characterOverlapCache[t] = i, i;\n            }\n          }\n          t.TextRenderLayer = c;\n        },\n        13: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.BaseCharAtlas = void 0, t.BaseCharAtlas = class {\n            constructor() {\n              this._didWarmUp = !1;\n            }\n            dispose() {}\n            warmUp() {\n              this._didWarmUp || (this._doWarmUp(), this._didWarmUp = !0);\n            }\n            _doWarmUp() {}\n            clear() {}\n            beginFrame() {}\n          };\n        },\n        713: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.removeTerminalFromCache = t.acquireCharAtlas = void 0;\n          const s = i(433),\n            r = i(389),\n            o = [];\n          t.acquireCharAtlas = function (e, t, i, n, a, l) {\n            const h = (0, s.generateConfig)(n, a, e, i, l);\n            for (let e = 0; e < o.length; e++) {\n              const i = o[e],\n                r = i.ownedBy.indexOf(t);\n              if (r >= 0) {\n                if ((0, s.configEquals)(i.config, h)) return i.atlas;\n                1 === i.ownedBy.length ? (i.atlas.dispose(), o.splice(e, 1)) : i.ownedBy.splice(r, 1);\n                break;\n              }\n            }\n            for (let e = 0; e < o.length; e++) {\n              const i = o[e];\n              if ((0, s.configEquals)(i.config, h)) return i.ownedBy.push(t), i.atlas;\n            }\n            const c = {\n              atlas: new r.DynamicCharAtlas(document, h),\n              config: h,\n              ownedBy: [t]\n            };\n            return o.push(c), c.atlas;\n          }, t.removeTerminalFromCache = function (e) {\n            for (let t = 0; t < o.length; t++) {\n              const i = o[t].ownedBy.indexOf(e);\n              if (-1 !== i) {\n                1 === o[t].ownedBy.length ? (o[t].atlas.dispose(), o.splice(t, 1)) : o[t].ownedBy.splice(i, 1);\n                break;\n              }\n            }\n          };\n        },\n        433: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.is256Color = t.configEquals = t.generateConfig = void 0;\n          const s = i(855);\n          t.generateConfig = function (e, t, i, s, r) {\n            const o = {\n              foreground: s.foreground,\n              background: s.background,\n              cursor: void 0,\n              cursorAccent: void 0,\n              selectionBackground: void 0,\n              ansi: s.ansi.slice()\n            };\n            return {\n              devicePixelRatio: r,\n              scaledCharWidth: e,\n              scaledCharHeight: t,\n              fontFamily: i.fontFamily,\n              fontSize: i.fontSize,\n              fontWeight: i.fontWeight,\n              fontWeightBold: i.fontWeightBold,\n              allowTransparency: i.allowTransparency,\n              colors: o\n            };\n          }, t.configEquals = function (e, t) {\n            for (let i = 0; i < e.colors.ansi.length; i++) if (e.colors.ansi[i].rgba !== t.colors.ansi[i].rgba) return !1;\n            return e.devicePixelRatio === t.devicePixelRatio && e.fontFamily === t.fontFamily && e.fontSize === t.fontSize && e.fontWeight === t.fontWeight && e.fontWeightBold === t.fontWeightBold && e.allowTransparency === t.allowTransparency && e.scaledCharWidth === t.scaledCharWidth && e.scaledCharHeight === t.scaledCharHeight && e.colors.foreground === t.colors.foreground && e.colors.background === t.colors.background;\n          }, t.is256Color = function (e) {\n            return e < s.DEFAULT_COLOR;\n          };\n        },\n        389: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.NoneCharAtlas = t.DynamicCharAtlas = t.getGlyphCacheKey = void 0;\n          const s = i(302),\n            r = i(13),\n            o = i(434),\n            n = i(279),\n            a = i(399),\n            l = i(634),\n            h = i(160),\n            c = 1024,\n            d = 1024,\n            _ = {\n              css: \"rgba(0, 0, 0, 0)\",\n              rgba: 0\n            };\n          function u(e) {\n            return e.code << 21 | e.bg << 12 | e.fg << 3 | (e.bold ? 0 : 4) + (e.dim ? 0 : 2) + (e.italic ? 0 : 1);\n          }\n          t.getGlyphCacheKey = u;\n          class f extends r.BaseCharAtlas {\n            constructor(e, t) {\n              super(), this._config = t, this._drawToCacheCount = 0, this._glyphsWaitingOnBitmap = [], this._bitmapCommitTimeout = null, this._bitmap = null, this._cacheCanvas = e.createElement(\"canvas\"), this._cacheCanvas.width = c, this._cacheCanvas.height = d, this._cacheCtx = (0, l.throwIfFalsy)(this._cacheCanvas.getContext(\"2d\", {\n                alpha: !0\n              }));\n              const i = e.createElement(\"canvas\");\n              i.width = this._config.scaledCharWidth, i.height = this._config.scaledCharHeight, this._tmpCtx = (0, l.throwIfFalsy)(i.getContext(\"2d\", {\n                alpha: this._config.allowTransparency\n              })), this._width = Math.floor(c / this._config.scaledCharWidth), this._height = Math.floor(d / this._config.scaledCharHeight);\n              const s = this._width * this._height;\n              this._cacheMap = new n.LRUMap(s), this._cacheMap.prealloc(s);\n            }\n            dispose() {\n              null !== this._bitmapCommitTimeout && (window.clearTimeout(this._bitmapCommitTimeout), this._bitmapCommitTimeout = null);\n            }\n            beginFrame() {\n              this._drawToCacheCount = 0;\n            }\n            clear() {\n              if (this._cacheMap.size > 0) {\n                const e = this._width * this._height;\n                this._cacheMap = new n.LRUMap(e), this._cacheMap.prealloc(e);\n              }\n              this._cacheCtx.clearRect(0, 0, c, d), this._tmpCtx.clearRect(0, 0, this._config.scaledCharWidth, this._config.scaledCharHeight);\n            }\n            draw(e, t, i, s) {\n              if (32 === t.code) return !0;\n              if (!this._canCache(t)) return !1;\n              const r = u(t),\n                o = this._cacheMap.get(r);\n              if (null != o) return this._drawFromCache(e, o, i, s), !0;\n              if (this._drawToCacheCount < 100) {\n                let o;\n                o = this._cacheMap.size < this._cacheMap.capacity ? this._cacheMap.size : this._cacheMap.peek().index;\n                const n = this._drawToCache(t, o);\n                return this._cacheMap.set(r, n), this._drawFromCache(e, n, i, s), !0;\n              }\n              return !1;\n            }\n            _canCache(e) {\n              return e.code < 256;\n            }\n            _toCoordinateX(e) {\n              return e % this._width * this._config.scaledCharWidth;\n            }\n            _toCoordinateY(e) {\n              return Math.floor(e / this._width) * this._config.scaledCharHeight;\n            }\n            _drawFromCache(e, t, i, s) {\n              if (t.isEmpty) return;\n              const r = this._toCoordinateX(t.index),\n                o = this._toCoordinateY(t.index);\n              e.drawImage(t.inBitmap ? this._bitmap : this._cacheCanvas, r, o, this._config.scaledCharWidth, this._config.scaledCharHeight, i, s, this._config.scaledCharWidth, this._config.scaledCharHeight);\n            }\n            _getColorFromAnsiIndex(e) {\n              return e < this._config.colors.ansi.length ? this._config.colors.ansi[e] : o.DEFAULT_ANSI_COLORS[e];\n            }\n            _getBackgroundColor(e) {\n              if (this._config.allowTransparency) return _;\n              let t;\n              return t = e.bg === s.INVERTED_DEFAULT_COLOR ? this._config.colors.foreground : e.bg < 256 ? this._getColorFromAnsiIndex(e.bg) : this._config.colors.background, e.dim && (t = h.color.blend(this._config.colors.background, h.color.multiplyOpacity(t, .5))), t;\n            }\n            _getForegroundColor(e) {\n              return e.fg === s.INVERTED_DEFAULT_COLOR ? h.color.opaque(this._config.colors.background) : e.fg < 256 ? this._getColorFromAnsiIndex(e.fg) : this._config.colors.foreground;\n            }\n            _drawToCache(e, t) {\n              this._drawToCacheCount++, this._tmpCtx.save();\n              const i = this._getBackgroundColor(e);\n              this._tmpCtx.globalCompositeOperation = \"copy\", this._tmpCtx.fillStyle = i.css, this._tmpCtx.fillRect(0, 0, this._config.scaledCharWidth, this._config.scaledCharHeight), this._tmpCtx.globalCompositeOperation = \"source-over\";\n              const r = e.bold ? this._config.fontWeightBold : this._config.fontWeight,\n                o = e.italic ? \"italic\" : \"\";\n              this._tmpCtx.font = `${o} ${r} ${this._config.fontSize * this._config.devicePixelRatio}px ${this._config.fontFamily}`, this._tmpCtx.textBaseline = s.TEXT_BASELINE, this._tmpCtx.fillStyle = this._getForegroundColor(e).css, e.dim && (this._tmpCtx.globalAlpha = s.DIM_OPACITY), this._tmpCtx.fillText(e.chars, 0, this._config.scaledCharHeight);\n              let n = this._tmpCtx.getImageData(0, 0, this._config.scaledCharWidth, this._config.scaledCharHeight),\n                a = !1;\n              if (this._config.allowTransparency || (a = C(n, i)), a && \"_\" === e.chars && !this._config.allowTransparency) for (let t = 1; t <= 5 && (this._tmpCtx.fillText(e.chars, 0, this._config.scaledCharHeight - t), n = this._tmpCtx.getImageData(0, 0, this._config.scaledCharWidth, this._config.scaledCharHeight), a = C(n, i), a); t++);\n              this._tmpCtx.restore();\n              const l = this._toCoordinateX(t),\n                h = this._toCoordinateY(t);\n              this._cacheCtx.putImageData(n, l, h);\n              const c = {\n                index: t,\n                isEmpty: a,\n                inBitmap: !1\n              };\n              return this._addGlyphToBitmap(c), c;\n            }\n            _addGlyphToBitmap(e) {\n              !(\"createImageBitmap\" in window) || a.isFirefox || a.isSafari || (this._glyphsWaitingOnBitmap.push(e), null === this._bitmapCommitTimeout && (this._bitmapCommitTimeout = window.setTimeout(() => this._generateBitmap(), 100)));\n            }\n            _generateBitmap() {\n              const e = this._glyphsWaitingOnBitmap;\n              this._glyphsWaitingOnBitmap = [], window.createImageBitmap(this._cacheCanvas).then(t => {\n                this._bitmap = t;\n                for (let t = 0; t < e.length; t++) e[t].inBitmap = !0;\n              }), this._bitmapCommitTimeout = null;\n            }\n          }\n          t.DynamicCharAtlas = f;\n          class g extends r.BaseCharAtlas {\n            constructor(e, t) {\n              super();\n            }\n            draw(e, t, i, s) {\n              return !1;\n            }\n          }\n          function C(e, t) {\n            let i = !0;\n            const s = t.rgba >>> 24,\n              r = t.rgba >>> 16 & 255,\n              o = t.rgba >>> 8 & 255;\n            for (let t = 0; t < e.data.length; t += 4) Math.abs(e.data[t] - s) + Math.abs(e.data[t + 1] - r) + Math.abs(e.data[t + 2] - o) < 35 ? e.data[t + 3] = 0 : i = !1;\n            return i;\n          }\n          t.NoneCharAtlas = g;\n        },\n        279: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.LRUMap = void 0, t.LRUMap = class {\n            constructor(e) {\n              this.capacity = e, this._map = {}, this._head = null, this._tail = null, this._nodePool = [], this.size = 0;\n            }\n            _unlinkNode(e) {\n              const t = e.prev,\n                i = e.next;\n              e === this._head && (this._head = i), e === this._tail && (this._tail = t), null !== t && (t.next = i), null !== i && (i.prev = t);\n            }\n            _appendNode(e) {\n              const t = this._tail;\n              null !== t && (t.next = e), e.prev = t, e.next = null, this._tail = e, null === this._head && (this._head = e);\n            }\n            prealloc(e) {\n              const t = this._nodePool;\n              for (let i = 0; i < e; i++) t.push({\n                prev: null,\n                next: null,\n                key: null,\n                value: null\n              });\n            }\n            get(e) {\n              const t = this._map[e];\n              return void 0 !== t ? (this._unlinkNode(t), this._appendNode(t), t.value) : null;\n            }\n            peekValue(e) {\n              const t = this._map[e];\n              return void 0 !== t ? t.value : null;\n            }\n            peek() {\n              const e = this._head;\n              return null === e ? null : e.value;\n            }\n            set(e, t) {\n              let i = this._map[e];\n              if (void 0 !== i) i = this._map[e], this._unlinkNode(i), i.value = t;else if (this.size >= this.capacity) i = this._head, this._unlinkNode(i), delete this._map[i.key], i.key = e, i.value = t, this._map[e] = i;else {\n                const s = this._nodePool;\n                s.length > 0 ? (i = s.pop(), i.key = e, i.value = t) : i = {\n                  prev: null,\n                  next: null,\n                  key: e,\n                  value: t\n                }, this._map[e] = i, this.size++;\n              }\n              this._appendNode(i);\n            }\n          };\n        },\n        930: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.ColorContrastCache = void 0;\n          const s = i(485);\n          t.ColorContrastCache = class {\n            constructor() {\n              this._color = new s.TwoKeyMap(), this._css = new s.TwoKeyMap();\n            }\n            setCss(e, t, i) {\n              this._css.set(e, t, i);\n            }\n            getCss(e, t) {\n              return this._css.get(e, t);\n            }\n            setColor(e, t, i) {\n              this._color.set(e, t, i);\n            }\n            getColor(e, t) {\n              return this._color.get(e, t);\n            }\n            clear() {\n              this._color.clear(), this._css.clear();\n            }\n          };\n        },\n        434: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.ColorManager = t.DEFAULT_ANSI_COLORS = void 0;\n          const s = i(160),\n            r = i(930),\n            o = s.css.toColor(\"#ffffff\"),\n            n = s.css.toColor(\"#000000\"),\n            a = s.css.toColor(\"#ffffff\"),\n            l = s.css.toColor(\"#000000\"),\n            h = {\n              css: \"rgba(255, 255, 255, 0.3)\",\n              rgba: 4294967117\n            };\n          t.DEFAULT_ANSI_COLORS = Object.freeze((() => {\n            const e = [s.css.toColor(\"#2e3436\"), s.css.toColor(\"#cc0000\"), s.css.toColor(\"#4e9a06\"), s.css.toColor(\"#c4a000\"), s.css.toColor(\"#3465a4\"), s.css.toColor(\"#75507b\"), s.css.toColor(\"#06989a\"), s.css.toColor(\"#d3d7cf\"), s.css.toColor(\"#555753\"), s.css.toColor(\"#ef2929\"), s.css.toColor(\"#8ae234\"), s.css.toColor(\"#fce94f\"), s.css.toColor(\"#729fcf\"), s.css.toColor(\"#ad7fa8\"), s.css.toColor(\"#34e2e2\"), s.css.toColor(\"#eeeeec\")],\n              t = [0, 95, 135, 175, 215, 255];\n            for (let i = 0; i < 216; i++) {\n              const r = t[i / 36 % 6 | 0],\n                o = t[i / 6 % 6 | 0],\n                n = t[i % 6];\n              e.push({\n                css: s.channels.toCss(r, o, n),\n                rgba: s.channels.toRgba(r, o, n)\n              });\n            }\n            for (let t = 0; t < 24; t++) {\n              const i = 8 + 10 * t;\n              e.push({\n                css: s.channels.toCss(i, i, i),\n                rgba: s.channels.toRgba(i, i, i)\n              });\n            }\n            return e;\n          })()), t.ColorManager = class {\n            constructor(e, i) {\n              this.allowTransparency = i;\n              const c = e.createElement(\"canvas\");\n              c.width = 1, c.height = 1;\n              const d = c.getContext(\"2d\");\n              if (!d) throw new Error(\"Could not get rendering context\");\n              this._ctx = d, this._ctx.globalCompositeOperation = \"copy\", this._litmusColor = this._ctx.createLinearGradient(0, 0, 1, 1), this._contrastCache = new r.ColorContrastCache(), this.colors = {\n                foreground: o,\n                background: n,\n                cursor: a,\n                cursorAccent: l,\n                selectionForeground: void 0,\n                selectionBackgroundTransparent: h,\n                selectionBackgroundOpaque: s.color.blend(n, h),\n                selectionInactiveBackgroundTransparent: h,\n                selectionInactiveBackgroundOpaque: s.color.blend(n, h),\n                ansi: t.DEFAULT_ANSI_COLORS.slice(),\n                contrastCache: this._contrastCache\n              }, this._updateRestoreColors();\n            }\n            onOptionsChange(e, t) {\n              switch (e) {\n                case \"minimumContrastRatio\":\n                  this._contrastCache.clear();\n                  break;\n                case \"allowTransparency\":\n                  this.allowTransparency = t;\n              }\n            }\n            setTheme(e = {}) {\n              this.colors.foreground = this._parseColor(e.foreground, o), this.colors.background = this._parseColor(e.background, n), this.colors.cursor = this._parseColor(e.cursor, a, !0), this.colors.cursorAccent = this._parseColor(e.cursorAccent, l, !0), this.colors.selectionBackgroundTransparent = this._parseColor(e.selectionBackground, h, !0), this.colors.selectionBackgroundOpaque = s.color.blend(this.colors.background, this.colors.selectionBackgroundTransparent), this.colors.selectionInactiveBackgroundTransparent = this._parseColor(e.selectionInactiveBackground, this.colors.selectionBackgroundTransparent, !0), this.colors.selectionInactiveBackgroundOpaque = s.color.blend(this.colors.background, this.colors.selectionInactiveBackgroundTransparent);\n              const i = {\n                css: \"\",\n                rgba: 0\n              };\n              if (this.colors.selectionForeground = e.selectionForeground ? this._parseColor(e.selectionForeground, i) : void 0, this.colors.selectionForeground === i && (this.colors.selectionForeground = void 0), s.color.isOpaque(this.colors.selectionBackgroundTransparent)) {\n                const e = .3;\n                this.colors.selectionBackgroundTransparent = s.color.opacity(this.colors.selectionBackgroundTransparent, e);\n              }\n              if (s.color.isOpaque(this.colors.selectionInactiveBackgroundTransparent)) {\n                const e = .3;\n                this.colors.selectionInactiveBackgroundTransparent = s.color.opacity(this.colors.selectionInactiveBackgroundTransparent, e);\n              }\n              if (this.colors.ansi = t.DEFAULT_ANSI_COLORS.slice(), this.colors.ansi[0] = this._parseColor(e.black, t.DEFAULT_ANSI_COLORS[0]), this.colors.ansi[1] = this._parseColor(e.red, t.DEFAULT_ANSI_COLORS[1]), this.colors.ansi[2] = this._parseColor(e.green, t.DEFAULT_ANSI_COLORS[2]), this.colors.ansi[3] = this._parseColor(e.yellow, t.DEFAULT_ANSI_COLORS[3]), this.colors.ansi[4] = this._parseColor(e.blue, t.DEFAULT_ANSI_COLORS[4]), this.colors.ansi[5] = this._parseColor(e.magenta, t.DEFAULT_ANSI_COLORS[5]), this.colors.ansi[6] = this._parseColor(e.cyan, t.DEFAULT_ANSI_COLORS[6]), this.colors.ansi[7] = this._parseColor(e.white, t.DEFAULT_ANSI_COLORS[7]), this.colors.ansi[8] = this._parseColor(e.brightBlack, t.DEFAULT_ANSI_COLORS[8]), this.colors.ansi[9] = this._parseColor(e.brightRed, t.DEFAULT_ANSI_COLORS[9]), this.colors.ansi[10] = this._parseColor(e.brightGreen, t.DEFAULT_ANSI_COLORS[10]), this.colors.ansi[11] = this._parseColor(e.brightYellow, t.DEFAULT_ANSI_COLORS[11]), this.colors.ansi[12] = this._parseColor(e.brightBlue, t.DEFAULT_ANSI_COLORS[12]), this.colors.ansi[13] = this._parseColor(e.brightMagenta, t.DEFAULT_ANSI_COLORS[13]), this.colors.ansi[14] = this._parseColor(e.brightCyan, t.DEFAULT_ANSI_COLORS[14]), this.colors.ansi[15] = this._parseColor(e.brightWhite, t.DEFAULT_ANSI_COLORS[15]), e.extendedAnsi) {\n                const i = Math.min(this.colors.ansi.length - 16, e.extendedAnsi.length);\n                for (let s = 0; s < i; s++) this.colors.ansi[s + 16] = this._parseColor(e.extendedAnsi[s], t.DEFAULT_ANSI_COLORS[s + 16]);\n              }\n              this._contrastCache.clear(), this._updateRestoreColors();\n            }\n            restoreColor(e) {\n              if (void 0 !== e) switch (e) {\n                case 256:\n                  this.colors.foreground = this._restoreColors.foreground;\n                  break;\n                case 257:\n                  this.colors.background = this._restoreColors.background;\n                  break;\n                case 258:\n                  this.colors.cursor = this._restoreColors.cursor;\n                  break;\n                default:\n                  this.colors.ansi[e] = this._restoreColors.ansi[e];\n              } else for (let e = 0; e < this._restoreColors.ansi.length; ++e) this.colors.ansi[e] = this._restoreColors.ansi[e];\n            }\n            _updateRestoreColors() {\n              this._restoreColors = {\n                foreground: this.colors.foreground,\n                background: this.colors.background,\n                cursor: this.colors.cursor,\n                ansi: this.colors.ansi.slice()\n              };\n            }\n            _parseColor(e, t, i = this.allowTransparency) {\n              if (void 0 === e) return t;\n              if (this._ctx.fillStyle = this._litmusColor, this._ctx.fillStyle = e, \"string\" != typeof this._ctx.fillStyle) return console.warn(`Color: ${e} is invalid using fallback ${t.css}`), t;\n              this._ctx.fillRect(0, 0, 1, 1);\n              const r = this._ctx.getImageData(0, 0, 1, 1).data;\n              if (255 !== r[3]) {\n                if (!i) return console.warn(`Color: ${e} is using transparency, but allowTransparency is false. Using fallback ${t.css}.`), t;\n                const [r, o, n, a] = this._ctx.fillStyle.substring(5, this._ctx.fillStyle.length - 1).split(\",\").map(e => Number(e)),\n                  l = Math.round(255 * a);\n                return {\n                  rgba: s.channels.toRgba(r, o, n, l),\n                  css: e\n                };\n              }\n              return {\n                css: this._ctx.fillStyle,\n                rgba: s.channels.toRgba(r[0], r[1], r[2], r[3])\n              };\n            }\n          };\n        },\n        503: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.removeElementFromParent = void 0, t.removeElementFromParent = function (...e) {\n            var t;\n            for (const i of e) null === (t = null == i ? void 0 : i.parentElement) || void 0 === t || t.removeChild(i);\n          };\n        },\n        302: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.TEXT_BASELINE = t.DIM_OPACITY = t.INVERTED_DEFAULT_COLOR = void 0;\n          const s = i(399);\n          t.INVERTED_DEFAULT_COLOR = 257, t.DIM_OPACITY = .5, t.TEXT_BASELINE = s.isFirefox || s.isLegacyEdge ? \"bottom\" : \"ideographic\";\n        },\n        14: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.tryDrawCustomChar = t.powerlineDefinitions = t.boxDrawingDefinitions = t.blockElementDefinitions = void 0;\n          const s = i(634);\n          t.blockElementDefinitions = {\n            \"▀\": [{\n              x: 0,\n              y: 0,\n              w: 8,\n              h: 4\n            }],\n            \"▁\": [{\n              x: 0,\n              y: 7,\n              w: 8,\n              h: 1\n            }],\n            \"▂\": [{\n              x: 0,\n              y: 6,\n              w: 8,\n              h: 2\n            }],\n            \"▃\": [{\n              x: 0,\n              y: 5,\n              w: 8,\n              h: 3\n            }],\n            \"▄\": [{\n              x: 0,\n              y: 4,\n              w: 8,\n              h: 4\n            }],\n            \"▅\": [{\n              x: 0,\n              y: 3,\n              w: 8,\n              h: 5\n            }],\n            \"▆\": [{\n              x: 0,\n              y: 2,\n              w: 8,\n              h: 6\n            }],\n            \"▇\": [{\n              x: 0,\n              y: 1,\n              w: 8,\n              h: 7\n            }],\n            \"█\": [{\n              x: 0,\n              y: 0,\n              w: 8,\n              h: 8\n            }],\n            \"▉\": [{\n              x: 0,\n              y: 0,\n              w: 7,\n              h: 8\n            }],\n            \"▊\": [{\n              x: 0,\n              y: 0,\n              w: 6,\n              h: 8\n            }],\n            \"▋\": [{\n              x: 0,\n              y: 0,\n              w: 5,\n              h: 8\n            }],\n            \"▌\": [{\n              x: 0,\n              y: 0,\n              w: 4,\n              h: 8\n            }],\n            \"▍\": [{\n              x: 0,\n              y: 0,\n              w: 3,\n              h: 8\n            }],\n            \"▎\": [{\n              x: 0,\n              y: 0,\n              w: 2,\n              h: 8\n            }],\n            \"▏\": [{\n              x: 0,\n              y: 0,\n              w: 1,\n              h: 8\n            }],\n            \"▐\": [{\n              x: 4,\n              y: 0,\n              w: 4,\n              h: 8\n            }],\n            \"▔\": [{\n              x: 0,\n              y: 0,\n              w: 9,\n              h: 1\n            }],\n            \"▕\": [{\n              x: 7,\n              y: 0,\n              w: 1,\n              h: 8\n            }],\n            \"▖\": [{\n              x: 0,\n              y: 4,\n              w: 4,\n              h: 4\n            }],\n            \"▗\": [{\n              x: 4,\n              y: 4,\n              w: 4,\n              h: 4\n            }],\n            \"▘\": [{\n              x: 0,\n              y: 0,\n              w: 4,\n              h: 4\n            }],\n            \"▙\": [{\n              x: 0,\n              y: 0,\n              w: 4,\n              h: 8\n            }, {\n              x: 0,\n              y: 4,\n              w: 8,\n              h: 4\n            }],\n            \"▚\": [{\n              x: 0,\n              y: 0,\n              w: 4,\n              h: 4\n            }, {\n              x: 4,\n              y: 4,\n              w: 4,\n              h: 4\n            }],\n            \"▛\": [{\n              x: 0,\n              y: 0,\n              w: 4,\n              h: 8\n            }, {\n              x: 4,\n              y: 0,\n              w: 4,\n              h: 4\n            }],\n            \"▜\": [{\n              x: 0,\n              y: 0,\n              w: 8,\n              h: 4\n            }, {\n              x: 4,\n              y: 0,\n              w: 4,\n              h: 8\n            }],\n            \"▝\": [{\n              x: 4,\n              y: 0,\n              w: 4,\n              h: 4\n            }],\n            \"▞\": [{\n              x: 4,\n              y: 0,\n              w: 4,\n              h: 4\n            }, {\n              x: 0,\n              y: 4,\n              w: 4,\n              h: 4\n            }],\n            \"▟\": [{\n              x: 4,\n              y: 0,\n              w: 4,\n              h: 8\n            }, {\n              x: 0,\n              y: 4,\n              w: 8,\n              h: 4\n            }],\n            \"🭰\": [{\n              x: 1,\n              y: 0,\n              w: 1,\n              h: 8\n            }],\n            \"🭱\": [{\n              x: 2,\n              y: 0,\n              w: 1,\n              h: 8\n            }],\n            \"🭲\": [{\n              x: 3,\n              y: 0,\n              w: 1,\n              h: 8\n            }],\n            \"🭳\": [{\n              x: 4,\n              y: 0,\n              w: 1,\n              h: 8\n            }],\n            \"🭴\": [{\n              x: 5,\n              y: 0,\n              w: 1,\n              h: 8\n            }],\n            \"🭵\": [{\n              x: 6,\n              y: 0,\n              w: 1,\n              h: 8\n            }],\n            \"🭶\": [{\n              x: 0,\n              y: 1,\n              w: 8,\n              h: 1\n            }],\n            \"🭷\": [{\n              x: 0,\n              y: 2,\n              w: 8,\n              h: 1\n            }],\n            \"🭸\": [{\n              x: 0,\n              y: 3,\n              w: 8,\n              h: 1\n            }],\n            \"🭹\": [{\n              x: 0,\n              y: 4,\n              w: 8,\n              h: 1\n            }],\n            \"🭺\": [{\n              x: 0,\n              y: 5,\n              w: 8,\n              h: 1\n            }],\n            \"🭻\": [{\n              x: 0,\n              y: 6,\n              w: 8,\n              h: 1\n            }],\n            \"🭼\": [{\n              x: 0,\n              y: 0,\n              w: 1,\n              h: 8\n            }, {\n              x: 0,\n              y: 7,\n              w: 8,\n              h: 1\n            }],\n            \"🭽\": [{\n              x: 0,\n              y: 0,\n              w: 1,\n              h: 8\n            }, {\n              x: 0,\n              y: 0,\n              w: 8,\n              h: 1\n            }],\n            \"🭾\": [{\n              x: 7,\n              y: 0,\n              w: 1,\n              h: 8\n            }, {\n              x: 0,\n              y: 0,\n              w: 8,\n              h: 1\n            }],\n            \"🭿\": [{\n              x: 7,\n              y: 0,\n              w: 1,\n              h: 8\n            }, {\n              x: 0,\n              y: 7,\n              w: 8,\n              h: 1\n            }],\n            \"🮀\": [{\n              x: 0,\n              y: 0,\n              w: 8,\n              h: 1\n            }, {\n              x: 0,\n              y: 7,\n              w: 8,\n              h: 1\n            }],\n            \"🮁\": [{\n              x: 0,\n              y: 0,\n              w: 8,\n              h: 1\n            }, {\n              x: 0,\n              y: 2,\n              w: 8,\n              h: 1\n            }, {\n              x: 0,\n              y: 4,\n              w: 8,\n              h: 1\n            }, {\n              x: 0,\n              y: 7,\n              w: 8,\n              h: 1\n            }],\n            \"🮂\": [{\n              x: 0,\n              y: 0,\n              w: 8,\n              h: 2\n            }],\n            \"🮃\": [{\n              x: 0,\n              y: 0,\n              w: 8,\n              h: 3\n            }],\n            \"🮄\": [{\n              x: 0,\n              y: 0,\n              w: 8,\n              h: 5\n            }],\n            \"🮅\": [{\n              x: 0,\n              y: 0,\n              w: 8,\n              h: 6\n            }],\n            \"🮆\": [{\n              x: 0,\n              y: 0,\n              w: 8,\n              h: 7\n            }],\n            \"🮇\": [{\n              x: 6,\n              y: 0,\n              w: 2,\n              h: 8\n            }],\n            \"🮈\": [{\n              x: 5,\n              y: 0,\n              w: 3,\n              h: 8\n            }],\n            \"🮉\": [{\n              x: 3,\n              y: 0,\n              w: 5,\n              h: 8\n            }],\n            \"🮊\": [{\n              x: 2,\n              y: 0,\n              w: 6,\n              h: 8\n            }],\n            \"🮋\": [{\n              x: 1,\n              y: 0,\n              w: 7,\n              h: 8\n            }],\n            \"🮕\": [{\n              x: 0,\n              y: 0,\n              w: 2,\n              h: 2\n            }, {\n              x: 4,\n              y: 0,\n              w: 2,\n              h: 2\n            }, {\n              x: 2,\n              y: 2,\n              w: 2,\n              h: 2\n            }, {\n              x: 6,\n              y: 2,\n              w: 2,\n              h: 2\n            }, {\n              x: 0,\n              y: 4,\n              w: 2,\n              h: 2\n            }, {\n              x: 4,\n              y: 4,\n              w: 2,\n              h: 2\n            }, {\n              x: 2,\n              y: 6,\n              w: 2,\n              h: 2\n            }, {\n              x: 6,\n              y: 6,\n              w: 2,\n              h: 2\n            }],\n            \"🮖\": [{\n              x: 2,\n              y: 0,\n              w: 2,\n              h: 2\n            }, {\n              x: 6,\n              y: 0,\n              w: 2,\n              h: 2\n            }, {\n              x: 0,\n              y: 2,\n              w: 2,\n              h: 2\n            }, {\n              x: 4,\n              y: 2,\n              w: 2,\n              h: 2\n            }, {\n              x: 2,\n              y: 4,\n              w: 2,\n              h: 2\n            }, {\n              x: 6,\n              y: 4,\n              w: 2,\n              h: 2\n            }, {\n              x: 0,\n              y: 6,\n              w: 2,\n              h: 2\n            }, {\n              x: 4,\n              y: 6,\n              w: 2,\n              h: 2\n            }],\n            \"🮗\": [{\n              x: 0,\n              y: 2,\n              w: 8,\n              h: 2\n            }, {\n              x: 0,\n              y: 6,\n              w: 8,\n              h: 2\n            }]\n          };\n          const r = {\n            \"░\": [[1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 0]],\n            \"▒\": [[1, 0], [0, 0], [0, 1], [0, 0]],\n            \"▓\": [[0, 1], [1, 1], [1, 0], [1, 1]]\n          };\n          t.boxDrawingDefinitions = {\n            \"─\": {\n              1: \"M0,.5 L1,.5\"\n            },\n            \"━\": {\n              3: \"M0,.5 L1,.5\"\n            },\n            \"│\": {\n              1: \"M.5,0 L.5,1\"\n            },\n            \"┃\": {\n              3: \"M.5,0 L.5,1\"\n            },\n            \"┌\": {\n              1: \"M0.5,1 L.5,.5 L1,.5\"\n            },\n            \"┏\": {\n              3: \"M0.5,1 L.5,.5 L1,.5\"\n            },\n            \"┐\": {\n              1: \"M0,.5 L.5,.5 L.5,1\"\n            },\n            \"┓\": {\n              3: \"M0,.5 L.5,.5 L.5,1\"\n            },\n            \"└\": {\n              1: \"M.5,0 L.5,.5 L1,.5\"\n            },\n            \"┗\": {\n              3: \"M.5,0 L.5,.5 L1,.5\"\n            },\n            \"┘\": {\n              1: \"M.5,0 L.5,.5 L0,.5\"\n            },\n            \"┛\": {\n              3: \"M.5,0 L.5,.5 L0,.5\"\n            },\n            \"├\": {\n              1: \"M.5,0 L.5,1 M.5,.5 L1,.5\"\n            },\n            \"┣\": {\n              3: \"M.5,0 L.5,1 M.5,.5 L1,.5\"\n            },\n            \"┤\": {\n              1: \"M.5,0 L.5,1 M.5,.5 L0,.5\"\n            },\n            \"┫\": {\n              3: \"M.5,0 L.5,1 M.5,.5 L0,.5\"\n            },\n            \"┬\": {\n              1: \"M0,.5 L1,.5 M.5,.5 L.5,1\"\n            },\n            \"┳\": {\n              3: \"M0,.5 L1,.5 M.5,.5 L.5,1\"\n            },\n            \"┴\": {\n              1: \"M0,.5 L1,.5 M.5,.5 L.5,0\"\n            },\n            \"┻\": {\n              3: \"M0,.5 L1,.5 M.5,.5 L.5,0\"\n            },\n            \"┼\": {\n              1: \"M0,.5 L1,.5 M.5,0 L.5,1\"\n            },\n            \"╋\": {\n              3: \"M0,.5 L1,.5 M.5,0 L.5,1\"\n            },\n            \"╴\": {\n              1: \"M.5,.5 L0,.5\"\n            },\n            \"╸\": {\n              3: \"M.5,.5 L0,.5\"\n            },\n            \"╵\": {\n              1: \"M.5,.5 L.5,0\"\n            },\n            \"╹\": {\n              3: \"M.5,.5 L.5,0\"\n            },\n            \"╶\": {\n              1: \"M.5,.5 L1,.5\"\n            },\n            \"╺\": {\n              3: \"M.5,.5 L1,.5\"\n            },\n            \"╷\": {\n              1: \"M.5,.5 L.5,1\"\n            },\n            \"╻\": {\n              3: \"M.5,.5 L.5,1\"\n            },\n            \"═\": {\n              1: (e, t) => `M0,${.5 - t} L1,${.5 - t} M0,${.5 + t} L1,${.5 + t}`\n            },\n            \"║\": {\n              1: (e, t) => `M${.5 - e},0 L${.5 - e},1 M${.5 + e},0 L${.5 + e},1`\n            },\n            \"╒\": {\n              1: (e, t) => `M.5,1 L.5,${.5 - t} L1,${.5 - t} M.5,${.5 + t} L1,${.5 + t}`\n            },\n            \"╓\": {\n              1: (e, t) => `M${.5 - e},1 L${.5 - e},.5 L1,.5 M${.5 + e},.5 L${.5 + e},1`\n            },\n            \"╔\": {\n              1: (e, t) => `M1,${.5 - t} L${.5 - e},${.5 - t} L${.5 - e},1 M1,${.5 + t} L${.5 + e},${.5 + t} L${.5 + e},1`\n            },\n            \"╕\": {\n              1: (e, t) => `M0,${.5 - t} L.5,${.5 - t} L.5,1 M0,${.5 + t} L.5,${.5 + t}`\n            },\n            \"╖\": {\n              1: (e, t) => `M${.5 + e},1 L${.5 + e},.5 L0,.5 M${.5 - e},.5 L${.5 - e},1`\n            },\n            \"╗\": {\n              1: (e, t) => `M0,${.5 + t} L${.5 - e},${.5 + t} L${.5 - e},1 M0,${.5 - t} L${.5 + e},${.5 - t} L${.5 + e},1`\n            },\n            \"╘\": {\n              1: (e, t) => `M.5,0 L.5,${.5 + t} L1,${.5 + t} M.5,${.5 - t} L1,${.5 - t}`\n            },\n            \"╙\": {\n              1: (e, t) => `M1,.5 L${.5 - e},.5 L${.5 - e},0 M${.5 + e},.5 L${.5 + e},0`\n            },\n            \"╚\": {\n              1: (e, t) => `M1,${.5 - t} L${.5 + e},${.5 - t} L${.5 + e},0 M1,${.5 + t} L${.5 - e},${.5 + t} L${.5 - e},0`\n            },\n            \"╛\": {\n              1: (e, t) => `M0,${.5 + t} L.5,${.5 + t} L.5,0 M0,${.5 - t} L.5,${.5 - t}`\n            },\n            \"╜\": {\n              1: (e, t) => `M0,.5 L${.5 + e},.5 L${.5 + e},0 M${.5 - e},.5 L${.5 - e},0`\n            },\n            \"╝\": {\n              1: (e, t) => `M0,${.5 - t} L${.5 - e},${.5 - t} L${.5 - e},0 M0,${.5 + t} L${.5 + e},${.5 + t} L${.5 + e},0`\n            },\n            \"╞\": {\n              1: (e, t) => `M.5,0 L.5,1 M.5,${.5 - t} L1,${.5 - t} M.5,${.5 + t} L1,${.5 + t}`\n            },\n            \"╟\": {\n              1: (e, t) => `M${.5 - e},0 L${.5 - e},1 M${.5 + e},0 L${.5 + e},1 M${.5 + e},.5 L1,.5`\n            },\n            \"╠\": {\n              1: (e, t) => `M${.5 - e},0 L${.5 - e},1 M1,${.5 + t} L${.5 + e},${.5 + t} L${.5 + e},1 M1,${.5 - t} L${.5 + e},${.5 - t} L${.5 + e},0`\n            },\n            \"╡\": {\n              1: (e, t) => `M.5,0 L.5,1 M0,${.5 - t} L.5,${.5 - t} M0,${.5 + t} L.5,${.5 + t}`\n            },\n            \"╢\": {\n              1: (e, t) => `M0,.5 L${.5 - e},.5 M${.5 - e},0 L${.5 - e},1 M${.5 + e},0 L${.5 + e},1`\n            },\n            \"╣\": {\n              1: (e, t) => `M${.5 + e},0 L${.5 + e},1 M0,${.5 + t} L${.5 - e},${.5 + t} L${.5 - e},1 M0,${.5 - t} L${.5 - e},${.5 - t} L${.5 - e},0`\n            },\n            \"╤\": {\n              1: (e, t) => `M0,${.5 - t} L1,${.5 - t} M0,${.5 + t} L1,${.5 + t} M.5,${.5 + t} L.5,1`\n            },\n            \"╥\": {\n              1: (e, t) => `M0,.5 L1,.5 M${.5 - e},.5 L${.5 - e},1 M${.5 + e},.5 L${.5 + e},1`\n            },\n            \"╦\": {\n              1: (e, t) => `M0,${.5 - t} L1,${.5 - t} M0,${.5 + t} L${.5 - e},${.5 + t} L${.5 - e},1 M1,${.5 + t} L${.5 + e},${.5 + t} L${.5 + e},1`\n            },\n            \"╧\": {\n              1: (e, t) => `M.5,0 L.5,${.5 - t} M0,${.5 - t} L1,${.5 - t} M0,${.5 + t} L1,${.5 + t}`\n            },\n            \"╨\": {\n              1: (e, t) => `M0,.5 L1,.5 M${.5 - e},.5 L${.5 - e},0 M${.5 + e},.5 L${.5 + e},0`\n            },\n            \"╩\": {\n              1: (e, t) => `M0,${.5 + t} L1,${.5 + t} M0,${.5 - t} L${.5 - e},${.5 - t} L${.5 - e},0 M1,${.5 - t} L${.5 + e},${.5 - t} L${.5 + e},0`\n            },\n            \"╪\": {\n              1: (e, t) => `M.5,0 L.5,1 M0,${.5 - t} L1,${.5 - t} M0,${.5 + t} L1,${.5 + t}`\n            },\n            \"╫\": {\n              1: (e, t) => `M0,.5 L1,.5 M${.5 - e},0 L${.5 - e},1 M${.5 + e},0 L${.5 + e},1`\n            },\n            \"╬\": {\n              1: (e, t) => `M0,${.5 + t} L${.5 - e},${.5 + t} L${.5 - e},1 M1,${.5 + t} L${.5 + e},${.5 + t} L${.5 + e},1 M0,${.5 - t} L${.5 - e},${.5 - t} L${.5 - e},0 M1,${.5 - t} L${.5 + e},${.5 - t} L${.5 + e},0`\n            },\n            \"╱\": {\n              1: \"M1,0 L0,1\"\n            },\n            \"╲\": {\n              1: \"M0,0 L1,1\"\n            },\n            \"╳\": {\n              1: \"M1,0 L0,1 M0,0 L1,1\"\n            },\n            \"╼\": {\n              1: \"M.5,.5 L0,.5\",\n              3: \"M.5,.5 L1,.5\"\n            },\n            \"╽\": {\n              1: \"M.5,.5 L.5,0\",\n              3: \"M.5,.5 L.5,1\"\n            },\n            \"╾\": {\n              1: \"M.5,.5 L1,.5\",\n              3: \"M.5,.5 L0,.5\"\n            },\n            \"╿\": {\n              1: \"M.5,.5 L.5,1\",\n              3: \"M.5,.5 L.5,0\"\n            },\n            \"┍\": {\n              1: \"M.5,.5 L.5,1\",\n              3: \"M.5,.5 L1,.5\"\n            },\n            \"┎\": {\n              1: \"M.5,.5 L1,.5\",\n              3: \"M.5,.5 L.5,1\"\n            },\n            \"┑\": {\n              1: \"M.5,.5 L.5,1\",\n              3: \"M.5,.5 L0,.5\"\n            },\n            \"┒\": {\n              1: \"M.5,.5 L0,.5\",\n              3: \"M.5,.5 L.5,1\"\n            },\n            \"┕\": {\n              1: \"M.5,.5 L.5,0\",\n              3: \"M.5,.5 L1,.5\"\n            },\n            \"┖\": {\n              1: \"M.5,.5 L1,.5\",\n              3: \"M.5,.5 L.5,0\"\n            },\n            \"┙\": {\n              1: \"M.5,.5 L.5,0\",\n              3: \"M.5,.5 L0,.5\"\n            },\n            \"┚\": {\n              1: \"M.5,.5 L0,.5\",\n              3: \"M.5,.5 L.5,0\"\n            },\n            \"┝\": {\n              1: \"M.5,0 L.5,1\",\n              3: \"M.5,.5 L1,.5\"\n            },\n            \"┞\": {\n              1: \"M0.5,1 L.5,.5 L1,.5\",\n              3: \"M.5,.5 L.5,0\"\n            },\n            \"┟\": {\n              1: \"M.5,0 L.5,.5 L1,.5\",\n              3: \"M.5,.5 L.5,1\"\n            },\n            \"┠\": {\n              1: \"M.5,.5 L1,.5\",\n              3: \"M.5,0 L.5,1\"\n            },\n            \"┡\": {\n              1: \"M.5,.5 L.5,1\",\n              3: \"M.5,0 L.5,.5 L1,.5\"\n            },\n            \"┢\": {\n              1: \"M.5,.5 L.5,0\",\n              3: \"M0.5,1 L.5,.5 L1,.5\"\n            },\n            \"┥\": {\n              1: \"M.5,0 L.5,1\",\n              3: \"M.5,.5 L0,.5\"\n            },\n            \"┦\": {\n              1: \"M0,.5 L.5,.5 L.5,1\",\n              3: \"M.5,.5 L.5,0\"\n            },\n            \"┧\": {\n              1: \"M.5,0 L.5,.5 L0,.5\",\n              3: \"M.5,.5 L.5,1\"\n            },\n            \"┨\": {\n              1: \"M.5,.5 L0,.5\",\n              3: \"M.5,0 L.5,1\"\n            },\n            \"┩\": {\n              1: \"M.5,.5 L.5,1\",\n              3: \"M.5,0 L.5,.5 L0,.5\"\n            },\n            \"┪\": {\n              1: \"M.5,.5 L.5,0\",\n              3: \"M0,.5 L.5,.5 L.5,1\"\n            },\n            \"┭\": {\n              1: \"M0.5,1 L.5,.5 L1,.5\",\n              3: \"M.5,.5 L0,.5\"\n            },\n            \"┮\": {\n              1: \"M0,.5 L.5,.5 L.5,1\",\n              3: \"M.5,.5 L1,.5\"\n            },\n            \"┯\": {\n              1: \"M.5,.5 L.5,1\",\n              3: \"M0,.5 L1,.5\"\n            },\n            \"┰\": {\n              1: \"M0,.5 L1,.5\",\n              3: \"M.5,.5 L.5,1\"\n            },\n            \"┱\": {\n              1: \"M.5,.5 L1,.5\",\n              3: \"M0,.5 L.5,.5 L.5,1\"\n            },\n            \"┲\": {\n              1: \"M.5,.5 L0,.5\",\n              3: \"M0.5,1 L.5,.5 L1,.5\"\n            },\n            \"┵\": {\n              1: \"M.5,0 L.5,.5 L1,.5\",\n              3: \"M.5,.5 L0,.5\"\n            },\n            \"┶\": {\n              1: \"M.5,0 L.5,.5 L0,.5\",\n              3: \"M.5,.5 L1,.5\"\n            },\n            \"┷\": {\n              1: \"M.5,.5 L.5,0\",\n              3: \"M0,.5 L1,.5\"\n            },\n            \"┸\": {\n              1: \"M0,.5 L1,.5\",\n              3: \"M.5,.5 L.5,0\"\n            },\n            \"┹\": {\n              1: \"M.5,.5 L1,.5\",\n              3: \"M.5,0 L.5,.5 L0,.5\"\n            },\n            \"┺\": {\n              1: \"M.5,.5 L0,.5\",\n              3: \"M.5,0 L.5,.5 L1,.5\"\n            },\n            \"┽\": {\n              1: \"M.5,0 L.5,1 M.5,.5 L1,.5\",\n              3: \"M.5,.5 L0,.5\"\n            },\n            \"┾\": {\n              1: \"M.5,0 L.5,1 M.5,.5 L0,.5\",\n              3: \"M.5,.5 L1,.5\"\n            },\n            \"┿\": {\n              1: \"M.5,0 L.5,1\",\n              3: \"M0,.5 L1,.5\"\n            },\n            \"╀\": {\n              1: \"M0,.5 L1,.5 M.5,.5 L.5,1\",\n              3: \"M.5,.5 L.5,0\"\n            },\n            \"╁\": {\n              1: \"M.5,.5 L.5,0 M0,.5 L1,.5\",\n              3: \"M.5,.5 L.5,1\"\n            },\n            \"╂\": {\n              1: \"M0,.5 L1,.5\",\n              3: \"M.5,0 L.5,1\"\n            },\n            \"╃\": {\n              1: \"M0.5,1 L.5,.5 L1,.5\",\n              3: \"M.5,0 L.5,.5 L0,.5\"\n            },\n            \"╄\": {\n              1: \"M0,.5 L.5,.5 L.5,1\",\n              3: \"M.5,0 L.5,.5 L1,.5\"\n            },\n            \"╅\": {\n              1: \"M.5,0 L.5,.5 L1,.5\",\n              3: \"M0,.5 L.5,.5 L.5,1\"\n            },\n            \"╆\": {\n              1: \"M.5,0 L.5,.5 L0,.5\",\n              3: \"M0.5,1 L.5,.5 L1,.5\"\n            },\n            \"╇\": {\n              1: \"M.5,.5 L.5,1\",\n              3: \"M.5,.5 L.5,0 M0,.5 L1,.5\"\n            },\n            \"╈\": {\n              1: \"M.5,.5 L.5,0\",\n              3: \"M0,.5 L1,.5 M.5,.5 L.5,1\"\n            },\n            \"╉\": {\n              1: \"M.5,.5 L1,.5\",\n              3: \"M.5,0 L.5,1 M.5,.5 L0,.5\"\n            },\n            \"╊\": {\n              1: \"M.5,.5 L0,.5\",\n              3: \"M.5,0 L.5,1 M.5,.5 L1,.5\"\n            },\n            \"╌\": {\n              1: \"M.1,.5 L.4,.5 M.6,.5 L.9,.5\"\n            },\n            \"╍\": {\n              3: \"M.1,.5 L.4,.5 M.6,.5 L.9,.5\"\n            },\n            \"┄\": {\n              1: \"M.0667,.5 L.2667,.5 M.4,.5 L.6,.5 M.7333,.5 L.9333,.5\"\n            },\n            \"┅\": {\n              3: \"M.0667,.5 L.2667,.5 M.4,.5 L.6,.5 M.7333,.5 L.9333,.5\"\n            },\n            \"┈\": {\n              1: \"M.05,.5 L.2,.5 M.3,.5 L.45,.5 M.55,.5 L.7,.5 M.8,.5 L.95,.5\"\n            },\n            \"┉\": {\n              3: \"M.05,.5 L.2,.5 M.3,.5 L.45,.5 M.55,.5 L.7,.5 M.8,.5 L.95,.5\"\n            },\n            \"╎\": {\n              1: \"M.5,.1 L.5,.4 M.5,.6 L.5,.9\"\n            },\n            \"╏\": {\n              3: \"M.5,.1 L.5,.4 M.5,.6 L.5,.9\"\n            },\n            \"┆\": {\n              1: \"M.5,.0667 L.5,.2667 M.5,.4 L.5,.6 M.5,.7333 L.5,.9333\"\n            },\n            \"┇\": {\n              3: \"M.5,.0667 L.5,.2667 M.5,.4 L.5,.6 M.5,.7333 L.5,.9333\"\n            },\n            \"┊\": {\n              1: \"M.5,.05 L.5,.2 M.5,.3 L.5,.45 L.5,.55 M.5,.7 L.5,.95\"\n            },\n            \"┋\": {\n              3: \"M.5,.05 L.5,.2 M.5,.3 L.5,.45 L.5,.55 M.5,.7 L.5,.95\"\n            },\n            \"╭\": {\n              1: (e, t) => `M.5,1 L.5,${.5 + t / .15 * .5} C.5,${.5 + t / .15 * .5},.5,.5,1,.5`\n            },\n            \"╮\": {\n              1: (e, t) => `M.5,1 L.5,${.5 + t / .15 * .5} C.5,${.5 + t / .15 * .5},.5,.5,0,.5`\n            },\n            \"╯\": {\n              1: (e, t) => `M.5,0 L.5,${.5 - t / .15 * .5} C.5,${.5 - t / .15 * .5},.5,.5,0,.5`\n            },\n            \"╰\": {\n              1: (e, t) => `M.5,0 L.5,${.5 - t / .15 * .5} C.5,${.5 - t / .15 * .5},.5,.5,1,.5`\n            }\n          }, t.powerlineDefinitions = {\n            \"\": {\n              d: \"M0,0 L1,.5 L0,1\",\n              type: 0,\n              rightPadding: 2\n            },\n            \"\": {\n              d: \"M-1,-.5 L1,.5 L-1,1.5\",\n              type: 1,\n              leftPadding: 1,\n              rightPadding: 1\n            },\n            \"\": {\n              d: \"M1,0 L0,.5 L1,1\",\n              type: 0,\n              leftPadding: 2\n            },\n            \"\": {\n              d: \"M2,-.5 L0,.5 L2,1.5\",\n              type: 1,\n              leftPadding: 1,\n              rightPadding: 1\n            },\n            \"\": {\n              d: \"M0,0 L0,1 C0.552,1,1,0.776,1,.5 C1,0.224,0.552,0,0,0\",\n              type: 0,\n              rightPadding: 1\n            },\n            \"\": {\n              d: \"M0,1 C0.552,1,1,0.776,1,.5 C1,0.224,0.552,0,0,0\",\n              type: 1,\n              rightPadding: 1\n            },\n            \"\": {\n              d: \"M1,0 L1,1 C0.448,1,0,0.776,0,.5 C0,0.224,0.448,0,1,0\",\n              type: 0,\n              leftPadding: 1\n            },\n            \"\": {\n              d: \"M1,1 C0.448,1,0,0.776,0,.5 C0,0.224,0.448,0,1,0\",\n              type: 1,\n              leftPadding: 1\n            }\n          }, t.tryDrawCustomChar = function (e, i, n, h, c, d, _, u) {\n            const f = t.blockElementDefinitions[i];\n            if (f) return function (e, t, i, s, r, o) {\n              for (let n = 0; n < t.length; n++) {\n                const a = t[n],\n                  l = r / 8,\n                  h = o / 8;\n                e.fillRect(i + a.x * l, s + a.y * h, a.w * l, a.h * h);\n              }\n            }(e, f, n, h, c, d), !0;\n            const g = r[i];\n            if (g) return function (e, t, i, r, n, a) {\n              let l = o.get(t);\n              l || (l = new Map(), o.set(t, l));\n              const h = e.fillStyle;\n              if (\"string\" != typeof h) throw new Error(`Unexpected fillStyle type \"${h}\"`);\n              let c = l.get(h);\n              if (!c) {\n                const i = t[0].length,\n                  r = t.length,\n                  o = document.createElement(\"canvas\");\n                o.width = i, o.height = r;\n                const n = (0, s.throwIfFalsy)(o.getContext(\"2d\")),\n                  a = new ImageData(i, r);\n                let d, _, u, f;\n                if (h.startsWith(\"#\")) d = parseInt(h.slice(1, 3), 16), _ = parseInt(h.slice(3, 5), 16), u = parseInt(h.slice(5, 7), 16), f = h.length > 7 && parseInt(h.slice(7, 9), 16) || 1;else {\n                  if (!h.startsWith(\"rgba\")) throw new Error(`Unexpected fillStyle color format \"${h}\" when drawing pattern glyph`);\n                  [d, _, u, f] = h.substring(5, h.length - 1).split(\",\").map(e => parseFloat(e));\n                }\n                for (let e = 0; e < r; e++) for (let s = 0; s < i; s++) a.data[4 * (e * i + s)] = d, a.data[4 * (e * i + s) + 1] = _, a.data[4 * (e * i + s) + 2] = u, a.data[4 * (e * i + s) + 3] = t[e][s] * (255 * f);\n                n.putImageData(a, 0, 0), c = (0, s.throwIfFalsy)(e.createPattern(o, null)), l.set(h, c);\n              }\n              e.fillStyle = c, e.fillRect(i, r, n, a);\n            }(e, g, n, h, c, d), !0;\n            const C = t.boxDrawingDefinitions[i];\n            if (C) return function (e, t, i, s, r, o, n) {\n              e.strokeStyle = e.fillStyle;\n              for (const [h, c] of Object.entries(t)) {\n                let t;\n                e.beginPath(), e.lineWidth = n * Number.parseInt(h), t = \"function\" == typeof c ? c(.15, .15 / o * r) : c;\n                for (const h of t.split(\" \")) {\n                  const t = h[0],\n                    c = a[t];\n                  if (!c) {\n                    console.error(`Could not find drawing instructions for \"${t}\"`);\n                    continue;\n                  }\n                  const d = h.substring(1).split(\",\");\n                  d[0] && d[1] && c(e, l(d, r, o, i, s, !0, n));\n                }\n                e.stroke(), e.closePath();\n              }\n            }(e, C, n, h, c, d, u), !0;\n            const p = t.powerlineDefinitions[i];\n            return !!p && (function (e, t, i, s, r, o, n, h) {\n              var c, d;\n              e.beginPath();\n              const _ = n / 12;\n              e.lineWidth = h * _;\n              for (const n of t.d.split(\" \")) {\n                const h = n[0],\n                  u = a[h];\n                if (!u) {\n                  console.error(`Could not find drawing instructions for \"${h}\"`);\n                  continue;\n                }\n                const f = n.substring(1).split(\",\");\n                f[0] && f[1] && u(e, l(f, r, o, i, s, !1, (null !== (c = t.leftPadding) && void 0 !== c ? c : 0) * (_ / 2), (null !== (d = t.rightPadding) && void 0 !== d ? d : 0) * (_ / 2)));\n              }\n              1 === t.type ? (e.strokeStyle = e.fillStyle, e.stroke()) : e.fill(), e.closePath();\n            }(e, p, n, h, c, d, _, u), !0);\n          };\n          const o = new Map();\n          function n(e, t, i = 0) {\n            return Math.max(Math.min(e, t), i);\n          }\n          const a = {\n            C: (e, t) => e.bezierCurveTo(t[0], t[1], t[2], t[3], t[4], t[5]),\n            L: (e, t) => e.lineTo(t[0], t[1]),\n            M: (e, t) => e.moveTo(t[0], t[1])\n          };\n          function l(e, t, i, s, r, o, a, l = 0, h = 0) {\n            const c = e.map(e => parseFloat(e) || parseInt(e));\n            if (c.length < 2) throw new Error(\"Too few arguments for instruction\");\n            for (let e = 0; e < c.length; e += 2) c[e] *= t - l * a - h * a, o && 0 !== c[e] && (c[e] = n(Math.round(c[e] + .5) - .5, t, 0)), c[e] += s + l * a;\n            for (let e = 1; e < c.length; e += 2) c[e] *= i, o && 0 !== c[e] && (c[e] = n(Math.round(c[e] + .5) - .5, i, 0)), c[e] += r;\n            return c;\n          }\n        },\n        476: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.observeDevicePixelDimensions = void 0;\n          const s = i(859);\n          t.observeDevicePixelDimensions = function (e, t, i) {\n            let r = new t.ResizeObserver(t => {\n              const s = t.find(t => t.target === e);\n              if (!s) return;\n              if (!(\"devicePixelContentBoxSize\" in s)) return null == r || r.disconnect(), void (r = void 0);\n              const o = s.devicePixelContentBoxSize[0].inlineSize,\n                n = s.devicePixelContentBoxSize[0].blockSize;\n              o > 0 && n > 0 && i(o, n);\n            });\n            try {\n              r.observe(e, {\n                box: [\"device-pixel-content-box\"]\n              });\n            } catch (e) {\n              r.disconnect(), r = void 0;\n            }\n            return (0, s.toDisposable)(() => null == r ? void 0 : r.disconnect());\n          };\n        },\n        634: (e, t) => {\n          function i(e) {\n            return 57508 <= e && e <= 57558;\n          }\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.excludeFromContrastRatioDemands = t.isRestrictedPowerlineGlyph = t.isPowerlineGlyph = t.throwIfFalsy = void 0, t.throwIfFalsy = function (e) {\n            if (!e) throw new Error(\"value must not be falsy\");\n            return e;\n          }, t.isPowerlineGlyph = i, t.isRestrictedPowerlineGlyph = function (e) {\n            return 57520 <= e && e <= 57527;\n          }, t.excludeFromContrastRatioDemands = function (e) {\n            return i(e) || function (e) {\n              return 9472 <= e && e <= 9631;\n            }(e);\n          };\n        },\n        577: function (e, t, i) {\n          var s = this && this.__decorate || function (e, t, i, s) {\n              var r,\n                o = arguments.length,\n                n = o < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;\n              if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) n = Reflect.decorate(e, t, i, s);else for (var a = e.length - 1; a >= 0; a--) (r = e[a]) && (n = (o < 3 ? r(n) : o > 3 ? r(t, i, n) : r(t, i)) || n);\n              return o > 3 && n && Object.defineProperty(t, i, n), n;\n            },\n            r = this && this.__param || function (e, t) {\n              return function (i, s) {\n                t(i, s, e);\n              };\n            };\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.CharacterJoinerService = t.JoinedCellData = void 0;\n          const o = i(147),\n            n = i(855),\n            a = i(782),\n            l = i(97);\n          class h extends o.AttributeData {\n            constructor(e, t, i) {\n              super(), this.content = 0, this.combinedData = \"\", this.fg = e.fg, this.bg = e.bg, this.combinedData = t, this._width = i;\n            }\n            isCombined() {\n              return 2097152;\n            }\n            getWidth() {\n              return this._width;\n            }\n            getChars() {\n              return this.combinedData;\n            }\n            getCode() {\n              return 2097151;\n            }\n            setFromCharData(e) {\n              throw new Error(\"not implemented\");\n            }\n            getAsCharData() {\n              return [this.fg, this.getChars(), this.getWidth(), this.getCode()];\n            }\n          }\n          t.JoinedCellData = h;\n          let c = class e {\n            constructor(e) {\n              this._bufferService = e, this._characterJoiners = [], this._nextCharacterJoinerId = 0, this._workCell = new a.CellData();\n            }\n            register(e) {\n              const t = {\n                id: this._nextCharacterJoinerId++,\n                handler: e\n              };\n              return this._characterJoiners.push(t), t.id;\n            }\n            deregister(e) {\n              for (let t = 0; t < this._characterJoiners.length; t++) if (this._characterJoiners[t].id === e) return this._characterJoiners.splice(t, 1), !0;\n              return !1;\n            }\n            getJoinedCharacters(e) {\n              if (0 === this._characterJoiners.length) return [];\n              const t = this._bufferService.buffer.lines.get(e);\n              if (!t || 0 === t.length) return [];\n              const i = [],\n                s = t.translateToString(!0);\n              let r = 0,\n                o = 0,\n                a = 0,\n                l = t.getFg(0),\n                h = t.getBg(0);\n              for (let e = 0; e < t.getTrimmedLength(); e++) if (t.loadCell(e, this._workCell), 0 !== this._workCell.getWidth()) {\n                if (this._workCell.fg !== l || this._workCell.bg !== h) {\n                  if (e - r > 1) {\n                    const e = this._getJoinedRanges(s, a, o, t, r);\n                    for (let t = 0; t < e.length; t++) i.push(e[t]);\n                  }\n                  r = e, a = o, l = this._workCell.fg, h = this._workCell.bg;\n                }\n                o += this._workCell.getChars().length || n.WHITESPACE_CELL_CHAR.length;\n              }\n              if (this._bufferService.cols - r > 1) {\n                const e = this._getJoinedRanges(s, a, o, t, r);\n                for (let t = 0; t < e.length; t++) i.push(e[t]);\n              }\n              return i;\n            }\n            _getJoinedRanges(t, i, s, r, o) {\n              const n = t.substring(i, s);\n              let a = [];\n              try {\n                a = this._characterJoiners[0].handler(n);\n              } catch (e) {\n                console.error(e);\n              }\n              for (let t = 1; t < this._characterJoiners.length; t++) try {\n                const i = this._characterJoiners[t].handler(n);\n                for (let t = 0; t < i.length; t++) e._mergeRanges(a, i[t]);\n              } catch (e) {\n                console.error(e);\n              }\n              return this._stringRangesToCellRanges(a, r, o), a;\n            }\n            _stringRangesToCellRanges(e, t, i) {\n              let s = 0,\n                r = !1,\n                o = 0,\n                a = e[s];\n              if (a) {\n                for (let l = i; l < this._bufferService.cols; l++) {\n                  const i = t.getWidth(l),\n                    h = t.getString(l).length || n.WHITESPACE_CELL_CHAR.length;\n                  if (0 !== i) {\n                    if (!r && a[0] <= o && (a[0] = l, r = !0), a[1] <= o) {\n                      if (a[1] = l, a = e[++s], !a) break;\n                      a[0] <= o ? (a[0] = l, r = !0) : r = !1;\n                    }\n                    o += h;\n                  }\n                }\n                a && (a[1] = this._bufferService.cols);\n              }\n            }\n            static _mergeRanges(e, t) {\n              let i = !1;\n              for (let s = 0; s < e.length; s++) {\n                const r = e[s];\n                if (i) {\n                  if (t[1] <= r[0]) return e[s - 1][1] = t[1], e;\n                  if (t[1] <= r[1]) return e[s - 1][1] = Math.max(t[1], r[1]), e.splice(s, 1), e;\n                  e.splice(s, 1), s--;\n                } else {\n                  if (t[1] <= r[0]) return e.splice(s, 0, t), e;\n                  if (t[1] <= r[1]) return r[0] = Math.min(t[0], r[0]), e;\n                  t[0] < r[1] && (r[0] = Math.min(t[0], r[0]), i = !0);\n                }\n              }\n              return i ? e[e.length - 1][1] = t[1] : e.push(t), e;\n            }\n          };\n          c = s([r(0, l.IBufferService)], c), t.CharacterJoinerService = c;\n        },\n        160: (e, t) => {\n          var i, s, r;\n          function o(e) {\n            const t = e.toString(16);\n            return t.length < 2 ? \"0\" + t : t;\n          }\n          function n(e, t) {\n            return e < t ? (t + .05) / (e + .05) : (e + .05) / (t + .05);\n          }\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.contrastRatio = t.toPaddedHex = t.rgba = t.rgb = t.css = t.color = t.channels = void 0, function (e) {\n            e.toCss = function (e, t, i, s) {\n              return void 0 !== s ? `#${o(e)}${o(t)}${o(i)}${o(s)}` : `#${o(e)}${o(t)}${o(i)}`;\n            }, e.toRgba = function (e, t, i, s = 255) {\n              return (e << 24 | t << 16 | i << 8 | s) >>> 0;\n            };\n          }(i = t.channels || (t.channels = {})), function (e) {\n            function t(e, t) {\n              const s = Math.round(255 * t),\n                [o, n, a] = r.toChannels(e.rgba);\n              return {\n                css: i.toCss(o, n, a, s),\n                rgba: i.toRgba(o, n, a, s)\n              };\n            }\n            e.blend = function (e, t) {\n              const s = (255 & t.rgba) / 255;\n              if (1 === s) return {\n                css: t.css,\n                rgba: t.rgba\n              };\n              const r = t.rgba >> 24 & 255,\n                o = t.rgba >> 16 & 255,\n                n = t.rgba >> 8 & 255,\n                a = e.rgba >> 24 & 255,\n                l = e.rgba >> 16 & 255,\n                h = e.rgba >> 8 & 255,\n                c = a + Math.round((r - a) * s),\n                d = l + Math.round((o - l) * s),\n                _ = h + Math.round((n - h) * s);\n              return {\n                css: i.toCss(c, d, _),\n                rgba: i.toRgba(c, d, _)\n              };\n            }, e.isOpaque = function (e) {\n              return 255 == (255 & e.rgba);\n            }, e.ensureContrastRatio = function (e, t, i) {\n              const s = r.ensureContrastRatio(e.rgba, t.rgba, i);\n              if (s) return r.toColor(s >> 24 & 255, s >> 16 & 255, s >> 8 & 255);\n            }, e.opaque = function (e) {\n              const t = (255 | e.rgba) >>> 0,\n                [s, o, n] = r.toChannels(t);\n              return {\n                css: i.toCss(s, o, n),\n                rgba: t\n              };\n            }, e.opacity = t, e.multiplyOpacity = function (e, i) {\n              return t(e, (255 & e.rgba) * i / 255);\n            }, e.toColorRGB = function (e) {\n              return [e.rgba >> 24 & 255, e.rgba >> 16 & 255, e.rgba >> 8 & 255];\n            };\n          }(t.color || (t.color = {})), (t.css || (t.css = {})).toColor = function (e) {\n            if (e.match(/#[0-9a-f]{3,8}/i)) switch (e.length) {\n              case 4:\n                {\n                  const t = parseInt(e.slice(1, 2).repeat(2), 16),\n                    i = parseInt(e.slice(2, 3).repeat(2), 16),\n                    s = parseInt(e.slice(3, 4).repeat(2), 16);\n                  return r.toColor(t, i, s);\n                }\n              case 5:\n                {\n                  const t = parseInt(e.slice(1, 2).repeat(2), 16),\n                    i = parseInt(e.slice(2, 3).repeat(2), 16),\n                    s = parseInt(e.slice(3, 4).repeat(2), 16),\n                    o = parseInt(e.slice(4, 5).repeat(2), 16);\n                  return r.toColor(t, i, s, o);\n                }\n              case 7:\n                return {\n                  css: e,\n                  rgba: (parseInt(e.slice(1), 16) << 8 | 255) >>> 0\n                };\n              case 9:\n                return {\n                  css: e,\n                  rgba: parseInt(e.slice(1), 16) >>> 0\n                };\n            }\n            const t = e.match(/rgba?\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*(,\\s*(0|1|\\d?\\.(\\d+))\\s*)?\\)/);\n            if (t) {\n              const e = parseInt(t[1]),\n                i = parseInt(t[2]),\n                s = parseInt(t[3]),\n                o = Math.round(255 * (void 0 === t[5] ? 1 : parseFloat(t[5])));\n              return r.toColor(e, i, s, o);\n            }\n            throw new Error(\"css.toColor: Unsupported css format\");\n          }, function (e) {\n            function t(e, t, i) {\n              const s = e / 255,\n                r = t / 255,\n                o = i / 255;\n              return .2126 * (s <= .03928 ? s / 12.92 : Math.pow((s + .055) / 1.055, 2.4)) + .7152 * (r <= .03928 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4)) + .0722 * (o <= .03928 ? o / 12.92 : Math.pow((o + .055) / 1.055, 2.4));\n            }\n            e.relativeLuminance = function (e) {\n              return t(e >> 16 & 255, e >> 8 & 255, 255 & e);\n            }, e.relativeLuminance2 = t;\n          }(s = t.rgb || (t.rgb = {})), function (e) {\n            function t(e, t, i) {\n              const r = e >> 24 & 255,\n                o = e >> 16 & 255,\n                a = e >> 8 & 255;\n              let l = t >> 24 & 255,\n                h = t >> 16 & 255,\n                c = t >> 8 & 255,\n                d = n(s.relativeLuminance2(l, h, c), s.relativeLuminance2(r, o, a));\n              for (; d < i && (l > 0 || h > 0 || c > 0);) l -= Math.max(0, Math.ceil(.1 * l)), h -= Math.max(0, Math.ceil(.1 * h)), c -= Math.max(0, Math.ceil(.1 * c)), d = n(s.relativeLuminance2(l, h, c), s.relativeLuminance2(r, o, a));\n              return (l << 24 | h << 16 | c << 8 | 255) >>> 0;\n            }\n            function r(e, t, i) {\n              const r = e >> 24 & 255,\n                o = e >> 16 & 255,\n                a = e >> 8 & 255;\n              let l = t >> 24 & 255,\n                h = t >> 16 & 255,\n                c = t >> 8 & 255,\n                d = n(s.relativeLuminance2(l, h, c), s.relativeLuminance2(r, o, a));\n              for (; d < i && (l < 255 || h < 255 || c < 255);) l = Math.min(255, l + Math.ceil(.1 * (255 - l))), h = Math.min(255, h + Math.ceil(.1 * (255 - h))), c = Math.min(255, c + Math.ceil(.1 * (255 - c))), d = n(s.relativeLuminance2(l, h, c), s.relativeLuminance2(r, o, a));\n              return (l << 24 | h << 16 | c << 8 | 255) >>> 0;\n            }\n            e.ensureContrastRatio = function (e, i, o) {\n              const a = s.relativeLuminance(e >> 8),\n                l = s.relativeLuminance(i >> 8);\n              if (n(a, l) < o) {\n                if (l < a) {\n                  const l = t(e, i, o),\n                    h = n(a, s.relativeLuminance(l >> 8));\n                  if (h < o) {\n                    const t = r(e, i, o);\n                    return h > n(a, s.relativeLuminance(t >> 8)) ? l : t;\n                  }\n                  return l;\n                }\n                const h = r(e, i, o),\n                  c = n(a, s.relativeLuminance(h >> 8));\n                if (c < o) {\n                  const r = t(e, i, o);\n                  return c > n(a, s.relativeLuminance(r >> 8)) ? h : r;\n                }\n                return h;\n              }\n            }, e.reduceLuminance = t, e.increaseLuminance = r, e.toChannels = function (e) {\n              return [e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e];\n            }, e.toColor = function (e, t, s, r) {\n              return {\n                css: i.toCss(e, t, s, r),\n                rgba: i.toRgba(e, t, s, r)\n              };\n            };\n          }(r = t.rgba || (t.rgba = {})), t.toPaddedHex = o, t.contrastRatio = n;\n        },\n        345: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.forwardEvent = t.EventEmitter = void 0, t.EventEmitter = class {\n            constructor() {\n              this._listeners = [], this._disposed = !1;\n            }\n            get event() {\n              return this._event || (this._event = e => (this._listeners.push(e), {\n                dispose: () => {\n                  if (!this._disposed) for (let t = 0; t < this._listeners.length; t++) if (this._listeners[t] === e) return void this._listeners.splice(t, 1);\n                }\n              })), this._event;\n            }\n            fire(e, t) {\n              const i = [];\n              for (let e = 0; e < this._listeners.length; e++) i.push(this._listeners[e]);\n              for (let s = 0; s < i.length; s++) i[s].call(void 0, e, t);\n            }\n            dispose() {\n              this._listeners && (this._listeners.length = 0), this._disposed = !0;\n            }\n          }, t.forwardEvent = function (e, t) {\n            return e(e => t.fire(e));\n          };\n        },\n        859: (e, t) => {\n          function i(e) {\n            for (const t of e) t.dispose();\n            e.length = 0;\n          }\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.getDisposeArrayDisposable = t.disposeArray = t.toDisposable = t.Disposable = void 0, t.Disposable = class {\n            constructor() {\n              this._disposables = [], this._isDisposed = !1;\n            }\n            dispose() {\n              this._isDisposed = !0;\n              for (const e of this._disposables) e.dispose();\n              this._disposables.length = 0;\n            }\n            register(e) {\n              return this._disposables.push(e), e;\n            }\n            unregister(e) {\n              const t = this._disposables.indexOf(e);\n              -1 !== t && this._disposables.splice(t, 1);\n            }\n          }, t.toDisposable = function (e) {\n            return {\n              dispose: e\n            };\n          }, t.disposeArray = i, t.getDisposeArrayDisposable = function (e) {\n            return {\n              dispose: () => i(e)\n            };\n          };\n        },\n        485: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.FourKeyMap = t.TwoKeyMap = void 0;\n          class i {\n            constructor() {\n              this._data = {};\n            }\n            set(e, t, i) {\n              this._data[e] || (this._data[e] = {}), this._data[e][t] = i;\n            }\n            get(e, t) {\n              return this._data[e] ? this._data[e][t] : void 0;\n            }\n            clear() {\n              this._data = {};\n            }\n          }\n          t.TwoKeyMap = i, t.FourKeyMap = class {\n            constructor() {\n              this._data = new i();\n            }\n            set(e, t, s, r, o) {\n              this._data.get(e, t) || this._data.set(e, t, new i()), this._data.get(e, t).set(s, r, o);\n            }\n            get(e, t, i, s) {\n              var r;\n              return null === (r = this._data.get(e, t)) || void 0 === r ? void 0 : r.get(i, s);\n            }\n            clear() {\n              this._data.clear();\n            }\n          };\n        },\n        399: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.isLinux = t.isWindows = t.isIphone = t.isIpad = t.isMac = t.isSafari = t.isLegacyEdge = t.isFirefox = void 0;\n          const i = \"undefined\" == typeof navigator,\n            s = i ? \"node\" : navigator.userAgent,\n            r = i ? \"node\" : navigator.platform;\n          t.isFirefox = s.includes(\"Firefox\"), t.isLegacyEdge = s.includes(\"Edge\"), t.isSafari = /^((?!chrome|android).)*safari/i.test(s), t.isMac = [\"Macintosh\", \"MacIntel\", \"MacPPC\", \"Mac68K\"].includes(r), t.isIpad = \"iPad\" === r, t.isIphone = \"iPhone\" === r, t.isWindows = [\"Windows\", \"Win16\", \"Win32\", \"WinCE\"].includes(r), t.isLinux = r.indexOf(\"Linux\") >= 0;\n        },\n        147: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.ExtendedAttrs = t.AttributeData = void 0;\n          class i {\n            constructor() {\n              this.fg = 0, this.bg = 0, this.extended = new s();\n            }\n            static toColorRGB(e) {\n              return [e >>> 16 & 255, e >>> 8 & 255, 255 & e];\n            }\n            static fromColorRGB(e) {\n              return (255 & e[0]) << 16 | (255 & e[1]) << 8 | 255 & e[2];\n            }\n            clone() {\n              const e = new i();\n              return e.fg = this.fg, e.bg = this.bg, e.extended = this.extended.clone(), e;\n            }\n            isInverse() {\n              return 67108864 & this.fg;\n            }\n            isBold() {\n              return 134217728 & this.fg;\n            }\n            isUnderline() {\n              return this.hasExtendedAttrs() && 0 !== this.extended.underlineStyle ? 1 : 268435456 & this.fg;\n            }\n            isBlink() {\n              return 536870912 & this.fg;\n            }\n            isInvisible() {\n              return 1073741824 & this.fg;\n            }\n            isItalic() {\n              return 67108864 & this.bg;\n            }\n            isDim() {\n              return 134217728 & this.bg;\n            }\n            isStrikethrough() {\n              return 2147483648 & this.fg;\n            }\n            isProtected() {\n              return 536870912 & this.bg;\n            }\n            getFgColorMode() {\n              return 50331648 & this.fg;\n            }\n            getBgColorMode() {\n              return 50331648 & this.bg;\n            }\n            isFgRGB() {\n              return 50331648 == (50331648 & this.fg);\n            }\n            isBgRGB() {\n              return 50331648 == (50331648 & this.bg);\n            }\n            isFgPalette() {\n              return 16777216 == (50331648 & this.fg) || 33554432 == (50331648 & this.fg);\n            }\n            isBgPalette() {\n              return 16777216 == (50331648 & this.bg) || 33554432 == (50331648 & this.bg);\n            }\n            isFgDefault() {\n              return 0 == (50331648 & this.fg);\n            }\n            isBgDefault() {\n              return 0 == (50331648 & this.bg);\n            }\n            isAttributeDefault() {\n              return 0 === this.fg && 0 === this.bg;\n            }\n            getFgColor() {\n              switch (50331648 & this.fg) {\n                case 16777216:\n                case 33554432:\n                  return 255 & this.fg;\n                case 50331648:\n                  return 16777215 & this.fg;\n                default:\n                  return -1;\n              }\n            }\n            getBgColor() {\n              switch (50331648 & this.bg) {\n                case 16777216:\n                case 33554432:\n                  return 255 & this.bg;\n                case 50331648:\n                  return 16777215 & this.bg;\n                default:\n                  return -1;\n              }\n            }\n            hasExtendedAttrs() {\n              return 268435456 & this.bg;\n            }\n            updateExtended() {\n              this.extended.isEmpty() ? this.bg &= -268435457 : this.bg |= 268435456;\n            }\n            getUnderlineColor() {\n              if (268435456 & this.bg && ~this.extended.underlineColor) switch (50331648 & this.extended.underlineColor) {\n                case 16777216:\n                case 33554432:\n                  return 255 & this.extended.underlineColor;\n                case 50331648:\n                  return 16777215 & this.extended.underlineColor;\n                default:\n                  return this.getFgColor();\n              }\n              return this.getFgColor();\n            }\n            getUnderlineColorMode() {\n              return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 & this.extended.underlineColor : this.getFgColorMode();\n            }\n            isUnderlineColorRGB() {\n              return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 == (50331648 & this.extended.underlineColor) : this.isFgRGB();\n            }\n            isUnderlineColorPalette() {\n              return 268435456 & this.bg && ~this.extended.underlineColor ? 16777216 == (50331648 & this.extended.underlineColor) || 33554432 == (50331648 & this.extended.underlineColor) : this.isFgPalette();\n            }\n            isUnderlineColorDefault() {\n              return 268435456 & this.bg && ~this.extended.underlineColor ? 0 == (50331648 & this.extended.underlineColor) : this.isFgDefault();\n            }\n            getUnderlineStyle() {\n              return 268435456 & this.fg ? 268435456 & this.bg ? this.extended.underlineStyle : 1 : 0;\n            }\n          }\n          t.AttributeData = i;\n          class s {\n            constructor(e = 0, t = 0) {\n              this._ext = 0, this._urlId = 0, this._ext = e, this._urlId = t;\n            }\n            get ext() {\n              return this._urlId ? -469762049 & this._ext | this.underlineStyle << 26 : this._ext;\n            }\n            set ext(e) {\n              this._ext = e;\n            }\n            get underlineStyle() {\n              return this._urlId ? 5 : (469762048 & this._ext) >> 26;\n            }\n            set underlineStyle(e) {\n              this._ext &= -469762049, this._ext |= e << 26 & 469762048;\n            }\n            get underlineColor() {\n              return 67108863 & this._ext;\n            }\n            set underlineColor(e) {\n              this._ext &= -67108864, this._ext |= 67108863 & e;\n            }\n            get urlId() {\n              return this._urlId;\n            }\n            set urlId(e) {\n              this._urlId = e;\n            }\n            clone() {\n              return new s(this._ext, this._urlId);\n            }\n            isEmpty() {\n              return 0 === this.underlineStyle && 0 === this._urlId;\n            }\n          }\n          t.ExtendedAttrs = s;\n        },\n        782: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.CellData = void 0;\n          const s = i(133),\n            r = i(855),\n            o = i(147);\n          class n extends o.AttributeData {\n            constructor() {\n              super(...arguments), this.content = 0, this.fg = 0, this.bg = 0, this.extended = new o.ExtendedAttrs(), this.combinedData = \"\";\n            }\n            static fromCharData(e) {\n              const t = new n();\n              return t.setFromCharData(e), t;\n            }\n            isCombined() {\n              return 2097152 & this.content;\n            }\n            getWidth() {\n              return this.content >> 22;\n            }\n            getChars() {\n              return 2097152 & this.content ? this.combinedData : 2097151 & this.content ? (0, s.stringFromCodePoint)(2097151 & this.content) : \"\";\n            }\n            getCode() {\n              return this.isCombined() ? this.combinedData.charCodeAt(this.combinedData.length - 1) : 2097151 & this.content;\n            }\n            setFromCharData(e) {\n              this.fg = e[r.CHAR_DATA_ATTR_INDEX], this.bg = 0;\n              let t = !1;\n              if (e[r.CHAR_DATA_CHAR_INDEX].length > 2) t = !0;else if (2 === e[r.CHAR_DATA_CHAR_INDEX].length) {\n                const i = e[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0);\n                if (55296 <= i && i <= 56319) {\n                  const s = e[r.CHAR_DATA_CHAR_INDEX].charCodeAt(1);\n                  56320 <= s && s <= 57343 ? this.content = 1024 * (i - 55296) + s - 56320 + 65536 | e[r.CHAR_DATA_WIDTH_INDEX] << 22 : t = !0;\n                } else t = !0;\n              } else this.content = e[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | e[r.CHAR_DATA_WIDTH_INDEX] << 22;\n              t && (this.combinedData = e[r.CHAR_DATA_CHAR_INDEX], this.content = 2097152 | e[r.CHAR_DATA_WIDTH_INDEX] << 22);\n            }\n            getAsCharData() {\n              return [this.fg, this.getChars(), this.getWidth(), this.getCode()];\n            }\n          }\n          t.CellData = n;\n        },\n        855: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.WHITESPACE_CELL_CODE = t.WHITESPACE_CELL_WIDTH = t.WHITESPACE_CELL_CHAR = t.NULL_CELL_CODE = t.NULL_CELL_WIDTH = t.NULL_CELL_CHAR = t.CHAR_DATA_CODE_INDEX = t.CHAR_DATA_WIDTH_INDEX = t.CHAR_DATA_CHAR_INDEX = t.CHAR_DATA_ATTR_INDEX = t.DEFAULT_EXT = t.DEFAULT_ATTR = t.DEFAULT_COLOR = void 0, t.DEFAULT_COLOR = 256, t.DEFAULT_ATTR = 256 | t.DEFAULT_COLOR << 9, t.DEFAULT_EXT = 0, t.CHAR_DATA_ATTR_INDEX = 0, t.CHAR_DATA_CHAR_INDEX = 1, t.CHAR_DATA_WIDTH_INDEX = 2, t.CHAR_DATA_CODE_INDEX = 3, t.NULL_CELL_CHAR = \"\", t.NULL_CELL_WIDTH = 1, t.NULL_CELL_CODE = 0, t.WHITESPACE_CELL_CHAR = \" \", t.WHITESPACE_CELL_WIDTH = 1, t.WHITESPACE_CELL_CODE = 32;\n        },\n        133: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.Utf8ToUtf32 = t.StringToUtf32 = t.utf32ToString = t.stringFromCodePoint = void 0, t.stringFromCodePoint = function (e) {\n            return e > 65535 ? (e -= 65536, String.fromCharCode(55296 + (e >> 10)) + String.fromCharCode(e % 1024 + 56320)) : String.fromCharCode(e);\n          }, t.utf32ToString = function (e, t = 0, i = e.length) {\n            let s = \"\";\n            for (let r = t; r < i; ++r) {\n              let t = e[r];\n              t > 65535 ? (t -= 65536, s += String.fromCharCode(55296 + (t >> 10)) + String.fromCharCode(t % 1024 + 56320)) : s += String.fromCharCode(t);\n            }\n            return s;\n          }, t.StringToUtf32 = class {\n            constructor() {\n              this._interim = 0;\n            }\n            clear() {\n              this._interim = 0;\n            }\n            decode(e, t) {\n              const i = e.length;\n              if (!i) return 0;\n              let s = 0,\n                r = 0;\n              if (this._interim) {\n                const i = e.charCodeAt(r++);\n                56320 <= i && i <= 57343 ? t[s++] = 1024 * (this._interim - 55296) + i - 56320 + 65536 : (t[s++] = this._interim, t[s++] = i), this._interim = 0;\n              }\n              for (let o = r; o < i; ++o) {\n                const r = e.charCodeAt(o);\n                if (55296 <= r && r <= 56319) {\n                  if (++o >= i) return this._interim = r, s;\n                  const n = e.charCodeAt(o);\n                  56320 <= n && n <= 57343 ? t[s++] = 1024 * (r - 55296) + n - 56320 + 65536 : (t[s++] = r, t[s++] = n);\n                } else 65279 !== r && (t[s++] = r);\n              }\n              return s;\n            }\n          }, t.Utf8ToUtf32 = class {\n            constructor() {\n              this.interim = new Uint8Array(3);\n            }\n            clear() {\n              this.interim.fill(0);\n            }\n            decode(e, t) {\n              const i = e.length;\n              if (!i) return 0;\n              let s,\n                r,\n                o,\n                n,\n                a = 0,\n                l = 0,\n                h = 0;\n              if (this.interim[0]) {\n                let s = !1,\n                  r = this.interim[0];\n                r &= 192 == (224 & r) ? 31 : 224 == (240 & r) ? 15 : 7;\n                let o,\n                  n = 0;\n                for (; (o = 63 & this.interim[++n]) && n < 4;) r <<= 6, r |= o;\n                const l = 192 == (224 & this.interim[0]) ? 2 : 224 == (240 & this.interim[0]) ? 3 : 4,\n                  c = l - n;\n                for (; h < c;) {\n                  if (h >= i) return 0;\n                  if (o = e[h++], 128 != (192 & o)) {\n                    h--, s = !0;\n                    break;\n                  }\n                  this.interim[n++] = o, r <<= 6, r |= 63 & o;\n                }\n                s || (2 === l ? r < 128 ? h-- : t[a++] = r : 3 === l ? r < 2048 || r >= 55296 && r <= 57343 || 65279 === r || (t[a++] = r) : r < 65536 || r > 1114111 || (t[a++] = r)), this.interim.fill(0);\n              }\n              const c = i - 4;\n              let d = h;\n              for (; d < i;) {\n                for (; !(!(d < c) || 128 & (s = e[d]) || 128 & (r = e[d + 1]) || 128 & (o = e[d + 2]) || 128 & (n = e[d + 3]));) t[a++] = s, t[a++] = r, t[a++] = o, t[a++] = n, d += 4;\n                if (s = e[d++], s < 128) t[a++] = s;else if (192 == (224 & s)) {\n                  if (d >= i) return this.interim[0] = s, a;\n                  if (r = e[d++], 128 != (192 & r)) {\n                    d--;\n                    continue;\n                  }\n                  if (l = (31 & s) << 6 | 63 & r, l < 128) {\n                    d--;\n                    continue;\n                  }\n                  t[a++] = l;\n                } else if (224 == (240 & s)) {\n                  if (d >= i) return this.interim[0] = s, a;\n                  if (r = e[d++], 128 != (192 & r)) {\n                    d--;\n                    continue;\n                  }\n                  if (d >= i) return this.interim[0] = s, this.interim[1] = r, a;\n                  if (o = e[d++], 128 != (192 & o)) {\n                    d--;\n                    continue;\n                  }\n                  if (l = (15 & s) << 12 | (63 & r) << 6 | 63 & o, l < 2048 || l >= 55296 && l <= 57343 || 65279 === l) continue;\n                  t[a++] = l;\n                } else if (240 == (248 & s)) {\n                  if (d >= i) return this.interim[0] = s, a;\n                  if (r = e[d++], 128 != (192 & r)) {\n                    d--;\n                    continue;\n                  }\n                  if (d >= i) return this.interim[0] = s, this.interim[1] = r, a;\n                  if (o = e[d++], 128 != (192 & o)) {\n                    d--;\n                    continue;\n                  }\n                  if (d >= i) return this.interim[0] = s, this.interim[1] = r, this.interim[2] = o, a;\n                  if (n = e[d++], 128 != (192 & n)) {\n                    d--;\n                    continue;\n                  }\n                  if (l = (7 & s) << 18 | (63 & r) << 12 | (63 & o) << 6 | 63 & n, l < 65536 || l > 1114111) continue;\n                  t[a++] = l;\n                }\n              }\n              return a;\n            }\n          };\n        },\n        726: (e, t) => {\n          function i(e, t, i) {\n            t.di$target === t ? t.di$dependencies.push({\n              id: e,\n              index: i\n            }) : (t.di$dependencies = [{\n              id: e,\n              index: i\n            }], t.di$target = t);\n          }\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.createDecorator = t.getServiceDependencies = t.serviceRegistry = void 0, t.serviceRegistry = new Map(), t.getServiceDependencies = function (e) {\n            return e.di$dependencies || [];\n          }, t.createDecorator = function (e) {\n            if (t.serviceRegistry.has(e)) return t.serviceRegistry.get(e);\n            const s = function (e, t, r) {\n              if (3 !== arguments.length) throw new Error(\"@IServiceName-decorator can only be used to decorate a parameter\");\n              i(s, e, r);\n            };\n            return s.toString = () => e, t.serviceRegistry.set(e, s), s;\n          };\n        },\n        97: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.IDecorationService = t.IUnicodeService = t.IOscLinkService = t.IOptionsService = t.ILogService = t.LogLevelEnum = t.IInstantiationService = t.IDirtyRowService = t.ICharsetService = t.ICoreService = t.ICoreMouseService = t.IBufferService = void 0;\n          const s = i(726);\n          var r;\n          t.IBufferService = (0, s.createDecorator)(\"BufferService\"), t.ICoreMouseService = (0, s.createDecorator)(\"CoreMouseService\"), t.ICoreService = (0, s.createDecorator)(\"CoreService\"), t.ICharsetService = (0, s.createDecorator)(\"CharsetService\"), t.IDirtyRowService = (0, s.createDecorator)(\"DirtyRowService\"), t.IInstantiationService = (0, s.createDecorator)(\"InstantiationService\"), (r = t.LogLevelEnum || (t.LogLevelEnum = {}))[r.DEBUG = 0] = \"DEBUG\", r[r.INFO = 1] = \"INFO\", r[r.WARN = 2] = \"WARN\", r[r.ERROR = 3] = \"ERROR\", r[r.OFF = 4] = \"OFF\", t.ILogService = (0, s.createDecorator)(\"LogService\"), t.IOptionsService = (0, s.createDecorator)(\"OptionsService\"), t.IOscLinkService = (0, s.createDecorator)(\"OscLinkService\"), t.IUnicodeService = (0, s.createDecorator)(\"UnicodeService\"), t.IDecorationService = (0, s.createDecorator)(\"DecorationService\");\n        }\n      },\n      t = {};\n    function i(s) {\n      var r = t[s];\n      if (void 0 !== r) return r.exports;\n      var o = t[s] = {\n        exports: {}\n      };\n      return e[s].call(o.exports, o, o.exports, i), o.exports;\n    }\n    var s = {};\n    return (() => {\n      var e = s;\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      }), e.CanvasAddon = void 0;\n      const t = i(949);\n      e.CanvasAddon = class {\n        activate(e) {\n          if (!e.element) throw new Error(\"Cannot activate CanvasAddon before Terminal.open\");\n          this._terminal = e;\n          const i = e._core._bufferService,\n            s = e._core._renderService,\n            r = e._core._characterJoinerService,\n            o = e._core._charSizeService,\n            n = e._core.coreService,\n            a = e._core._coreBrowserService,\n            l = e._core._decorationService,\n            h = e._core.optionsService,\n            c = e._core._colorManager.colors,\n            d = e._core.screenElement,\n            _ = e._core.linkifier2;\n          this._renderer = new t.CanvasRenderer(c, d, _, i, o, h, r, n, a, l), s.setRenderer(this._renderer), s.onResize(i.cols, i.rows);\n        }\n        dispose() {\n          var e;\n          if (!this._terminal) throw new Error(\"Cannot dispose CanvasAddon because it is activated\");\n          const t = this._terminal._core._renderService;\n          t.setRenderer(this._terminal._core._createRenderer()), t.onResize(this._terminal.cols, this._terminal.rows), null === (e = this._renderer) || void 0 === e || e.dispose(), this._renderer = void 0;\n        }\n      };\n    })(), s;\n  })();\n});\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/.store/xterm-addon-canvas@0.2.0/node_modules/xterm-addon-canvas/lib/xterm-addon-canvas.js?");

/***/ }),

/***/ "./node_modules/.store/xterm-addon-fit@0.6.0/node_modules/xterm-addon-fit/lib/xterm-addon-fit.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.store/xterm-addon-fit@0.6.0/node_modules/xterm-addon-fit/lib/xterm-addon-fit.js ***!
  \*******************************************************************************************************/
/***/ (function(module) {

eval("!function (e, t) {\n   true ? module.exports = t() : 0;\n}(self, function () {\n  return (() => {\n    \"use strict\";\n\n    var e = {};\n    return (() => {\n      var t = e;\n      Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      }), t.FitAddon = void 0, t.FitAddon = class {\n        constructor() {}\n        activate(e) {\n          this._terminal = e;\n        }\n        dispose() {}\n        fit() {\n          const e = this.proposeDimensions();\n          if (!e || !this._terminal || isNaN(e.cols) || isNaN(e.rows)) return;\n          const t = this._terminal._core;\n          this._terminal.rows === e.rows && this._terminal.cols === e.cols || (t._renderService.clear(), this._terminal.resize(e.cols, e.rows));\n        }\n        proposeDimensions() {\n          if (!this._terminal) return;\n          if (!this._terminal.element || !this._terminal.element.parentElement) return;\n          const e = this._terminal._core;\n          if (0 === e._renderService.dimensions.actualCellWidth || 0 === e._renderService.dimensions.actualCellHeight) return;\n          const t = 0 === this._terminal.options.scrollback ? 0 : e.viewport.scrollBarWidth,\n            r = window.getComputedStyle(this._terminal.element.parentElement),\n            i = parseInt(r.getPropertyValue(\"height\")),\n            n = Math.max(0, parseInt(r.getPropertyValue(\"width\"))),\n            o = window.getComputedStyle(this._terminal.element),\n            s = i - (parseInt(o.getPropertyValue(\"padding-top\")) + parseInt(o.getPropertyValue(\"padding-bottom\"))),\n            a = n - (parseInt(o.getPropertyValue(\"padding-right\")) + parseInt(o.getPropertyValue(\"padding-left\"))) - t;\n          return {\n            cols: Math.max(2, Math.floor(a / e._renderService.dimensions.actualCellWidth)),\n            rows: Math.max(1, Math.floor(s / e._renderService.dimensions.actualCellHeight))\n          };\n        }\n      };\n    })(), e;\n  })();\n});\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/.store/xterm-addon-fit@0.6.0/node_modules/xterm-addon-fit/lib/xterm-addon-fit.js?");

/***/ }),

/***/ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EffectScope: function() { return /* binding */ EffectScope; },\n/* harmony export */   ITERATE_KEY: function() { return /* binding */ ITERATE_KEY; },\n/* harmony export */   ReactiveEffect: function() { return /* binding */ ReactiveEffect; },\n/* harmony export */   ReactiveFlags: function() { return /* binding */ ReactiveFlags; },\n/* harmony export */   TrackOpTypes: function() { return /* binding */ TrackOpTypes; },\n/* harmony export */   TriggerOpTypes: function() { return /* binding */ TriggerOpTypes; },\n/* harmony export */   computed: function() { return /* binding */ computed; },\n/* harmony export */   customRef: function() { return /* binding */ customRef; },\n/* harmony export */   deferredComputed: function() { return /* binding */ deferredComputed; },\n/* harmony export */   effect: function() { return /* binding */ effect; },\n/* harmony export */   effectScope: function() { return /* binding */ effectScope; },\n/* harmony export */   enableTracking: function() { return /* binding */ enableTracking; },\n/* harmony export */   getCurrentScope: function() { return /* binding */ getCurrentScope; },\n/* harmony export */   isProxy: function() { return /* binding */ isProxy; },\n/* harmony export */   isReactive: function() { return /* binding */ isReactive; },\n/* harmony export */   isReadonly: function() { return /* binding */ isReadonly; },\n/* harmony export */   isRef: function() { return /* binding */ isRef; },\n/* harmony export */   isShallow: function() { return /* binding */ isShallow; },\n/* harmony export */   markRaw: function() { return /* binding */ markRaw; },\n/* harmony export */   onScopeDispose: function() { return /* binding */ onScopeDispose; },\n/* harmony export */   pauseScheduling: function() { return /* binding */ pauseScheduling; },\n/* harmony export */   pauseTracking: function() { return /* binding */ pauseTracking; },\n/* harmony export */   proxyRefs: function() { return /* binding */ proxyRefs; },\n/* harmony export */   reactive: function() { return /* binding */ reactive; },\n/* harmony export */   readonly: function() { return /* binding */ readonly; },\n/* harmony export */   ref: function() { return /* binding */ ref; },\n/* harmony export */   resetScheduling: function() { return /* binding */ resetScheduling; },\n/* harmony export */   resetTracking: function() { return /* binding */ resetTracking; },\n/* harmony export */   shallowReactive: function() { return /* binding */ shallowReactive; },\n/* harmony export */   shallowReadonly: function() { return /* binding */ shallowReadonly; },\n/* harmony export */   shallowRef: function() { return /* binding */ shallowRef; },\n/* harmony export */   stop: function() { return /* binding */ stop; },\n/* harmony export */   toRaw: function() { return /* binding */ toRaw; },\n/* harmony export */   toRef: function() { return /* binding */ toRef; },\n/* harmony export */   toRefs: function() { return /* binding */ toRefs; },\n/* harmony export */   toValue: function() { return /* binding */ toValue; },\n/* harmony export */   track: function() { return /* binding */ track; },\n/* harmony export */   trigger: function() { return /* binding */ trigger; },\n/* harmony export */   triggerRef: function() { return /* binding */ triggerRef; },\n/* harmony export */   unref: function() { return /* binding */ unref; }\n/* harmony export */ });\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.push.js */ \"./node_modules/core-js/modules/es.array.push.js\");\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ \"./node_modules/@vue/shared/dist/shared.esm-bundler.js\");\n\n\nfunction warn(msg, ...args) {\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\nlet activeEffectScope;\nclass EffectScope {\n  constructor(detached = false) {\n    this.detached = detached;\n    /**\n     * @internal\n     */\n    this._active = true;\n    /**\n     * @internal\n     */\n    this.effects = [];\n    /**\n     * @internal\n     */\n    this.cleanups = [];\n    this.parent = activeEffectScope;\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\n    }\n  }\n  get active() {\n    return this._active;\n  }\n  run(fn) {\n    if (this._active) {\n      const currentEffectScope = activeEffectScope;\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    } else if (true) {\n      warn(`cannot run an inactive effect scope.`);\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  on() {\n    activeEffectScope = this;\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  off() {\n    activeEffectScope = this.parent;\n  }\n  stop(fromParent) {\n    if (this._active) {\n      let i, l;\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop();\n      }\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n      }\n      if (!this.detached && this.parent && !fromParent) {\n        const last = this.parent.scopes.pop();\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n      this.parent = void 0;\n      this._active = false;\n    }\n  }\n}\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\nfunction recordEffectScope(effect, scope = activeEffectScope) {\n  if (scope && scope.active) {\n    scope.effects.push(effect);\n  }\n}\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\nfunction onScopeDispose(fn) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (true) {\n    warn(`onScopeDispose() is called when there is no active effect scope to be associated with.`);\n  }\n}\nlet activeEffect;\nclass ReactiveEffect {\n  constructor(fn, trigger, scheduler, scope) {\n    this.fn = fn;\n    this.trigger = trigger;\n    this.scheduler = scheduler;\n    this.active = true;\n    this.deps = [];\n    /**\n     * @internal\n     */\n    this._dirtyLevel = 3;\n    /**\n     * @internal\n     */\n    this._trackId = 0;\n    /**\n     * @internal\n     */\n    this._runnings = 0;\n    /**\n     * @internal\n     */\n    this._queryings = 0;\n    /**\n     * @internal\n     */\n    this._depsLength = 0;\n    recordEffectScope(this, scope);\n  }\n  get dirty() {\n    if (this._dirtyLevel === 1) {\n      this._dirtyLevel = 0;\n      this._queryings++;\n      pauseTracking();\n      for (const dep of this.deps) {\n        if (dep.computed) {\n          triggerComputed(dep.computed);\n          if (this._dirtyLevel >= 2) {\n            break;\n          }\n        }\n      }\n      resetTracking();\n      this._queryings--;\n    }\n    return this._dirtyLevel >= 2;\n  }\n  set dirty(v) {\n    this._dirtyLevel = v ? 3 : 0;\n  }\n  run() {\n    this._dirtyLevel = 0;\n    if (!this.active) {\n      return this.fn();\n    }\n    let lastShouldTrack = shouldTrack;\n    let lastEffect = activeEffect;\n    try {\n      shouldTrack = true;\n      activeEffect = this;\n      this._runnings++;\n      preCleanupEffect(this);\n      return this.fn();\n    } finally {\n      postCleanupEffect(this);\n      this._runnings--;\n      activeEffect = lastEffect;\n      shouldTrack = lastShouldTrack;\n    }\n  }\n  stop() {\n    var _a;\n    if (this.active) {\n      preCleanupEffect(this);\n      postCleanupEffect(this);\n      (_a = this.onStop) == null ? void 0 : _a.call(this);\n      this.active = false;\n    }\n  }\n}\nfunction triggerComputed(computed) {\n  return computed.value;\n}\nfunction preCleanupEffect(effect2) {\n  effect2._trackId++;\n  effect2._depsLength = 0;\n}\nfunction postCleanupEffect(effect2) {\n  if (effect2.deps && effect2.deps.length > effect2._depsLength) {\n    for (let i = effect2._depsLength; i < effect2.deps.length; i++) {\n      cleanupDepEffect(effect2.deps[i], effect2);\n    }\n    effect2.deps.length = effect2._depsLength;\n  }\n}\nfunction cleanupDepEffect(dep, effect2) {\n  const trackId = dep.get(effect2);\n  if (trackId !== void 0 && effect2._trackId !== trackId) {\n    dep.delete(effect2);\n    if (dep.size === 0) {\n      dep.cleanup();\n    }\n  }\n}\nfunction effect(fn, options) {\n  if (fn.effect instanceof ReactiveEffect) {\n    fn = fn.effect.fn;\n  }\n  const _effect = new ReactiveEffect(fn, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP, () => {\n    if (_effect.dirty) {\n      _effect.run();\n    }\n  });\n  if (options) {\n    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(_effect, options);\n    if (options.scope) recordEffectScope(_effect, options.scope);\n  }\n  if (!options || !options.lazy) {\n    _effect.run();\n  }\n  const runner = _effect.run.bind(_effect);\n  runner.effect = _effect;\n  return runner;\n}\nfunction stop(runner) {\n  runner.effect.stop();\n}\nlet shouldTrack = true;\nlet pauseScheduleStack = 0;\nconst trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\nfunction pauseScheduling() {\n  pauseScheduleStack++;\n}\nfunction resetScheduling() {\n  pauseScheduleStack--;\n  while (!pauseScheduleStack && queueEffectSchedulers.length) {\n    queueEffectSchedulers.shift()();\n  }\n}\nfunction trackEffect(effect2, dep, debuggerEventExtraInfo) {\n  var _a;\n  if (dep.get(effect2) !== effect2._trackId) {\n    dep.set(effect2, effect2._trackId);\n    const oldDep = effect2.deps[effect2._depsLength];\n    if (oldDep !== dep) {\n      if (oldDep) {\n        cleanupDepEffect(oldDep, effect2);\n      }\n      effect2.deps[effect2._depsLength++] = dep;\n    } else {\n      effect2._depsLength++;\n    }\n    if (true) {\n      (_a = effect2.onTrack) == null ? void 0 : _a.call(effect2, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({\n        effect: effect2\n      }, debuggerEventExtraInfo));\n    }\n  }\n}\nconst queueEffectSchedulers = [];\nfunction triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {\n  var _a;\n  pauseScheduling();\n  for (const effect2 of dep.keys()) {\n    if (!effect2.allowRecurse && effect2._runnings) {\n      continue;\n    }\n    if (effect2._dirtyLevel < dirtyLevel && (!effect2._runnings || dirtyLevel !== 2)) {\n      const lastDirtyLevel = effect2._dirtyLevel;\n      effect2._dirtyLevel = dirtyLevel;\n      if (lastDirtyLevel === 0 && (!effect2._queryings || dirtyLevel !== 2)) {\n        if (true) {\n          (_a = effect2.onTrigger) == null ? void 0 : _a.call(effect2, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({\n            effect: effect2\n          }, debuggerEventExtraInfo));\n        }\n        effect2.trigger();\n        if (effect2.scheduler) {\n          queueEffectSchedulers.push(effect2.scheduler);\n        }\n      }\n    }\n  }\n  resetScheduling();\n}\nconst createDep = (cleanup, computed) => {\n  const dep = /* @__PURE__ */new Map();\n  dep.cleanup = cleanup;\n  dep.computed = computed;\n  return dep;\n};\nconst targetMap = /* @__PURE__ */new WeakMap();\nconst ITERATE_KEY = Symbol( true ? \"iterate\" : 0);\nconst MAP_KEY_ITERATE_KEY = Symbol( true ? \"Map key iterate\" : 0);\nfunction track(target, type, key) {\n  if (shouldTrack && activeEffect) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = /* @__PURE__ */new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = createDep(() => depsMap.delete(key)));\n    }\n    trackEffect(activeEffect, dep,  true ? {\n      target,\n      type,\n      key\n    } : 0);\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    return;\n  }\n  let deps = [];\n  if (type === \"clear\") {\n    deps = [...depsMap.values()];\n  } else if (key === \"length\" && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(target)) {\n    const newLength = Number(newValue);\n    depsMap.forEach((dep, key2) => {\n      if (key2 === \"length\" || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSymbol)(key2) && key2 >= newLength) {\n        deps.push(dep);\n      }\n    });\n  } else {\n    if (key !== void 0) {\n      deps.push(depsMap.get(key));\n    }\n    switch (type) {\n      case \"add\":\n        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isMap)(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isIntegerKey)(key)) {\n          deps.push(depsMap.get(\"length\"));\n        }\n        break;\n      case \"delete\":\n        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isMap)(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        }\n        break;\n      case \"set\":\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isMap)(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n        }\n        break;\n    }\n  }\n  pauseScheduling();\n  for (const dep of deps) {\n    if (dep) {\n      triggerEffects(dep, 3,  true ? {\n        target,\n        type,\n        key,\n        newValue,\n        oldValue,\n        oldTarget\n      } : 0);\n    }\n  }\n  resetScheduling();\n}\nfunction getDepFromReactive(object, key) {\n  var _a;\n  return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);\n}\nconst isNonTrackableKeys = /* @__PURE__ */(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set( /* @__PURE__ */Object.getOwnPropertyNames(Symbol).filter(key => key !== \"arguments\" && key !== \"caller\").map(key => Symbol[key]).filter(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSymbol));\nconst arrayInstrumentations = /* @__PURE__ */createArrayInstrumentations();\nfunction createArrayInstrumentations() {\n  const instrumentations = {};\n  [\"includes\", \"indexOf\", \"lastIndexOf\"].forEach(key => {\n    instrumentations[key] = function (...args) {\n      const arr = toRaw(this);\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, \"get\", i + \"\");\n      }\n      const res = arr[key](...args);\n      if (res === -1 || res === false) {\n        return arr[key](...args.map(toRaw));\n      } else {\n        return res;\n      }\n    };\n  });\n  [\"push\", \"pop\", \"shift\", \"unshift\", \"splice\"].forEach(key => {\n    instrumentations[key] = function (...args) {\n      pauseTracking();\n      pauseScheduling();\n      const res = toRaw(this)[key].apply(this, args);\n      resetScheduling();\n      resetTracking();\n      return res;\n    };\n  });\n  return instrumentations;\n}\nfunction hasOwnProperty(key) {\n  const obj = toRaw(this);\n  track(obj, \"has\", key);\n  return obj.hasOwnProperty(key);\n}\nclass BaseReactiveHandler {\n  constructor(_isReadonly = false, _shallow = false) {\n    this._isReadonly = _isReadonly;\n    this._shallow = _shallow;\n  }\n  get(target, key, receiver) {\n    const isReadonly2 = this._isReadonly,\n      shallow = this._shallow;\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_isShallow\") {\n      return shallow;\n    } else if (key === \"__v_raw\") {\n      if (receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target) ||\n      // receiver is not the reactive proxy, but has the same prototype\n      // this means the reciever is a user proxy of the reactive proxy\n      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {\n        return target;\n      }\n      return;\n    }\n    const targetIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(target);\n    if (!isReadonly2) {\n      if (targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(arrayInstrumentations, key)) {\n        return Reflect.get(arrayInstrumentations, key, receiver);\n      }\n      if (key === \"hasOwnProperty\") {\n        return hasOwnProperty;\n      }\n    }\n    const res = Reflect.get(target, key, receiver);\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSymbol)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly2) {\n      track(target, \"get\", key);\n    }\n    if (shallow) {\n      return res;\n    }\n    if (isRef(res)) {\n      return targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isIntegerKey)(key) ? res : res.value;\n    }\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(res)) {\n      return isReadonly2 ? readonly(res) : reactive(res);\n    }\n    return res;\n  }\n}\nclass MutableReactiveHandler extends BaseReactiveHandler {\n  constructor(shallow = false) {\n    super(false, shallow);\n  }\n  set(target, key, value, receiver) {\n    let oldValue = target[key];\n    if (!this._shallow) {\n      const isOldValueReadonly = isReadonly(oldValue);\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue);\n        value = toRaw(value);\n      }\n      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(target) && isRef(oldValue) && !isRef(value)) {\n        if (isOldValueReadonly) {\n          return false;\n        } else {\n          oldValue.value = value;\n          return true;\n        }\n      }\n    }\n    const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(target) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isIntegerKey)(key) ? Number(key) < target.length : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(target, key);\n    const result = Reflect.set(target, key, value, receiver);\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n    }\n    return result;\n  }\n  deleteProperty(target, key) {\n    const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(target, key);\n    const oldValue = target[key];\n    const result = Reflect.deleteProperty(target, key);\n    if (result && hadKey) {\n      trigger(target, \"delete\", key, void 0, oldValue);\n    }\n    return result;\n  }\n  has(target, key) {\n    const result = Reflect.has(target, key);\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSymbol)(key) || !builtInSymbols.has(key)) {\n      track(target, \"has\", key);\n    }\n    return result;\n  }\n  ownKeys(target) {\n    track(target, \"iterate\", (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(target) ? \"length\" : ITERATE_KEY);\n    return Reflect.ownKeys(target);\n  }\n}\nclass ReadonlyReactiveHandler extends BaseReactiveHandler {\n  constructor(shallow = false) {\n    super(true, shallow);\n  }\n  set(target, key) {\n    if (true) {\n      warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\n    }\n    return true;\n  }\n  deleteProperty(target, key) {\n    if (true) {\n      warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\n    }\n    return true;\n  }\n}\nconst mutableHandlers = /* @__PURE__ */new MutableReactiveHandler();\nconst readonlyHandlers = /* @__PURE__ */new ReadonlyReactiveHandler();\nconst shallowReactiveHandlers = /* @__PURE__ */new MutableReactiveHandler(true);\nconst shallowReadonlyHandlers = /* @__PURE__ */new ReadonlyReactiveHandler(true);\nconst toShallow = value => value;\nconst getProto = v => Reflect.getPrototypeOf(v);\nfunction get(target, key, isReadonly = false, isShallow = false) {\n  target = target[\"__v_raw\"];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (!isReadonly) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(key, rawKey)) {\n      track(rawTarget, \"get\", key);\n    }\n    track(rawTarget, \"get\", rawKey);\n  }\n  const {\n    has: has2\n  } = getProto(rawTarget);\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n  if (has2.call(rawTarget, key)) {\n    return wrap(target.get(key));\n  } else if (has2.call(rawTarget, rawKey)) {\n    return wrap(target.get(rawKey));\n  } else if (target !== rawTarget) {\n    target.get(key);\n  }\n}\nfunction has(key, isReadonly = false) {\n  const target = this[\"__v_raw\"];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (!isReadonly) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(key, rawKey)) {\n      track(rawTarget, \"has\", key);\n    }\n    track(rawTarget, \"has\", rawKey);\n  }\n  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n}\nfunction size(target, isReadonly = false) {\n  target = target[\"__v_raw\"];\n  !isReadonly && track(toRaw(target), \"iterate\", ITERATE_KEY);\n  return Reflect.get(target, \"size\", target);\n}\nfunction add(value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const proto = getProto(target);\n  const hadKey = proto.has.call(target, value);\n  if (!hadKey) {\n    target.add(value);\n    trigger(target, \"add\", value, value);\n  }\n  return this;\n}\nfunction set(key, value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const {\n    has: has2,\n    get: get2\n  } = getProto(target);\n  let hadKey = has2.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (true) {\n    checkIdentityKeys(target, has2, key);\n  }\n  const oldValue = get2.call(target, key);\n  target.set(key, value);\n  if (!hadKey) {\n    trigger(target, \"add\", key, value);\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(value, oldValue)) {\n    trigger(target, \"set\", key, value, oldValue);\n  }\n  return this;\n}\nfunction deleteEntry(key) {\n  const target = toRaw(this);\n  const {\n    has: has2,\n    get: get2\n  } = getProto(target);\n  let hadKey = has2.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (true) {\n    checkIdentityKeys(target, has2, key);\n  }\n  const oldValue = get2 ? get2.call(target, key) : void 0;\n  const result = target.delete(key);\n  if (hadKey) {\n    trigger(target, \"delete\", key, void 0, oldValue);\n  }\n  return result;\n}\nfunction clear() {\n  const target = toRaw(this);\n  const hadItems = target.size !== 0;\n  const oldTarget =  true ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isMap)(target) ? new Map(target) : new Set(target) : 0;\n  const result = target.clear();\n  if (hadItems) {\n    trigger(target, \"clear\", void 0, void 0, oldTarget);\n  }\n  return result;\n}\nfunction createForEach(isReadonly, isShallow) {\n  return function forEach(callback, thisArg) {\n    const observed = this;\n    const target = observed[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\", ITERATE_KEY);\n    return target.forEach((value, key) => {\n      return callback.call(thisArg, wrap(value), wrap(key), observed);\n    });\n  };\n}\nfunction createIterableMethod(method, isReadonly, isShallow) {\n  return function (...args) {\n    const target = this[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const targetIsMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isMap)(rawTarget);\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \"keys\" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\n    return {\n      // iterator protocol\n      next() {\n        const {\n          value,\n          done\n        } = innerIterator.next();\n        return done ? {\n          value,\n          done\n        } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function (...args) {\n    if (true) {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      console.warn(`${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(type)} operation ${key}failed: target is readonly.`, toRaw(this));\n    }\n    return type === \"delete\" ? false : type === \"clear\" ? void 0 : this;\n  };\n}\nfunction createInstrumentations() {\n  const mutableInstrumentations2 = {\n    get(key) {\n      return get(this, key);\n    },\n    get size() {\n      return size(this);\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  };\n  const shallowInstrumentations2 = {\n    get(key) {\n      return get(this, key, false, true);\n    },\n    get size() {\n      return size(this);\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  };\n  const readonlyInstrumentations2 = {\n    get(key) {\n      return get(this, key, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\"),\n    forEach: createForEach(true, false)\n  };\n  const shallowReadonlyInstrumentations2 = {\n    get(key) {\n      return get(this, key, true, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\"),\n    forEach: createForEach(true, true)\n  };\n  const iteratorMethods = [\"keys\", \"values\", \"entries\", Symbol.iterator];\n  iteratorMethods.forEach(method => {\n    mutableInstrumentations2[method] = createIterableMethod(method, false, false);\n    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);\n    shallowInstrumentations2[method] = createIterableMethod(method, false, true);\n    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);\n  });\n  return [mutableInstrumentations2, readonlyInstrumentations2, shallowInstrumentations2, shallowReadonlyInstrumentations2];\n}\nconst [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */createInstrumentations();\nfunction createInstrumentationGetter(isReadonly, shallow) {\n  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly;\n    } else if (key === \"__v_raw\") {\n      return target;\n    }\n    return Reflect.get((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(instrumentations, key) && key in target ? instrumentations : target, key, receiver);\n  };\n}\nconst mutableCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has2, key) {\n  const rawKey = toRaw(key);\n  if (rawKey !== key && has2.call(target, rawKey)) {\n    const type = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toRawType)(target);\n    console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);\n  }\n}\nconst reactiveMap = /* @__PURE__ */new WeakMap();\nconst shallowReactiveMap = /* @__PURE__ */new WeakMap();\nconst readonlyMap = /* @__PURE__ */new WeakMap();\nconst shallowReadonlyMap = /* @__PURE__ */new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return 1 /* COMMON */;\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2 /* COLLECTION */;\n    default:\n      return 0 /* INVALID */;\n  }\n}\nfunction getTargetType(value) {\n  return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toRawType)(value));\n}\nfunction reactive(target) {\n  if (isReadonly(target)) {\n    return target;\n  }\n  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n}\nfunction shallowReactive(target) {\n  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\n}\nfunction readonly(target) {\n  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n}\nfunction shallowReadonly(target) {\n  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\n}\nfunction createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(target)) {\n    if (true) {\n      console.warn(`value cannot be made reactive: ${String(target)}`);\n    }\n    return target;\n  }\n  if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n    return target;\n  }\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  const targetType = getTargetType(target);\n  if (targetType === 0 /* INVALID */) {\n    return target;\n  }\n  const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"]);\n  }\n  return !!(value && value[\"__v_isReactive\"]);\n}\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"]);\n}\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"]);\n}\nfunction isProxy(value) {\n  return isReactive(value) || isReadonly(value);\n}\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\"];\n  return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(value, \"__v_skip\", true);\n  return value;\n}\nconst toReactive = value => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value) ? reactive(value) : value;\nconst toReadonly = value => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value) ? readonly(value) : value;\nclass ComputedRefImpl {\n  constructor(getter, _setter, isReadonly, isSSR) {\n    this._setter = _setter;\n    this.dep = void 0;\n    this.__v_isRef = true;\n    this[\"__v_isReadonly\"] = false;\n    this.effect = new ReactiveEffect(() => getter(this._value), () => triggerRefValue(this, 1));\n    this.effect.computed = this;\n    this.effect.active = this._cacheable = !isSSR;\n    this[\"__v_isReadonly\"] = isReadonly;\n  }\n  get value() {\n    const self = toRaw(this);\n    trackRefValue(self);\n    if (!self._cacheable || self.effect.dirty) {\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(self._value, self._value = self.effect.run())) {\n        triggerRefValue(self, 2);\n      }\n    }\n    return self._value;\n  }\n  set value(newValue) {\n    this._setter(newValue);\n  }\n  // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x\n  get _dirty() {\n    return this.effect.dirty;\n  }\n  set _dirty(v) {\n    this.effect.dirty = v;\n  }\n  // #endregion\n}\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter;\n  let setter;\n  const onlyGetter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(getterOrOptions);\n  if (onlyGetter) {\n    getter = getterOrOptions;\n    setter =  true ? () => {\n      console.warn(\"Write operation failed: computed value is readonly\");\n    } : 0;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\n  if ( true && debugOptions && !isSSR) {\n    cRef.effect.onTrack = debugOptions.onTrack;\n    cRef.effect.onTrigger = debugOptions.onTrigger;\n  }\n  return cRef;\n}\nfunction trackRefValue(ref2) {\n  if (shouldTrack && activeEffect) {\n    ref2 = toRaw(ref2);\n    trackEffect(activeEffect, ref2.dep || (ref2.dep = createDep(() => ref2.dep = void 0, ref2 instanceof ComputedRefImpl ? ref2 : void 0)),  true ? {\n      target: ref2,\n      type: \"get\",\n      key: \"value\"\n    } : 0);\n  }\n}\nfunction triggerRefValue(ref2, dirtyLevel = 3, newVal) {\n  ref2 = toRaw(ref2);\n  const dep = ref2.dep;\n  if (dep) {\n    triggerEffects(dep, dirtyLevel,  true ? {\n      target: ref2,\n      type: \"set\",\n      key: \"value\",\n      newValue: newVal\n    } : 0);\n  }\n}\nfunction isRef(r) {\n  return !!(r && r.__v_isRef === true);\n}\nfunction ref(value) {\n  return createRef(value, false);\n}\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n  return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n  constructor(value, __v_isShallow) {\n    this.__v_isShallow = __v_isShallow;\n    this.dep = void 0;\n    this.__v_isRef = true;\n    this._rawValue = __v_isShallow ? value : toRaw(value);\n    this._value = __v_isShallow ? value : toReactive(value);\n  }\n  get value() {\n    trackRefValue(this);\n    return this._value;\n  }\n  set value(newVal) {\n    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);\n    newVal = useDirectValue ? newVal : toRaw(newVal);\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(newVal, this._rawValue)) {\n      this._rawValue = newVal;\n      this._value = useDirectValue ? newVal : toReactive(newVal);\n      triggerRefValue(this, 3, newVal);\n    }\n  }\n}\nfunction triggerRef(ref2) {\n  triggerRefValue(ref2, 3,  true ? ref2.value : 0);\n}\nfunction unref(ref2) {\n  return isRef(ref2) ? ref2.value : ref2;\n}\nfunction toValue(source) {\n  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source) ? source() : unref(source);\n}\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n  constructor(factory) {\n    this.dep = void 0;\n    this.__v_isRef = true;\n    const {\n      get,\n      set\n    } = factory(() => trackRefValue(this), () => triggerRefValue(this));\n    this._get = get;\n    this._set = set;\n  }\n  get value() {\n    return this._get();\n  }\n  set value(newVal) {\n    this._set(newVal);\n  }\n}\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n  if ( true && !isProxy(object)) {\n    console.warn(`toRefs() expects a reactive object but received a plain one.`);\n  }\n  const ret = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(object) ? new Array(object.length) : {};\n  for (const key in object) {\n    ret[key] = propertyToRef(object, key);\n  }\n  return ret;\n}\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this.__v_isRef = true;\n  }\n  get value() {\n    const val = this._object[this._key];\n    return val === void 0 ? this._defaultValue : val;\n  }\n  set value(newVal) {\n    this._object[this._key] = newVal;\n  }\n  get dep() {\n    return getDepFromReactive(toRaw(this._object), this._key);\n  }\n}\nclass GetterRefImpl {\n  constructor(_getter) {\n    this._getter = _getter;\n    this.__v_isRef = true;\n    this.__v_isReadonly = true;\n  }\n  get value() {\n    return this._getter();\n  }\n}\nfunction toRef(source, key, defaultValue) {\n  if (isRef(source)) {\n    return source;\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {\n    return new GetterRefImpl(source);\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(source) && arguments.length > 1) {\n    return propertyToRef(source, key, defaultValue);\n  } else {\n    return ref(source);\n  }\n}\nfunction propertyToRef(source, key, defaultValue) {\n  const val = source[key];\n  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);\n}\nconst deferredComputed = computed;\nconst TrackOpTypes = {\n  \"GET\": \"get\",\n  \"HAS\": \"has\",\n  \"ITERATE\": \"iterate\"\n};\nconst TriggerOpTypes = {\n  \"SET\": \"set\",\n  \"ADD\": \"add\",\n  \"DELETE\": \"delete\",\n  \"CLEAR\": \"clear\"\n};\nconst ReactiveFlags = {\n  \"SKIP\": \"__v_skip\",\n  \"IS_REACTIVE\": \"__v_isReactive\",\n  \"IS_READONLY\": \"__v_isReadonly\",\n  \"IS_SHALLOW\": \"__v_isShallow\",\n  \"RAW\": \"__v_raw\"\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js?");

/***/ }),

/***/ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseTransition: function() { return /* binding */ BaseTransition; },\n/* harmony export */   BaseTransitionPropsValidators: function() { return /* binding */ BaseTransitionPropsValidators; },\n/* harmony export */   Comment: function() { return /* binding */ Comment; },\n/* harmony export */   DeprecationTypes: function() { return /* binding */ DeprecationTypes; },\n/* harmony export */   EffectScope: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.EffectScope; },\n/* harmony export */   ErrorCodes: function() { return /* binding */ ErrorCodes; },\n/* harmony export */   ErrorTypeStrings: function() { return /* binding */ ErrorTypeStrings; },\n/* harmony export */   Fragment: function() { return /* binding */ Fragment; },\n/* harmony export */   KeepAlive: function() { return /* binding */ KeepAlive; },\n/* harmony export */   ReactiveEffect: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.ReactiveEffect; },\n/* harmony export */   Static: function() { return /* binding */ Static; },\n/* harmony export */   Suspense: function() { return /* binding */ Suspense; },\n/* harmony export */   Teleport: function() { return /* binding */ Teleport; },\n/* harmony export */   Text: function() { return /* binding */ Text; },\n/* harmony export */   TrackOpTypes: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.TrackOpTypes; },\n/* harmony export */   TriggerOpTypes: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.TriggerOpTypes; },\n/* harmony export */   assertNumber: function() { return /* binding */ assertNumber; },\n/* harmony export */   callWithAsyncErrorHandling: function() { return /* binding */ callWithAsyncErrorHandling; },\n/* harmony export */   callWithErrorHandling: function() { return /* binding */ callWithErrorHandling; },\n/* harmony export */   camelize: function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_2__.camelize; },\n/* harmony export */   capitalize: function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_2__.capitalize; },\n/* harmony export */   cloneVNode: function() { return /* binding */ cloneVNode; },\n/* harmony export */   compatUtils: function() { return /* binding */ compatUtils; },\n/* harmony export */   computed: function() { return /* binding */ computed; },\n/* harmony export */   createBlock: function() { return /* binding */ createBlock; },\n/* harmony export */   createCommentVNode: function() { return /* binding */ createCommentVNode; },\n/* harmony export */   createElementBlock: function() { return /* binding */ createElementBlock; },\n/* harmony export */   createElementVNode: function() { return /* binding */ createBaseVNode; },\n/* harmony export */   createHydrationRenderer: function() { return /* binding */ createHydrationRenderer; },\n/* harmony export */   createPropsRestProxy: function() { return /* binding */ createPropsRestProxy; },\n/* harmony export */   createRenderer: function() { return /* binding */ createRenderer; },\n/* harmony export */   createSlots: function() { return /* binding */ createSlots; },\n/* harmony export */   createStaticVNode: function() { return /* binding */ createStaticVNode; },\n/* harmony export */   createTextVNode: function() { return /* binding */ createTextVNode; },\n/* harmony export */   createVNode: function() { return /* binding */ createVNode; },\n/* harmony export */   customRef: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.customRef; },\n/* harmony export */   defineAsyncComponent: function() { return /* binding */ defineAsyncComponent; },\n/* harmony export */   defineComponent: function() { return /* binding */ defineComponent; },\n/* harmony export */   defineEmits: function() { return /* binding */ defineEmits; },\n/* harmony export */   defineExpose: function() { return /* binding */ defineExpose; },\n/* harmony export */   defineModel: function() { return /* binding */ defineModel; },\n/* harmony export */   defineOptions: function() { return /* binding */ defineOptions; },\n/* harmony export */   defineProps: function() { return /* binding */ defineProps; },\n/* harmony export */   defineSlots: function() { return /* binding */ defineSlots; },\n/* harmony export */   devtools: function() { return /* binding */ devtools; },\n/* harmony export */   effect: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.effect; },\n/* harmony export */   effectScope: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.effectScope; },\n/* harmony export */   getCurrentInstance: function() { return /* binding */ getCurrentInstance; },\n/* harmony export */   getCurrentScope: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.getCurrentScope; },\n/* harmony export */   getTransitionRawChildren: function() { return /* binding */ getTransitionRawChildren; },\n/* harmony export */   guardReactiveProps: function() { return /* binding */ guardReactiveProps; },\n/* harmony export */   h: function() { return /* binding */ h; },\n/* harmony export */   handleError: function() { return /* binding */ handleError; },\n/* harmony export */   hasInjectionContext: function() { return /* binding */ hasInjectionContext; },\n/* harmony export */   initCustomFormatter: function() { return /* binding */ initCustomFormatter; },\n/* harmony export */   inject: function() { return /* binding */ inject; },\n/* harmony export */   isMemoSame: function() { return /* binding */ isMemoSame; },\n/* harmony export */   isProxy: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.isProxy; },\n/* harmony export */   isReactive: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.isReactive; },\n/* harmony export */   isReadonly: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.isReadonly; },\n/* harmony export */   isRef: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.isRef; },\n/* harmony export */   isRuntimeOnly: function() { return /* binding */ isRuntimeOnly; },\n/* harmony export */   isShallow: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.isShallow; },\n/* harmony export */   isVNode: function() { return /* binding */ isVNode; },\n/* harmony export */   markRaw: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.markRaw; },\n/* harmony export */   mergeDefaults: function() { return /* binding */ mergeDefaults; },\n/* harmony export */   mergeModels: function() { return /* binding */ mergeModels; },\n/* harmony export */   mergeProps: function() { return /* binding */ mergeProps; },\n/* harmony export */   nextTick: function() { return /* binding */ nextTick; },\n/* harmony export */   normalizeClass: function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_2__.normalizeClass; },\n/* harmony export */   normalizeProps: function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_2__.normalizeProps; },\n/* harmony export */   normalizeStyle: function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_2__.normalizeStyle; },\n/* harmony export */   onActivated: function() { return /* binding */ onActivated; },\n/* harmony export */   onBeforeMount: function() { return /* binding */ onBeforeMount; },\n/* harmony export */   onBeforeUnmount: function() { return /* binding */ onBeforeUnmount; },\n/* harmony export */   onBeforeUpdate: function() { return /* binding */ onBeforeUpdate; },\n/* harmony export */   onDeactivated: function() { return /* binding */ onDeactivated; },\n/* harmony export */   onErrorCaptured: function() { return /* binding */ onErrorCaptured; },\n/* harmony export */   onMounted: function() { return /* binding */ onMounted; },\n/* harmony export */   onRenderTracked: function() { return /* binding */ onRenderTracked; },\n/* harmony export */   onRenderTriggered: function() { return /* binding */ onRenderTriggered; },\n/* harmony export */   onScopeDispose: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.onScopeDispose; },\n/* harmony export */   onServerPrefetch: function() { return /* binding */ onServerPrefetch; },\n/* harmony export */   onUnmounted: function() { return /* binding */ onUnmounted; },\n/* harmony export */   onUpdated: function() { return /* binding */ onUpdated; },\n/* harmony export */   openBlock: function() { return /* binding */ openBlock; },\n/* harmony export */   popScopeId: function() { return /* binding */ popScopeId; },\n/* harmony export */   provide: function() { return /* binding */ provide; },\n/* harmony export */   proxyRefs: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.proxyRefs; },\n/* harmony export */   pushScopeId: function() { return /* binding */ pushScopeId; },\n/* harmony export */   queuePostFlushCb: function() { return /* binding */ queuePostFlushCb; },\n/* harmony export */   reactive: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.reactive; },\n/* harmony export */   readonly: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.readonly; },\n/* harmony export */   ref: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.ref; },\n/* harmony export */   registerRuntimeCompiler: function() { return /* binding */ registerRuntimeCompiler; },\n/* harmony export */   renderList: function() { return /* binding */ renderList; },\n/* harmony export */   renderSlot: function() { return /* binding */ renderSlot; },\n/* harmony export */   resolveComponent: function() { return /* binding */ resolveComponent; },\n/* harmony export */   resolveDirective: function() { return /* binding */ resolveDirective; },\n/* harmony export */   resolveDynamicComponent: function() { return /* binding */ resolveDynamicComponent; },\n/* harmony export */   resolveFilter: function() { return /* binding */ resolveFilter; },\n/* harmony export */   resolveTransitionHooks: function() { return /* binding */ resolveTransitionHooks; },\n/* harmony export */   setBlockTracking: function() { return /* binding */ setBlockTracking; },\n/* harmony export */   setDevtoolsHook: function() { return /* binding */ setDevtoolsHook; },\n/* harmony export */   setTransitionHooks: function() { return /* binding */ setTransitionHooks; },\n/* harmony export */   shallowReactive: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.shallowReactive; },\n/* harmony export */   shallowReadonly: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.shallowReadonly; },\n/* harmony export */   shallowRef: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.shallowRef; },\n/* harmony export */   ssrContextKey: function() { return /* binding */ ssrContextKey; },\n/* harmony export */   ssrUtils: function() { return /* binding */ ssrUtils; },\n/* harmony export */   stop: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.stop; },\n/* harmony export */   toDisplayString: function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_2__.toDisplayString; },\n/* harmony export */   toHandlerKey: function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_2__.toHandlerKey; },\n/* harmony export */   toHandlers: function() { return /* binding */ toHandlers; },\n/* harmony export */   toRaw: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.toRaw; },\n/* harmony export */   toRef: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.toRef; },\n/* harmony export */   toRefs: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.toRefs; },\n/* harmony export */   toValue: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.toValue; },\n/* harmony export */   transformVNodeArgs: function() { return /* binding */ transformVNodeArgs; },\n/* harmony export */   triggerRef: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.triggerRef; },\n/* harmony export */   unref: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.unref; },\n/* harmony export */   useAttrs: function() { return /* binding */ useAttrs; },\n/* harmony export */   useModel: function() { return /* binding */ useModel; },\n/* harmony export */   useSSRContext: function() { return /* binding */ useSSRContext; },\n/* harmony export */   useSlots: function() { return /* binding */ useSlots; },\n/* harmony export */   useTransitionState: function() { return /* binding */ useTransitionState; },\n/* harmony export */   version: function() { return /* binding */ version; },\n/* harmony export */   warn: function() { return /* binding */ warn; },\n/* harmony export */   watch: function() { return /* binding */ watch; },\n/* harmony export */   watchEffect: function() { return /* binding */ watchEffect; },\n/* harmony export */   watchPostEffect: function() { return /* binding */ watchPostEffect; },\n/* harmony export */   watchSyncEffect: function() { return /* binding */ watchSyncEffect; },\n/* harmony export */   withAsyncContext: function() { return /* binding */ withAsyncContext; },\n/* harmony export */   withCtx: function() { return /* binding */ withCtx; },\n/* harmony export */   withDefaults: function() { return /* binding */ withDefaults; },\n/* harmony export */   withDirectives: function() { return /* binding */ withDirectives; },\n/* harmony export */   withMemo: function() { return /* binding */ withMemo; },\n/* harmony export */   withScopeId: function() { return /* binding */ withScopeId; }\n/* harmony export */ });\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.push.js */ \"./node_modules/core-js/modules/es.array.push.js\");\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/reactivity */ \"./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js\");\n/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/shared */ \"./node_modules/@vue/shared/dist/shared.esm-bundler.js\");\n\n\n\n\n\nconst stack = [];\nfunction pushWarningContext(vnode) {\n  stack.push(vnode);\n}\nfunction popWarningContext() {\n  stack.pop();\n}\nfunction warn$1(msg, ...args) {\n  (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.pauseTracking)();\n  const instance = stack.length ? stack[stack.length - 1].component : null;\n  const appWarnHandler = instance && instance.appContext.config.warnHandler;\n  const trace = getComponentTrace();\n  if (appWarnHandler) {\n    callWithErrorHandling(appWarnHandler, instance, 11, [msg + args.join(\"\"), instance && instance.proxy, trace.map(({\n      vnode\n    }) => `at <${formatComponentName(instance, vnode.type)}>`).join(\"\\n\"), trace]);\n  } else {\n    const warnArgs = [`[Vue warn]: ${msg}`, ...args];\n    if (trace.length &&\n    // avoid spamming console during tests\n    true) {\n      warnArgs.push(`\n`, ...formatTrace(trace));\n    }\n    console.warn(...warnArgs);\n  }\n  (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.resetTracking)();\n}\nfunction getComponentTrace() {\n  let currentVNode = stack[stack.length - 1];\n  if (!currentVNode) {\n    return [];\n  }\n  const normalizedStack = [];\n  while (currentVNode) {\n    const last = normalizedStack[0];\n    if (last && last.vnode === currentVNode) {\n      last.recurseCount++;\n    } else {\n      normalizedStack.push({\n        vnode: currentVNode,\n        recurseCount: 0\n      });\n    }\n    const parentInstance = currentVNode.component && currentVNode.component.parent;\n    currentVNode = parentInstance && parentInstance.vnode;\n  }\n  return normalizedStack;\n}\nfunction formatTrace(trace) {\n  const logs = [];\n  trace.forEach((entry, i) => {\n    logs.push(...(i === 0 ? [] : [`\n`]), ...formatTraceEntry(entry));\n  });\n  return logs;\n}\nfunction formatTraceEntry({\n  vnode,\n  recurseCount\n}) {\n  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\n  const isRoot = vnode.component ? vnode.component.parent == null : false;\n  const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;\n  const close = `>` + postfix;\n  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];\n}\nfunction formatProps(props) {\n  const res = [];\n  const keys = Object.keys(props);\n  keys.slice(0, 3).forEach(key => {\n    res.push(...formatProp(key, props[key]));\n  });\n  if (keys.length > 3) {\n    res.push(` ...`);\n  }\n  return res;\n}\nfunction formatProp(key, value, raw) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isString)(value)) {\n    value = JSON.stringify(value);\n    return raw ? value : [`${key}=${value}`];\n  } else if (typeof value === \"number\" || typeof value === \"boolean\" || value == null) {\n    return raw ? value : [`${key}=${value}`];\n  } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.isRef)(value)) {\n    value = formatProp(key, (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.toRaw)(value.value), true);\n    return raw ? value : [`${key}=Ref<`, value, `>`];\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(value)) {\n    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\n  } else {\n    value = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.toRaw)(value);\n    return raw ? value : [`${key}=`, value];\n  }\n}\nfunction assertNumber(val, type) {\n  if (false) {}\n  if (val === void 0) {\n    return;\n  } else if (typeof val !== \"number\") {\n    warn$1(`${type} is not a valid number - got ${JSON.stringify(val)}.`);\n  } else if (isNaN(val)) {\n    warn$1(`${type} is NaN - the duration expression might be incorrect.`);\n  }\n}\nconst ErrorCodes = {\n  \"SETUP_FUNCTION\": 0,\n  \"0\": \"SETUP_FUNCTION\",\n  \"RENDER_FUNCTION\": 1,\n  \"1\": \"RENDER_FUNCTION\",\n  \"WATCH_GETTER\": 2,\n  \"2\": \"WATCH_GETTER\",\n  \"WATCH_CALLBACK\": 3,\n  \"3\": \"WATCH_CALLBACK\",\n  \"WATCH_CLEANUP\": 4,\n  \"4\": \"WATCH_CLEANUP\",\n  \"NATIVE_EVENT_HANDLER\": 5,\n  \"5\": \"NATIVE_EVENT_HANDLER\",\n  \"COMPONENT_EVENT_HANDLER\": 6,\n  \"6\": \"COMPONENT_EVENT_HANDLER\",\n  \"VNODE_HOOK\": 7,\n  \"7\": \"VNODE_HOOK\",\n  \"DIRECTIVE_HOOK\": 8,\n  \"8\": \"DIRECTIVE_HOOK\",\n  \"TRANSITION_HOOK\": 9,\n  \"9\": \"TRANSITION_HOOK\",\n  \"APP_ERROR_HANDLER\": 10,\n  \"10\": \"APP_ERROR_HANDLER\",\n  \"APP_WARN_HANDLER\": 11,\n  \"11\": \"APP_WARN_HANDLER\",\n  \"FUNCTION_REF\": 12,\n  \"12\": \"FUNCTION_REF\",\n  \"ASYNC_COMPONENT_LOADER\": 13,\n  \"13\": \"ASYNC_COMPONENT_LOADER\",\n  \"SCHEDULER\": 14,\n  \"14\": \"SCHEDULER\"\n};\nconst ErrorTypeStrings$1 = {\n  [\"sp\"]: \"serverPrefetch hook\",\n  [\"bc\"]: \"beforeCreate hook\",\n  [\"c\"]: \"created hook\",\n  [\"bm\"]: \"beforeMount hook\",\n  [\"m\"]: \"mounted hook\",\n  [\"bu\"]: \"beforeUpdate hook\",\n  [\"u\"]: \"updated\",\n  [\"bum\"]: \"beforeUnmount hook\",\n  [\"um\"]: \"unmounted hook\",\n  [\"a\"]: \"activated hook\",\n  [\"da\"]: \"deactivated hook\",\n  [\"ec\"]: \"errorCaptured hook\",\n  [\"rtc\"]: \"renderTracked hook\",\n  [\"rtg\"]: \"renderTriggered hook\",\n  [0]: \"setup function\",\n  [1]: \"render function\",\n  [2]: \"watcher getter\",\n  [3]: \"watcher callback\",\n  [4]: \"watcher cleanup function\",\n  [5]: \"native event handler\",\n  [6]: \"component event handler\",\n  [7]: \"vnode hook\",\n  [8]: \"directive hook\",\n  [9]: \"transition hook\",\n  [10]: \"app errorHandler\",\n  [11]: \"app warnHandler\",\n  [12]: \"ref function\",\n  [13]: \"async component loader\",\n  [14]: \"scheduler flush. This is likely a Vue internals bug. Please open an issue at https://github.com/vuejs/core .\"\n};\nfunction callWithErrorHandling(fn, instance, type, args) {\n  let res;\n  try {\n    res = args ? fn(...args) : fn();\n  } catch (err) {\n    handleError(err, instance, type);\n  }\n  return res;\n}\nfunction callWithAsyncErrorHandling(fn, instance, type, args) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(fn)) {\n    const res = callWithErrorHandling(fn, instance, type, args);\n    if (res && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isPromise)(res)) {\n      res.catch(err => {\n        handleError(err, instance, type);\n      });\n    }\n    return res;\n  }\n  const values = [];\n  for (let i = 0; i < fn.length; i++) {\n    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\n  }\n  return values;\n}\nfunction handleError(err, instance, type, throwInDev = true) {\n  const contextVNode = instance ? instance.vnode : null;\n  if (instance) {\n    let cur = instance.parent;\n    const exposedInstance = instance.proxy;\n    const errorInfo =  true ? ErrorTypeStrings$1[type] : 0;\n    while (cur) {\n      const errorCapturedHooks = cur.ec;\n      if (errorCapturedHooks) {\n        for (let i = 0; i < errorCapturedHooks.length; i++) {\n          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\n            return;\n          }\n        }\n      }\n      cur = cur.parent;\n    }\n    const appErrorHandler = instance.appContext.config.errorHandler;\n    if (appErrorHandler) {\n      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);\n      return;\n    }\n  }\n  logError(err, type, contextVNode, throwInDev);\n}\nfunction logError(err, type, contextVNode, throwInDev = true) {\n  if (true) {\n    const info = ErrorTypeStrings$1[type];\n    if (contextVNode) {\n      pushWarningContext(contextVNode);\n    }\n    warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);\n    if (contextVNode) {\n      popWarningContext();\n    }\n    if (throwInDev) {\n      throw err;\n    } else {\n      console.error(err);\n    }\n  } else {}\n}\nlet isFlushing = false;\nlet isFlushPending = false;\nconst queue = [];\nlet flushIndex = 0;\nconst pendingPostFlushCbs = [];\nlet activePostFlushCbs = null;\nlet postFlushIndex = 0;\nconst resolvedPromise = /* @__PURE__ */Promise.resolve();\nlet currentFlushPromise = null;\nconst RECURSION_LIMIT = 100;\nfunction nextTick(fn) {\n  const p = currentFlushPromise || resolvedPromise;\n  return fn ? p.then(this ? fn.bind(this) : fn) : p;\n}\nfunction findInsertionIndex(id) {\n  let start = flushIndex + 1;\n  let end = queue.length;\n  while (start < end) {\n    const middle = start + end >>> 1;\n    const middleJob = queue[middle];\n    const middleJobId = getId(middleJob);\n    if (middleJobId < id || middleJobId === id && middleJob.pre) {\n      start = middle + 1;\n    } else {\n      end = middle;\n    }\n  }\n  return start;\n}\nfunction queueJob(job) {\n  if (!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {\n    if (job.id == null) {\n      queue.push(job);\n    } else {\n      queue.splice(findInsertionIndex(job.id), 0, job);\n    }\n    queueFlush();\n  }\n}\nfunction queueFlush() {\n  if (!isFlushing && !isFlushPending) {\n    isFlushPending = true;\n    currentFlushPromise = resolvedPromise.then(flushJobs);\n  }\n}\nfunction invalidateJob(job) {\n  const i = queue.indexOf(job);\n  if (i > flushIndex) {\n    queue.splice(i, 1);\n  }\n}\nfunction queuePostFlushCb(cb) {\n  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(cb)) {\n    if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {\n      pendingPostFlushCbs.push(cb);\n    }\n  } else {\n    pendingPostFlushCbs.push(...cb);\n  }\n  queueFlush();\n}\nfunction flushPreFlushCbs(instance, seen, i = isFlushing ? flushIndex + 1 : 0) {\n  if (true) {\n    seen = seen || /* @__PURE__ */new Map();\n  }\n  for (; i < queue.length; i++) {\n    const cb = queue[i];\n    if (cb && cb.pre) {\n      if (instance && cb.id !== instance.uid) {\n        continue;\n      }\n      if ( true && checkRecursiveUpdates(seen, cb)) {\n        continue;\n      }\n      queue.splice(i, 1);\n      i--;\n      cb();\n    }\n  }\n}\nfunction flushPostFlushCbs(seen) {\n  if (pendingPostFlushCbs.length) {\n    const deduped = [...new Set(pendingPostFlushCbs)];\n    pendingPostFlushCbs.length = 0;\n    if (activePostFlushCbs) {\n      activePostFlushCbs.push(...deduped);\n      return;\n    }\n    activePostFlushCbs = deduped;\n    if (true) {\n      seen = seen || /* @__PURE__ */new Map();\n    }\n    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));\n    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\n      if ( true && checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {\n        continue;\n      }\n      activePostFlushCbs[postFlushIndex]();\n    }\n    activePostFlushCbs = null;\n    postFlushIndex = 0;\n  }\n}\nconst getId = job => job.id == null ? Infinity : job.id;\nconst comparator = (a, b) => {\n  const diff = getId(a) - getId(b);\n  if (diff === 0) {\n    if (a.pre && !b.pre) return -1;\n    if (b.pre && !a.pre) return 1;\n  }\n  return diff;\n};\nfunction flushJobs(seen) {\n  isFlushPending = false;\n  isFlushing = true;\n  if (true) {\n    seen = seen || /* @__PURE__ */new Map();\n  }\n  queue.sort(comparator);\n  const check =  true ? job => checkRecursiveUpdates(seen, job) : 0;\n  try {\n    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\n      const job = queue[flushIndex];\n      if (job && job.active !== false) {\n        if ( true && check(job)) {\n          continue;\n        }\n        callWithErrorHandling(job, null, 14);\n      }\n    }\n  } finally {\n    flushIndex = 0;\n    queue.length = 0;\n    flushPostFlushCbs(seen);\n    isFlushing = false;\n    currentFlushPromise = null;\n    if (queue.length || pendingPostFlushCbs.length) {\n      flushJobs(seen);\n    }\n  }\n}\nfunction checkRecursiveUpdates(seen, fn) {\n  if (!seen.has(fn)) {\n    seen.set(fn, 1);\n  } else {\n    const count = seen.get(fn);\n    if (count > RECURSION_LIMIT) {\n      const instance = fn.ownerInstance;\n      const componentName = instance && getComponentName(instance.type);\n      handleError(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`, null, 10);\n      return true;\n    } else {\n      seen.set(fn, count + 1);\n    }\n  }\n}\nlet isHmrUpdating = false;\nconst hmrDirtyComponents = /* @__PURE__ */new Set();\nif (true) {\n  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.getGlobalThis)().__VUE_HMR_RUNTIME__ = {\n    createRecord: tryWrap(createRecord),\n    rerender: tryWrap(rerender),\n    reload: tryWrap(reload)\n  };\n}\nconst map = /* @__PURE__ */new Map();\nfunction registerHMR(instance) {\n  const id = instance.type.__hmrId;\n  let record = map.get(id);\n  if (!record) {\n    createRecord(id, instance.type);\n    record = map.get(id);\n  }\n  record.instances.add(instance);\n}\nfunction unregisterHMR(instance) {\n  map.get(instance.type.__hmrId).instances.delete(instance);\n}\nfunction createRecord(id, initialDef) {\n  if (map.has(id)) {\n    return false;\n  }\n  map.set(id, {\n    initialDef: normalizeClassComponent(initialDef),\n    instances: /* @__PURE__ */new Set()\n  });\n  return true;\n}\nfunction normalizeClassComponent(component) {\n  return isClassComponent(component) ? component.__vccOpts : component;\n}\nfunction rerender(id, newRender) {\n  const record = map.get(id);\n  if (!record) {\n    return;\n  }\n  record.initialDef.render = newRender;\n  [...record.instances].forEach(instance => {\n    if (newRender) {\n      instance.render = newRender;\n      normalizeClassComponent(instance.type).render = newRender;\n    }\n    instance.renderCache = [];\n    isHmrUpdating = true;\n    instance.effect.dirty = true;\n    instance.update();\n    isHmrUpdating = false;\n  });\n}\nfunction reload(id, newComp) {\n  const record = map.get(id);\n  if (!record) return;\n  newComp = normalizeClassComponent(newComp);\n  updateComponentDef(record.initialDef, newComp);\n  const instances = [...record.instances];\n  for (const instance of instances) {\n    const oldComp = normalizeClassComponent(instance.type);\n    if (!hmrDirtyComponents.has(oldComp)) {\n      if (oldComp !== record.initialDef) {\n        updateComponentDef(oldComp, newComp);\n      }\n      hmrDirtyComponents.add(oldComp);\n    }\n    instance.appContext.propsCache.delete(instance.type);\n    instance.appContext.emitsCache.delete(instance.type);\n    instance.appContext.optionsCache.delete(instance.type);\n    if (instance.ceReload) {\n      hmrDirtyComponents.add(oldComp);\n      instance.ceReload(newComp.styles);\n      hmrDirtyComponents.delete(oldComp);\n    } else if (instance.parent) {\n      instance.parent.effect.dirty = true;\n      queueJob(instance.parent.update);\n    } else if (instance.appContext.reload) {\n      instance.appContext.reload();\n    } else if (typeof window !== \"undefined\") {\n      window.location.reload();\n    } else {\n      console.warn(\"[HMR] Root or manually mounted instance modified. Full reload required.\");\n    }\n  }\n  queuePostFlushCb(() => {\n    for (const instance of instances) {\n      hmrDirtyComponents.delete(normalizeClassComponent(instance.type));\n    }\n  });\n}\nfunction updateComponentDef(oldComp, newComp) {\n  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)(oldComp, newComp);\n  for (const key in oldComp) {\n    if (key !== \"__file\" && !(key in newComp)) {\n      delete oldComp[key];\n    }\n  }\n}\nfunction tryWrap(fn) {\n  return (id, arg) => {\n    try {\n      return fn(id, arg);\n    } catch (e) {\n      console.error(e);\n      console.warn(`[HMR] Something went wrong during Vue component hot-reload. Full reload required.`);\n    }\n  };\n}\nlet devtools$1;\nlet buffer = [];\nlet devtoolsNotInstalled = false;\nfunction emit$1(event, ...args) {\n  if (devtools$1) {\n    devtools$1.emit(event, ...args);\n  } else if (!devtoolsNotInstalled) {\n    buffer.push({\n      event,\n      args\n    });\n  }\n}\nfunction setDevtoolsHook$1(hook, target) {\n  var _a, _b;\n  devtools$1 = hook;\n  if (devtools$1) {\n    devtools$1.enabled = true;\n    buffer.forEach(({\n      event,\n      args\n    }) => devtools$1.emit(event, ...args));\n    buffer = [];\n  } else if (\n  // handle late devtools injection - only do this if we are in an actual\n  // browser environment to avoid the timer handle stalling test runner exit\n  // (#4815)\n  typeof window !== \"undefined\" &&\n  // some envs mock window but not fully\n  window.HTMLElement &&\n  // also exclude jsdom\n  !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes(\"jsdom\"))) {\n    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];\n    replay.push(newHook => {\n      setDevtoolsHook$1(newHook, target);\n    });\n    setTimeout(() => {\n      if (!devtools$1) {\n        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;\n        devtoolsNotInstalled = true;\n        buffer = [];\n      }\n    }, 3e3);\n  } else {\n    devtoolsNotInstalled = true;\n    buffer = [];\n  }\n}\nfunction devtoolsInitApp(app, version) {\n  emit$1(\"app:init\" /* APP_INIT */, app, version, {\n    Fragment,\n    Text,\n    Comment,\n    Static\n  });\n}\nfunction devtoolsUnmountApp(app) {\n  emit$1(\"app:unmount\" /* APP_UNMOUNT */, app);\n}\nconst devtoolsComponentAdded = /* @__PURE__ */createDevtoolsComponentHook(\"component:added\" /* COMPONENT_ADDED */);\nconst devtoolsComponentUpdated = /* @__PURE__ */createDevtoolsComponentHook(\"component:updated\" /* COMPONENT_UPDATED */);\nconst _devtoolsComponentRemoved = /* @__PURE__ */createDevtoolsComponentHook(\"component:removed\" /* COMPONENT_REMOVED */);\nconst devtoolsComponentRemoved = component => {\n  if (devtools$1 && typeof devtools$1.cleanupBuffer === \"function\" &&\n  // remove the component if it wasn't buffered\n  !devtools$1.cleanupBuffer(component)) {\n    _devtoolsComponentRemoved(component);\n  }\n};\nfunction createDevtoolsComponentHook(hook) {\n  return component => {\n    emit$1(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : void 0, component);\n  };\n}\nconst devtoolsPerfStart = /* @__PURE__ */createDevtoolsPerformanceHook(\"perf:start\" /* PERFORMANCE_START */);\nconst devtoolsPerfEnd = /* @__PURE__ */createDevtoolsPerformanceHook(\"perf:end\" /* PERFORMANCE_END */);\nfunction createDevtoolsPerformanceHook(hook) {\n  return (component, type, time) => {\n    emit$1(hook, component.appContext.app, component.uid, component, type, time);\n  };\n}\nfunction devtoolsComponentEmit(component, event, params) {\n  emit$1(\"component:emit\" /* COMPONENT_EMIT */, component.appContext.app, component, event, params);\n}\nfunction emit(instance, event, ...rawArgs) {\n  if (instance.isUnmounted) return;\n  const props = instance.vnode.props || _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ;\n  if (true) {\n    const {\n      emitsOptions,\n      propsOptions: [propsOptions]\n    } = instance;\n    if (emitsOptions) {\n      if (!(event in emitsOptions) && true) {\n        if (!propsOptions || !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.toHandlerKey)(event) in propsOptions)) {\n          warn$1(`Component emitted event \"${event}\" but it is neither declared in the emits option nor as an \"${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.toHandlerKey)(event)}\" prop.`);\n        }\n      } else {\n        const validator = emitsOptions[event];\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(validator)) {\n          const isValid = validator(...rawArgs);\n          if (!isValid) {\n            warn$1(`Invalid event arguments: event validation failed for event \"${event}\".`);\n          }\n        }\n      }\n    }\n  }\n  let args = rawArgs;\n  const isModelListener = event.startsWith(\"update:\");\n  const modelArg = isModelListener && event.slice(7);\n  if (modelArg && modelArg in props) {\n    const modifiersKey = `${modelArg === \"modelValue\" ? \"model\" : modelArg}Modifiers`;\n    const {\n      number,\n      trim\n    } = props[modifiersKey] || _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ;\n    if (trim) {\n      args = rawArgs.map(a => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isString)(a) ? a.trim() : a);\n    }\n    if (number) {\n      args = rawArgs.map(_vue_shared__WEBPACK_IMPORTED_MODULE_2__.looseToNumber);\n    }\n  }\n  if (true) {\n    devtoolsComponentEmit(instance, event, args);\n  }\n  if (true) {\n    const lowerCaseEvent = event.toLowerCase();\n    if (lowerCaseEvent !== event && props[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.toHandlerKey)(lowerCaseEvent)]) {\n      warn$1(`Event \"${lowerCaseEvent}\" is emitted in component ${formatComponentName(instance, instance.type)} but the handler is registered for \"${event}\". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use \"${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hyphenate)(event)}\" instead of \"${event}\".`);\n    }\n  }\n  let handlerName;\n  let handler = props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.toHandlerKey)(event)] ||\n  // also try camelCase event handler (#2249)\n  props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.camelize)(event))];\n  if (!handler && isModelListener) {\n    handler = props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hyphenate)(event))];\n  }\n  if (handler) {\n    callWithAsyncErrorHandling(handler, instance, 6, args);\n  }\n  const onceHandler = props[handlerName + `Once`];\n  if (onceHandler) {\n    if (!instance.emitted) {\n      instance.emitted = {};\n    } else if (instance.emitted[handlerName]) {\n      return;\n    }\n    instance.emitted[handlerName] = true;\n    callWithAsyncErrorHandling(onceHandler, instance, 6, args);\n  }\n}\nfunction normalizeEmitsOptions(comp, appContext, asMixin = false) {\n  const cache = appContext.emitsCache;\n  const cached = cache.get(comp);\n  if (cached !== void 0) {\n    return cached;\n  }\n  const raw = comp.emits;\n  let normalized = {};\n  let hasExtends = false;\n  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(comp)) {\n    const extendEmits = raw2 => {\n      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);\n      if (normalizedFromExtend) {\n        hasExtends = true;\n        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)(normalized, normalizedFromExtend);\n      }\n    };\n    if (!asMixin && appContext.mixins.length) {\n      appContext.mixins.forEach(extendEmits);\n    }\n    if (comp.extends) {\n      extendEmits(comp.extends);\n    }\n    if (comp.mixins) {\n      comp.mixins.forEach(extendEmits);\n    }\n  }\n  if (!raw && !hasExtends) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isObject)(comp)) {\n      cache.set(comp, null);\n    }\n    return null;\n  }\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(raw)) {\n    raw.forEach(key => normalized[key] = null);\n  } else {\n    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)(normalized, raw);\n  }\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isObject)(comp)) {\n    cache.set(comp, normalized);\n  }\n  return normalized;\n}\nfunction isEmitListener(options, key) {\n  if (!options || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isOn)(key)) {\n    return false;\n  }\n  key = key.slice(2).replace(/Once$/, \"\");\n  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(options, key[0].toLowerCase() + key.slice(1)) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(options, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hyphenate)(key)) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(options, key);\n}\nlet currentRenderingInstance = null;\nlet currentScopeId = null;\nfunction setCurrentRenderingInstance(instance) {\n  const prev = currentRenderingInstance;\n  currentRenderingInstance = instance;\n  currentScopeId = instance && instance.type.__scopeId || null;\n  return prev;\n}\nfunction pushScopeId(id) {\n  currentScopeId = id;\n}\nfunction popScopeId() {\n  currentScopeId = null;\n}\nconst withScopeId = _id => withCtx;\nfunction withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {\n  if (!ctx) return fn;\n  if (fn._n) {\n    return fn;\n  }\n  const renderFnWithContext = (...args) => {\n    if (renderFnWithContext._d) {\n      setBlockTracking(-1);\n    }\n    const prevInstance = setCurrentRenderingInstance(ctx);\n    let res;\n    try {\n      res = fn(...args);\n    } finally {\n      setCurrentRenderingInstance(prevInstance);\n      if (renderFnWithContext._d) {\n        setBlockTracking(1);\n      }\n    }\n    if (true) {\n      devtoolsComponentUpdated(ctx);\n    }\n    return res;\n  };\n  renderFnWithContext._n = true;\n  renderFnWithContext._c = true;\n  renderFnWithContext._d = true;\n  return renderFnWithContext;\n}\nlet accessedAttrs = false;\nfunction markAttrsAccessed() {\n  accessedAttrs = true;\n}\nfunction renderComponentRoot(instance) {\n  const {\n    type: Component,\n    vnode,\n    proxy,\n    withProxy,\n    props,\n    propsOptions: [propsOptions],\n    slots,\n    attrs,\n    emit,\n    render,\n    renderCache,\n    data,\n    setupState,\n    ctx,\n    inheritAttrs\n  } = instance;\n  let result;\n  let fallthroughAttrs;\n  const prev = setCurrentRenderingInstance(instance);\n  if (true) {\n    accessedAttrs = false;\n  }\n  try {\n    if (vnode.shapeFlag & 4) {\n      const proxyToUse = withProxy || proxy;\n      const thisProxy =  true && setupState.__isScriptSetup ? new Proxy(proxyToUse, {\n        get(target, key, receiver) {\n          warn$1(`Property '${String(key)}' was accessed via 'this'. Avoid using 'this' in templates.`);\n          return Reflect.get(target, key, receiver);\n        }\n      }) : proxyToUse;\n      result = normalizeVNode(render.call(thisProxy, proxyToUse, renderCache, props, setupState, data, ctx));\n      fallthroughAttrs = attrs;\n    } else {\n      const render2 = Component;\n      if ( true && attrs === props) {\n        markAttrsAccessed();\n      }\n      result = normalizeVNode(render2.length > 1 ? render2(props,  true ? {\n        get attrs() {\n          markAttrsAccessed();\n          return attrs;\n        },\n        slots,\n        emit\n      } : 0) : render2(props, null\n      /* we know it doesn't need it */));\n      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);\n    }\n  } catch (err) {\n    blockStack.length = 0;\n    handleError(err, instance, 1);\n    result = createVNode(Comment);\n  }\n  let root = result;\n  let setRoot = void 0;\n  if ( true && result.patchFlag > 0 && result.patchFlag & 2048) {\n    [root, setRoot] = getChildRoot(result);\n  }\n  if (fallthroughAttrs && inheritAttrs !== false) {\n    const keys = Object.keys(fallthroughAttrs);\n    const {\n      shapeFlag\n    } = root;\n    if (keys.length) {\n      if (shapeFlag & (1 | 6)) {\n        if (propsOptions && keys.some(_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isModelListener)) {\n          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);\n        }\n        root = cloneVNode(root, fallthroughAttrs);\n      } else if ( true && !accessedAttrs && root.type !== Comment) {\n        const allAttrs = Object.keys(attrs);\n        const eventAttrs = [];\n        const extraAttrs = [];\n        for (let i = 0, l = allAttrs.length; i < l; i++) {\n          const key = allAttrs[i];\n          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isOn)(key)) {\n            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isModelListener)(key)) {\n              eventAttrs.push(key[2].toLowerCase() + key.slice(3));\n            }\n          } else {\n            extraAttrs.push(key);\n          }\n        }\n        if (extraAttrs.length) {\n          warn$1(`Extraneous non-props attributes (${extraAttrs.join(\", \")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`);\n        }\n        if (eventAttrs.length) {\n          warn$1(`Extraneous non-emits event listeners (${eventAttrs.join(\", \")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the \"emits\" option.`);\n        }\n      }\n    }\n  }\n  if (vnode.dirs) {\n    if ( true && !isElementRoot(root)) {\n      warn$1(`Runtime directive used on component with non-element root node. The directives will not function as intended.`);\n    }\n    root = cloneVNode(root);\n    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;\n  }\n  if (vnode.transition) {\n    if ( true && !isElementRoot(root)) {\n      warn$1(`Component inside <Transition> renders non-element root node that cannot be animated.`);\n    }\n    root.transition = vnode.transition;\n  }\n  if ( true && setRoot) {\n    setRoot(root);\n  } else {\n    result = root;\n  }\n  setCurrentRenderingInstance(prev);\n  return result;\n}\nconst getChildRoot = vnode => {\n  const rawChildren = vnode.children;\n  const dynamicChildren = vnode.dynamicChildren;\n  const childRoot = filterSingleRoot(rawChildren);\n  if (!childRoot) {\n    return [vnode, void 0];\n  }\n  const index = rawChildren.indexOf(childRoot);\n  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;\n  const setRoot = updatedRoot => {\n    rawChildren[index] = updatedRoot;\n    if (dynamicChildren) {\n      if (dynamicIndex > -1) {\n        dynamicChildren[dynamicIndex] = updatedRoot;\n      } else if (updatedRoot.patchFlag > 0) {\n        vnode.dynamicChildren = [...dynamicChildren, updatedRoot];\n      }\n    }\n  };\n  return [normalizeVNode(childRoot), setRoot];\n};\nfunction filterSingleRoot(children) {\n  let singleRoot;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    if (isVNode(child)) {\n      if (child.type !== Comment || child.children === \"v-if\") {\n        if (singleRoot) {\n          return;\n        } else {\n          singleRoot = child;\n        }\n      }\n    } else {\n      return;\n    }\n  }\n  return singleRoot;\n}\nconst getFunctionalFallthrough = attrs => {\n  let res;\n  for (const key in attrs) {\n    if (key === \"class\" || key === \"style\" || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isOn)(key)) {\n      (res || (res = {}))[key] = attrs[key];\n    }\n  }\n  return res;\n};\nconst filterModelListeners = (attrs, props) => {\n  const res = {};\n  for (const key in attrs) {\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isModelListener)(key) || !(key.slice(9) in props)) {\n      res[key] = attrs[key];\n    }\n  }\n  return res;\n};\nconst isElementRoot = vnode => {\n  return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;\n};\nfunction shouldUpdateComponent(prevVNode, nextVNode, optimized) {\n  const {\n    props: prevProps,\n    children: prevChildren,\n    component\n  } = prevVNode;\n  const {\n    props: nextProps,\n    children: nextChildren,\n    patchFlag\n  } = nextVNode;\n  const emits = component.emitsOptions;\n  if ( true && (prevChildren || nextChildren) && isHmrUpdating) {\n    return true;\n  }\n  if (nextVNode.dirs || nextVNode.transition) {\n    return true;\n  }\n  if (optimized && patchFlag >= 0) {\n    if (patchFlag & 1024) {\n      return true;\n    }\n    if (patchFlag & 16) {\n      if (!prevProps) {\n        return !!nextProps;\n      }\n      return hasPropsChanged(prevProps, nextProps, emits);\n    } else if (patchFlag & 8) {\n      const dynamicProps = nextVNode.dynamicProps;\n      for (let i = 0; i < dynamicProps.length; i++) {\n        const key = dynamicProps[i];\n        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {\n          return true;\n        }\n      }\n    }\n  } else {\n    if (prevChildren || nextChildren) {\n      if (!nextChildren || !nextChildren.$stable) {\n        return true;\n      }\n    }\n    if (prevProps === nextProps) {\n      return false;\n    }\n    if (!prevProps) {\n      return !!nextProps;\n    }\n    if (!nextProps) {\n      return true;\n    }\n    return hasPropsChanged(prevProps, nextProps, emits);\n  }\n  return false;\n}\nfunction hasPropsChanged(prevProps, nextProps, emitsOptions) {\n  const nextKeys = Object.keys(nextProps);\n  if (nextKeys.length !== Object.keys(prevProps).length) {\n    return true;\n  }\n  for (let i = 0; i < nextKeys.length; i++) {\n    const key = nextKeys[i];\n    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction updateHOCHostEl({\n  vnode,\n  parent\n}, el) {\n  if (!el) return;\n  while (parent) {\n    const root = parent.subTree;\n    if (root.suspense && root.suspense.activeBranch === vnode) {\n      root.el = vnode.el;\n    }\n    if (root === vnode) {\n      (vnode = parent.vnode).el = el;\n      parent = parent.parent;\n    } else {\n      break;\n    }\n  }\n}\nconst COMPONENTS = \"components\";\nconst DIRECTIVES = \"directives\";\nfunction resolveComponent(name, maybeSelfReference) {\n  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;\n}\nconst NULL_DYNAMIC_COMPONENT = Symbol.for(\"v-ndc\");\nfunction resolveDynamicComponent(component) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isString)(component)) {\n    return resolveAsset(COMPONENTS, component, false) || component;\n  } else {\n    return component || NULL_DYNAMIC_COMPONENT;\n  }\n}\nfunction resolveDirective(name) {\n  return resolveAsset(DIRECTIVES, name);\n}\nfunction resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {\n  const instance = currentRenderingInstance || currentInstance;\n  if (instance) {\n    const Component = instance.type;\n    if (type === COMPONENTS) {\n      const selfName = getComponentName(Component, false);\n      if (selfName && (selfName === name || selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.camelize)(name) || selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.camelize)(name)))) {\n        return Component;\n      }\n    }\n    const res =\n    // local registration\n    // check instance[type] first which is resolved for options API\n    resolve(instance[type] || Component[type], name) ||\n    // global registration\n    resolve(instance.appContext[type], name);\n    if (!res && maybeSelfReference) {\n      return Component;\n    }\n    if ( true && warnMissing && !res) {\n      const extra = type === COMPONENTS ? `\nIf this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;\n      warn$1(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);\n    }\n    return res;\n  } else if (true) {\n    warn$1(`resolve${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.capitalize)(type.slice(0, -1))} can only be used in render() or setup().`);\n  }\n}\nfunction resolve(registry, name) {\n  return registry && (registry[name] || registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.camelize)(name)] || registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.camelize)(name))]);\n}\nconst isSuspense = type => type.__isSuspense;\nlet suspenseId = 0;\nconst SuspenseImpl = {\n  name: \"Suspense\",\n  // In order to make Suspense tree-shakable, we need to avoid importing it\n  // directly in the renderer. The renderer checks for the __isSuspense flag\n  // on a vnode's type and calls the `process` method, passing in renderer\n  // internals.\n  __isSuspense: true,\n  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {\n    if (n1 == null) {\n      mountSuspense(n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals);\n    } else {\n      patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, rendererInternals);\n    }\n  },\n  hydrate: hydrateSuspense,\n  create: createSuspenseBoundary,\n  normalize: normalizeSuspenseChildren\n};\nconst Suspense = SuspenseImpl;\nfunction triggerEvent(vnode, name) {\n  const eventListener = vnode.props && vnode.props[name];\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(eventListener)) {\n    eventListener();\n  }\n}\nfunction mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {\n  const {\n    p: patch,\n    o: {\n      createElement\n    }\n  } = rendererInternals;\n  const hiddenContainer = createElement(\"div\");\n  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals);\n  patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, namespace, slotScopeIds);\n  if (suspense.deps > 0) {\n    triggerEvent(vnode, \"onPending\");\n    triggerEvent(vnode, \"onFallback\");\n    patch(null, vnode.ssFallback, container, anchor, parentComponent, null,\n    // fallback tree will not have suspense context\n    namespace, slotScopeIds);\n    setActiveBranch(suspense, vnode.ssFallback);\n  } else {\n    suspense.resolve(false, true);\n  }\n}\nfunction patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, {\n  p: patch,\n  um: unmount,\n  o: {\n    createElement\n  }\n}) {\n  const suspense = n2.suspense = n1.suspense;\n  suspense.vnode = n2;\n  n2.el = n1.el;\n  const newBranch = n2.ssContent;\n  const newFallback = n2.ssFallback;\n  const {\n    activeBranch,\n    pendingBranch,\n    isInFallback,\n    isHydrating\n  } = suspense;\n  if (pendingBranch) {\n    suspense.pendingBranch = newBranch;\n    if (isSameVNodeType(newBranch, pendingBranch)) {\n      patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, namespace, slotScopeIds, optimized);\n      if (suspense.deps <= 0) {\n        suspense.resolve();\n      } else if (isInFallback) {\n        if (!isHydrating) {\n          patch(activeBranch, newFallback, container, anchor, parentComponent, null,\n          // fallback tree will not have suspense context\n          namespace, slotScopeIds, optimized);\n          setActiveBranch(suspense, newFallback);\n        }\n      }\n    } else {\n      suspense.pendingId = suspenseId++;\n      if (isHydrating) {\n        suspense.isHydrating = false;\n        suspense.activeBranch = pendingBranch;\n      } else {\n        unmount(pendingBranch, parentComponent, suspense);\n      }\n      suspense.deps = 0;\n      suspense.effects.length = 0;\n      suspense.hiddenContainer = createElement(\"div\");\n      if (isInFallback) {\n        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, namespace, slotScopeIds, optimized);\n        if (suspense.deps <= 0) {\n          suspense.resolve();\n        } else {\n          patch(activeBranch, newFallback, container, anchor, parentComponent, null,\n          // fallback tree will not have suspense context\n          namespace, slotScopeIds, optimized);\n          setActiveBranch(suspense, newFallback);\n        }\n      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\n        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, namespace, slotScopeIds, optimized);\n        suspense.resolve(true);\n      } else {\n        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, namespace, slotScopeIds, optimized);\n        if (suspense.deps <= 0) {\n          suspense.resolve();\n        }\n      }\n    }\n  } else {\n    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\n      patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, namespace, slotScopeIds, optimized);\n      setActiveBranch(suspense, newBranch);\n    } else {\n      triggerEvent(n2, \"onPending\");\n      suspense.pendingBranch = newBranch;\n      if (newBranch.shapeFlag & 512) {\n        suspense.pendingId = newBranch.component.suspenseId;\n      } else {\n        suspense.pendingId = suspenseId++;\n      }\n      patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, namespace, slotScopeIds, optimized);\n      if (suspense.deps <= 0) {\n        suspense.resolve();\n      } else {\n        const {\n          timeout,\n          pendingId\n        } = suspense;\n        if (timeout > 0) {\n          setTimeout(() => {\n            if (suspense.pendingId === pendingId) {\n              suspense.fallback(newFallback);\n            }\n          }, timeout);\n        } else if (timeout === 0) {\n          suspense.fallback(newFallback);\n        }\n      }\n    }\n  }\n}\nlet hasWarned = false;\nfunction createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals, isHydrating = false) {\n  if ( true && !hasWarned) {\n    hasWarned = true;\n    console[console.info ? \"info\" : \"log\"](`<Suspense> is an experimental feature and its API will likely change.`);\n  }\n  const {\n    p: patch,\n    m: move,\n    um: unmount,\n    n: next,\n    o: {\n      parentNode,\n      remove\n    }\n  } = rendererInternals;\n  let parentSuspenseId;\n  const isSuspensible = isVNodeSuspensible(vnode);\n  if (isSuspensible) {\n    if (parentSuspense == null ? void 0 : parentSuspense.pendingBranch) {\n      parentSuspenseId = parentSuspense.pendingId;\n      parentSuspense.deps++;\n    }\n  }\n  const timeout = vnode.props ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.toNumber)(vnode.props.timeout) : void 0;\n  if (true) {\n    assertNumber(timeout, `Suspense timeout`);\n  }\n  const suspense = {\n    vnode,\n    parent: parentSuspense,\n    parentComponent,\n    namespace,\n    container,\n    hiddenContainer,\n    anchor,\n    deps: 0,\n    pendingId: suspenseId++,\n    timeout: typeof timeout === \"number\" ? timeout : -1,\n    activeBranch: null,\n    pendingBranch: null,\n    isInFallback: !isHydrating,\n    isHydrating,\n    isUnmounted: false,\n    effects: [],\n    resolve(resume = false, sync = false) {\n      if (true) {\n        if (!resume && !suspense.pendingBranch) {\n          throw new Error(`suspense.resolve() is called without a pending branch.`);\n        }\n        if (suspense.isUnmounted) {\n          throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);\n        }\n      }\n      const {\n        vnode: vnode2,\n        activeBranch,\n        pendingBranch,\n        pendingId,\n        effects,\n        parentComponent: parentComponent2,\n        container: container2\n      } = suspense;\n      let delayEnter = false;\n      if (suspense.isHydrating) {\n        suspense.isHydrating = false;\n      } else if (!resume) {\n        delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === \"out-in\";\n        if (delayEnter) {\n          activeBranch.transition.afterLeave = () => {\n            if (pendingId === suspense.pendingId) {\n              move(pendingBranch, container2, next(activeBranch), 0);\n              queuePostFlushCb(effects);\n            }\n          };\n        }\n        let {\n          anchor: anchor2\n        } = suspense;\n        if (activeBranch) {\n          anchor2 = next(activeBranch);\n          unmount(activeBranch, parentComponent2, suspense, true);\n        }\n        if (!delayEnter) {\n          move(pendingBranch, container2, anchor2, 0);\n        }\n      }\n      setActiveBranch(suspense, pendingBranch);\n      suspense.pendingBranch = null;\n      suspense.isInFallback = false;\n      let parent = suspense.parent;\n      let hasUnresolvedAncestor = false;\n      while (parent) {\n        if (parent.pendingBranch) {\n          parent.effects.push(...effects);\n          hasUnresolvedAncestor = true;\n          break;\n        }\n        parent = parent.parent;\n      }\n      if (!hasUnresolvedAncestor && !delayEnter) {\n        queuePostFlushCb(effects);\n      }\n      suspense.effects = [];\n      if (isSuspensible) {\n        if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {\n          parentSuspense.deps--;\n          if (parentSuspense.deps === 0 && !sync) {\n            parentSuspense.resolve();\n          }\n        }\n      }\n      triggerEvent(vnode2, \"onResolve\");\n    },\n    fallback(fallbackVNode) {\n      if (!suspense.pendingBranch) {\n        return;\n      }\n      const {\n        vnode: vnode2,\n        activeBranch,\n        parentComponent: parentComponent2,\n        container: container2,\n        namespace: namespace2\n      } = suspense;\n      triggerEvent(vnode2, \"onFallback\");\n      const anchor2 = next(activeBranch);\n      const mountFallback = () => {\n        if (!suspense.isInFallback) {\n          return;\n        }\n        patch(null, fallbackVNode, container2, anchor2, parentComponent2, null,\n        // fallback tree will not have suspense context\n        namespace2, slotScopeIds, optimized);\n        setActiveBranch(suspense, fallbackVNode);\n      };\n      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === \"out-in\";\n      if (delayEnter) {\n        activeBranch.transition.afterLeave = mountFallback;\n      }\n      suspense.isInFallback = true;\n      unmount(activeBranch, parentComponent2, null,\n      // no suspense so unmount hooks fire now\n      true\n      // shouldRemove\n      );\n      if (!delayEnter) {\n        mountFallback();\n      }\n    },\n    move(container2, anchor2, type) {\n      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);\n      suspense.container = container2;\n    },\n    next() {\n      return suspense.activeBranch && next(suspense.activeBranch);\n    },\n    registerDep(instance, setupRenderEffect) {\n      const isInPendingSuspense = !!suspense.pendingBranch;\n      if (isInPendingSuspense) {\n        suspense.deps++;\n      }\n      const hydratedEl = instance.vnode.el;\n      instance.asyncDep.catch(err => {\n        handleError(err, instance, 0);\n      }).then(asyncSetupResult => {\n        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {\n          return;\n        }\n        instance.asyncResolved = true;\n        const {\n          vnode: vnode2\n        } = instance;\n        if (true) {\n          pushWarningContext(vnode2);\n        }\n        handleSetupResult(instance, asyncSetupResult, false);\n        if (hydratedEl) {\n          vnode2.el = hydratedEl;\n        }\n        const placeholder = !hydratedEl && instance.subTree.el;\n        setupRenderEffect(instance, vnode2,\n        // component may have been moved before resolve.\n        // if this is not a hydration, instance.subTree will be the comment\n        // placeholder.\n        parentNode(hydratedEl || instance.subTree.el),\n        // anchor will not be used if this is hydration, so only need to\n        // consider the comment placeholder case.\n        hydratedEl ? null : next(instance.subTree), suspense, namespace, optimized);\n        if (placeholder) {\n          remove(placeholder);\n        }\n        updateHOCHostEl(instance, vnode2.el);\n        if (true) {\n          popWarningContext();\n        }\n        if (isInPendingSuspense && --suspense.deps === 0) {\n          suspense.resolve();\n        }\n      });\n    },\n    unmount(parentSuspense2, doRemove) {\n      suspense.isUnmounted = true;\n      if (suspense.activeBranch) {\n        unmount(suspense.activeBranch, parentComponent, parentSuspense2, doRemove);\n      }\n      if (suspense.pendingBranch) {\n        unmount(suspense.pendingBranch, parentComponent, parentSuspense2, doRemove);\n      }\n    }\n  };\n  return suspense;\n}\nfunction hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {\n  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode,\n  // eslint-disable-next-line no-restricted-globals\n  document.createElement(\"div\"), null, namespace, slotScopeIds, optimized, rendererInternals, true);\n  const result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);\n  if (suspense.deps === 0) {\n    suspense.resolve(false, true);\n  }\n  return result;\n}\nfunction normalizeSuspenseChildren(vnode) {\n  const {\n    shapeFlag,\n    children\n  } = vnode;\n  const isSlotChildren = shapeFlag & 32;\n  vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);\n  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);\n}\nfunction normalizeSuspenseSlot(s) {\n  let block;\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(s)) {\n    const trackBlock = isBlockTreeEnabled && s._c;\n    if (trackBlock) {\n      s._d = false;\n      openBlock();\n    }\n    s = s();\n    if (trackBlock) {\n      s._d = true;\n      block = currentBlock;\n      closeBlock();\n    }\n  }\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(s)) {\n    const singleChild = filterSingleRoot(s);\n    if ( true && !singleChild && s.filter(child => child !== NULL_DYNAMIC_COMPONENT).length > 0) {\n      warn$1(`<Suspense> slots expect a single root node.`);\n    }\n    s = singleChild;\n  }\n  s = normalizeVNode(s);\n  if (block && !s.dynamicChildren) {\n    s.dynamicChildren = block.filter(c => c !== s);\n  }\n  return s;\n}\nfunction queueEffectWithSuspense(fn, suspense) {\n  if (suspense && suspense.pendingBranch) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(fn)) {\n      suspense.effects.push(...fn);\n    } else {\n      suspense.effects.push(fn);\n    }\n  } else {\n    queuePostFlushCb(fn);\n  }\n}\nfunction setActiveBranch(suspense, branch) {\n  suspense.activeBranch = branch;\n  const {\n    vnode,\n    parentComponent\n  } = suspense;\n  const el = vnode.el = branch.el;\n  if (parentComponent && parentComponent.subTree === vnode) {\n    parentComponent.vnode.el = el;\n    updateHOCHostEl(parentComponent, el);\n  }\n}\nfunction isVNodeSuspensible(vnode) {\n  var _a;\n  return ((_a = vnode.props) == null ? void 0 : _a.suspensible) != null && vnode.props.suspensible !== false;\n}\nconst ssrContextKey = Symbol.for(\"v-scx\");\nconst useSSRContext = () => {\n  {\n    const ctx = inject(ssrContextKey);\n    if (!ctx) {\n       true && warn$1(`Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`);\n    }\n    return ctx;\n  }\n};\nfunction watchEffect(effect, options) {\n  return doWatch(effect, null, options);\n}\nfunction watchPostEffect(effect, options) {\n  return doWatch(effect, null,  true ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)({}, options, {\n    flush: \"post\"\n  }) : 0);\n}\nfunction watchSyncEffect(effect, options) {\n  return doWatch(effect, null,  true ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)({}, options, {\n    flush: \"sync\"\n  }) : 0);\n}\nconst INITIAL_WATCHER_VALUE = {};\nfunction watch(source, cb, options) {\n  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(cb)) {\n    warn$1(`\\`watch(fn, options?)\\` signature has been moved to a separate API. Use \\`watchEffect(fn, options?)\\` instead. \\`watch\\` now only supports \\`watch(source, cb, options?) signature.`);\n  }\n  return doWatch(source, cb, options);\n}\nfunction doWatch(source, cb, {\n  immediate,\n  deep,\n  flush,\n  once,\n  onTrack,\n  onTrigger\n} = _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ) {\n  if (cb && once) {\n    const _cb = cb;\n    cb = (...args) => {\n      _cb(...args);\n      unwatch();\n    };\n  }\n  if ( true && deep !== void 0 && typeof deep === \"number\") {\n    warn$1(`watch() \"deep\" option with number value will be used as watch depth in future versions. Please use a boolean instead to avoid potential breakage.`);\n  }\n  if ( true && !cb) {\n    if (immediate !== void 0) {\n      warn$1(`watch() \"immediate\" option is only respected when using the watch(source, callback, options?) signature.`);\n    }\n    if (deep !== void 0) {\n      warn$1(`watch() \"deep\" option is only respected when using the watch(source, callback, options?) signature.`);\n    }\n    if (once !== void 0) {\n      warn$1(`watch() \"once\" option is only respected when using the watch(source, callback, options?) signature.`);\n    }\n  }\n  const warnInvalidSource = s => {\n    warn$1(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);\n  };\n  const instance = currentInstance;\n  const reactiveGetter = source2 => deep === true ? source2 :\n  // for deep: false, only traverse root-level properties\n  traverse(source2, deep === false ? 1 : void 0);\n  let getter;\n  let forceTrigger = false;\n  let isMultiSource = false;\n  if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.isRef)(source)) {\n    getter = () => source.value;\n    forceTrigger = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.isShallow)(source);\n  } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.isReactive)(source)) {\n    getter = () => reactiveGetter(source);\n    forceTrigger = true;\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(source)) {\n    isMultiSource = true;\n    forceTrigger = source.some(s => (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.isReactive)(s) || (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.isShallow)(s));\n    getter = () => source.map(s => {\n      if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.isRef)(s)) {\n        return s.value;\n      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.isReactive)(s)) {\n        return reactiveGetter(s);\n      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(s)) {\n        return callWithErrorHandling(s, instance, 2);\n      } else {\n         true && warnInvalidSource(s);\n      }\n    });\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(source)) {\n    if (cb) {\n      getter = () => callWithErrorHandling(source, instance, 2);\n    } else {\n      getter = () => {\n        if (cleanup) {\n          cleanup();\n        }\n        return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);\n      };\n    }\n  } else {\n    getter = _vue_shared__WEBPACK_IMPORTED_MODULE_2__.NOOP;\n     true && warnInvalidSource(source);\n  }\n  if (cb && deep) {\n    const baseGetter = getter;\n    getter = () => traverse(baseGetter());\n  }\n  let cleanup;\n  let onCleanup = fn => {\n    cleanup = effect.onStop = () => {\n      callWithErrorHandling(fn, instance, 4);\n      cleanup = effect.onStop = void 0;\n    };\n  };\n  let ssrCleanup;\n  if (isInSSRComponentSetup) {\n    onCleanup = _vue_shared__WEBPACK_IMPORTED_MODULE_2__.NOOP;\n    if (!cb) {\n      getter();\n    } else if (immediate) {\n      callWithAsyncErrorHandling(cb, instance, 3, [getter(), isMultiSource ? [] : void 0, onCleanup]);\n    }\n    if (flush === \"sync\") {\n      const ctx = useSSRContext();\n      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);\n    } else {\n      return _vue_shared__WEBPACK_IMPORTED_MODULE_2__.NOOP;\n    }\n  }\n  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;\n  const job = () => {\n    if (!effect.active || !effect.dirty) {\n      return;\n    }\n    if (cb) {\n      const newValue = effect.run();\n      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasChanged)(v, oldValue[i])) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasChanged)(newValue, oldValue)) || false) {\n        if (cleanup) {\n          cleanup();\n        }\n        callWithAsyncErrorHandling(cb, instance, 3, [newValue,\n        // pass undefined as the old value when it's changed for the first time\n        oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue, onCleanup]);\n        oldValue = newValue;\n      }\n    } else {\n      effect.run();\n    }\n  };\n  job.allowRecurse = !!cb;\n  let scheduler;\n  if (flush === \"sync\") {\n    scheduler = job;\n  } else if (flush === \"post\") {\n    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\n  } else {\n    job.pre = true;\n    if (instance) job.id = instance.uid;\n    scheduler = () => queueJob(job);\n  }\n  const effect = new _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.ReactiveEffect(getter, _vue_shared__WEBPACK_IMPORTED_MODULE_2__.NOOP, scheduler);\n  const scope = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.getCurrentScope)();\n  const unwatch = () => {\n    effect.stop();\n    if (scope) {\n      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.remove)(scope.effects, effect);\n    }\n  };\n  if (true) {\n    effect.onTrack = onTrack;\n    effect.onTrigger = onTrigger;\n  }\n  if (cb) {\n    if (immediate) {\n      job();\n    } else {\n      oldValue = effect.run();\n    }\n  } else if (flush === \"post\") {\n    queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);\n  } else {\n    effect.run();\n  }\n  if (ssrCleanup) ssrCleanup.push(unwatch);\n  return unwatch;\n}\nfunction instanceWatch(source, value, options) {\n  const publicThis = this.proxy;\n  const getter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isString)(source) ? source.includes(\".\") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);\n  let cb;\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(value)) {\n    cb = value;\n  } else {\n    cb = value.handler;\n    options = value;\n  }\n  const cur = currentInstance;\n  setCurrentInstance(this);\n  const res = doWatch(getter, cb.bind(publicThis), options);\n  if (cur) {\n    setCurrentInstance(cur);\n  } else {\n    unsetCurrentInstance();\n  }\n  return res;\n}\nfunction createPathGetter(ctx, path) {\n  const segments = path.split(\".\");\n  return () => {\n    let cur = ctx;\n    for (let i = 0; i < segments.length && cur; i++) {\n      cur = cur[segments[i]];\n    }\n    return cur;\n  };\n}\nfunction traverse(value, depth, currentDepth = 0, seen) {\n  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isObject)(value) || value[\"__v_skip\"]) {\n    return value;\n  }\n  if (depth && depth > 0) {\n    if (currentDepth >= depth) {\n      return value;\n    }\n    currentDepth++;\n  }\n  seen = seen || /* @__PURE__ */new Set();\n  if (seen.has(value)) {\n    return value;\n  }\n  seen.add(value);\n  if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.isRef)(value)) {\n    traverse(value.value, depth, currentDepth, seen);\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(value)) {\n    for (let i = 0; i < value.length; i++) {\n      traverse(value[i], depth, currentDepth, seen);\n    }\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isSet)(value) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isMap)(value)) {\n    value.forEach(v => {\n      traverse(v, depth, currentDepth, seen);\n    });\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isPlainObject)(value)) {\n    for (const key in value) {\n      traverse(value[key], depth, currentDepth, seen);\n    }\n  }\n  return value;\n}\nfunction validateDirectiveName(name) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isBuiltInDirective)(name)) {\n    warn$1(\"Do not use built-in directive ids as custom directive id: \" + name);\n  }\n}\nfunction withDirectives(vnode, directives) {\n  const internalInstance = currentRenderingInstance;\n  if (internalInstance === null) {\n     true && warn$1(`withDirectives can only be used inside render functions.`);\n    return vnode;\n  }\n  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;\n  const bindings = vnode.dirs || (vnode.dirs = []);\n  for (let i = 0; i < directives.length; i++) {\n    let [dir, value, arg, modifiers = _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ] = directives[i];\n    if (dir) {\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(dir)) {\n        dir = {\n          mounted: dir,\n          updated: dir\n        };\n      }\n      if (dir.deep) {\n        traverse(value);\n      }\n      bindings.push({\n        dir,\n        instance,\n        value,\n        oldValue: void 0,\n        arg,\n        modifiers\n      });\n    }\n  }\n  return vnode;\n}\nfunction invokeDirectiveHook(vnode, prevVNode, instance, name) {\n  const bindings = vnode.dirs;\n  const oldBindings = prevVNode && prevVNode.dirs;\n  for (let i = 0; i < bindings.length; i++) {\n    const binding = bindings[i];\n    if (oldBindings) {\n      binding.oldValue = oldBindings[i].value;\n    }\n    let hook = binding.dir[name];\n    if (hook) {\n      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.pauseTracking)();\n      callWithAsyncErrorHandling(hook, instance, 8, [vnode.el, binding, vnode, prevVNode]);\n      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.resetTracking)();\n    }\n  }\n}\nconst leaveCbKey = Symbol(\"_leaveCb\");\nconst enterCbKey = Symbol(\"_enterCb\");\nfunction useTransitionState() {\n  const state = {\n    isMounted: false,\n    isLeaving: false,\n    isUnmounting: false,\n    leavingVNodes: /* @__PURE__ */new Map()\n  };\n  onMounted(() => {\n    state.isMounted = true;\n  });\n  onBeforeUnmount(() => {\n    state.isUnmounting = true;\n  });\n  return state;\n}\nconst TransitionHookValidator = [Function, Array];\nconst BaseTransitionPropsValidators = {\n  mode: String,\n  appear: Boolean,\n  persisted: Boolean,\n  // enter\n  onBeforeEnter: TransitionHookValidator,\n  onEnter: TransitionHookValidator,\n  onAfterEnter: TransitionHookValidator,\n  onEnterCancelled: TransitionHookValidator,\n  // leave\n  onBeforeLeave: TransitionHookValidator,\n  onLeave: TransitionHookValidator,\n  onAfterLeave: TransitionHookValidator,\n  onLeaveCancelled: TransitionHookValidator,\n  // appear\n  onBeforeAppear: TransitionHookValidator,\n  onAppear: TransitionHookValidator,\n  onAfterAppear: TransitionHookValidator,\n  onAppearCancelled: TransitionHookValidator\n};\nconst BaseTransitionImpl = {\n  name: `BaseTransition`,\n  props: BaseTransitionPropsValidators,\n  setup(props, {\n    slots\n  }) {\n    const instance = getCurrentInstance();\n    const state = useTransitionState();\n    let prevTransitionKey;\n    return () => {\n      const children = slots.default && getTransitionRawChildren(slots.default(), true);\n      if (!children || !children.length) {\n        return;\n      }\n      let child = children[0];\n      if (children.length > 1) {\n        let hasFound = false;\n        for (const c of children) {\n          if (c.type !== Comment) {\n            if ( true && hasFound) {\n              warn$1(\"<transition> can only be used on a single element or component. Use <transition-group> for lists.\");\n              break;\n            }\n            child = c;\n            hasFound = true;\n            if (false) {}\n          }\n        }\n      }\n      const rawProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.toRaw)(props);\n      const {\n        mode\n      } = rawProps;\n      if ( true && mode && mode !== \"in-out\" && mode !== \"out-in\" && mode !== \"default\") {\n        warn$1(`invalid <transition> mode: ${mode}`);\n      }\n      if (state.isLeaving) {\n        return emptyPlaceholder(child);\n      }\n      const innerChild = getKeepAliveChild(child);\n      if (!innerChild) {\n        return emptyPlaceholder(child);\n      }\n      const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);\n      setTransitionHooks(innerChild, enterHooks);\n      const oldChild = instance.subTree;\n      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);\n      let transitionKeyChanged = false;\n      const {\n        getTransitionKey\n      } = innerChild.type;\n      if (getTransitionKey) {\n        const key = getTransitionKey();\n        if (prevTransitionKey === void 0) {\n          prevTransitionKey = key;\n        } else if (key !== prevTransitionKey) {\n          prevTransitionKey = key;\n          transitionKeyChanged = true;\n        }\n      }\n      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {\n        const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);\n        setTransitionHooks(oldInnerChild, leavingHooks);\n        if (mode === \"out-in\") {\n          state.isLeaving = true;\n          leavingHooks.afterLeave = () => {\n            state.isLeaving = false;\n            if (instance.update.active !== false) {\n              instance.effect.dirty = true;\n              instance.update();\n            }\n          };\n          return emptyPlaceholder(child);\n        } else if (mode === \"in-out\" && innerChild.type !== Comment) {\n          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {\n            const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);\n            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;\n            el[leaveCbKey] = () => {\n              earlyRemove();\n              el[leaveCbKey] = void 0;\n              delete enterHooks.delayedLeave;\n            };\n            enterHooks.delayedLeave = delayedLeave;\n          };\n        }\n      }\n      return child;\n    };\n  }\n};\nconst BaseTransition = BaseTransitionImpl;\nfunction getLeavingNodesForType(state, vnode) {\n  const {\n    leavingVNodes\n  } = state;\n  let leavingVNodesCache = leavingVNodes.get(vnode.type);\n  if (!leavingVNodesCache) {\n    leavingVNodesCache = /* @__PURE__ */Object.create(null);\n    leavingVNodes.set(vnode.type, leavingVNodesCache);\n  }\n  return leavingVNodesCache;\n}\nfunction resolveTransitionHooks(vnode, props, state, instance) {\n  const {\n    appear,\n    mode,\n    persisted = false,\n    onBeforeEnter,\n    onEnter,\n    onAfterEnter,\n    onEnterCancelled,\n    onBeforeLeave,\n    onLeave,\n    onAfterLeave,\n    onLeaveCancelled,\n    onBeforeAppear,\n    onAppear,\n    onAfterAppear,\n    onAppearCancelled\n  } = props;\n  const key = String(vnode.key);\n  const leavingVNodesCache = getLeavingNodesForType(state, vnode);\n  const callHook = (hook, args) => {\n    hook && callWithAsyncErrorHandling(hook, instance, 9, args);\n  };\n  const callAsyncHook = (hook, args) => {\n    const done = args[1];\n    callHook(hook, args);\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(hook)) {\n      if (hook.every(hook2 => hook2.length <= 1)) done();\n    } else if (hook.length <= 1) {\n      done();\n    }\n  };\n  const hooks = {\n    mode,\n    persisted,\n    beforeEnter(el) {\n      let hook = onBeforeEnter;\n      if (!state.isMounted) {\n        if (appear) {\n          hook = onBeforeAppear || onBeforeEnter;\n        } else {\n          return;\n        }\n      }\n      if (el[leaveCbKey]) {\n        el[leaveCbKey](true\n        /* cancelled */);\n      }\n      const leavingVNode = leavingVNodesCache[key];\n      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {\n        leavingVNode.el[leaveCbKey]();\n      }\n      callHook(hook, [el]);\n    },\n    enter(el) {\n      let hook = onEnter;\n      let afterHook = onAfterEnter;\n      let cancelHook = onEnterCancelled;\n      if (!state.isMounted) {\n        if (appear) {\n          hook = onAppear || onEnter;\n          afterHook = onAfterAppear || onAfterEnter;\n          cancelHook = onAppearCancelled || onEnterCancelled;\n        } else {\n          return;\n        }\n      }\n      let called = false;\n      const done = el[enterCbKey] = cancelled => {\n        if (called) return;\n        called = true;\n        if (cancelled) {\n          callHook(cancelHook, [el]);\n        } else {\n          callHook(afterHook, [el]);\n        }\n        if (hooks.delayedLeave) {\n          hooks.delayedLeave();\n        }\n        el[enterCbKey] = void 0;\n      };\n      if (hook) {\n        callAsyncHook(hook, [el, done]);\n      } else {\n        done();\n      }\n    },\n    leave(el, remove) {\n      const key2 = String(vnode.key);\n      if (el[enterCbKey]) {\n        el[enterCbKey](true\n        /* cancelled */);\n      }\n      if (state.isUnmounting) {\n        return remove();\n      }\n      callHook(onBeforeLeave, [el]);\n      let called = false;\n      const done = el[leaveCbKey] = cancelled => {\n        if (called) return;\n        called = true;\n        remove();\n        if (cancelled) {\n          callHook(onLeaveCancelled, [el]);\n        } else {\n          callHook(onAfterLeave, [el]);\n        }\n        el[leaveCbKey] = void 0;\n        if (leavingVNodesCache[key2] === vnode) {\n          delete leavingVNodesCache[key2];\n        }\n      };\n      leavingVNodesCache[key2] = vnode;\n      if (onLeave) {\n        callAsyncHook(onLeave, [el, done]);\n      } else {\n        done();\n      }\n    },\n    clone(vnode2) {\n      return resolveTransitionHooks(vnode2, props, state, instance);\n    }\n  };\n  return hooks;\n}\nfunction emptyPlaceholder(vnode) {\n  if (isKeepAlive(vnode)) {\n    vnode = cloneVNode(vnode);\n    vnode.children = null;\n    return vnode;\n  }\n}\nfunction getKeepAliveChild(vnode) {\n  return isKeepAlive(vnode) ?\n  // #7121 ensure get the child component subtree in case\n  // it's been replaced during HMR\n   true && vnode.component ? vnode.component.subTree : vnode.children ? vnode.children[0] : void 0 : vnode;\n}\nfunction setTransitionHooks(vnode, hooks) {\n  if (vnode.shapeFlag & 6 && vnode.component) {\n    setTransitionHooks(vnode.component.subTree, hooks);\n  } else if (vnode.shapeFlag & 128) {\n    vnode.ssContent.transition = hooks.clone(vnode.ssContent);\n    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);\n  } else {\n    vnode.transition = hooks;\n  }\n}\nfunction getTransitionRawChildren(children, keepComment = false, parentKey) {\n  let ret = [];\n  let keyedFragmentCount = 0;\n  for (let i = 0; i < children.length; i++) {\n    let child = children[i];\n    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);\n    if (child.type === Fragment) {\n      if (child.patchFlag & 128) keyedFragmentCount++;\n      ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));\n    } else if (keepComment || child.type !== Comment) {\n      ret.push(key != null ? cloneVNode(child, {\n        key\n      }) : child);\n    }\n  }\n  if (keyedFragmentCount > 1) {\n    for (let i = 0; i < ret.length; i++) {\n      ret[i].patchFlag = -2;\n    }\n  }\n  return ret;\n}\n\n/*! #__NO_SIDE_EFFECTS__ */\n// @__NO_SIDE_EFFECTS__\nfunction defineComponent(options, extraOptions) {\n  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(options) ?\n  // #8326: extend call and options.name access are considered side-effects\n  // by Rollup, so we have to wrap it in a pure-annotated IIFE.\n  /* @__PURE__ */\n  (() => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)({\n    name: options.name\n  }, extraOptions, {\n    setup: options\n  }))() : options;\n}\nconst isAsyncWrapper = i => !!i.type.__asyncLoader;\n/*! #__NO_SIDE_EFFECTS__ */\n// @__NO_SIDE_EFFECTS__\nfunction defineAsyncComponent(source) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(source)) {\n    source = {\n      loader: source\n    };\n  }\n  const {\n    loader,\n    loadingComponent,\n    errorComponent,\n    delay = 200,\n    timeout,\n    // undefined = never times out\n    suspensible = true,\n    onError: userOnError\n  } = source;\n  let pendingRequest = null;\n  let resolvedComp;\n  let retries = 0;\n  const retry = () => {\n    retries++;\n    pendingRequest = null;\n    return load();\n  };\n  const load = () => {\n    let thisRequest;\n    return pendingRequest || (thisRequest = pendingRequest = loader().catch(err => {\n      err = err instanceof Error ? err : new Error(String(err));\n      if (userOnError) {\n        return new Promise((resolve, reject) => {\n          const userRetry = () => resolve(retry());\n          const userFail = () => reject(err);\n          userOnError(err, userRetry, userFail, retries + 1);\n        });\n      } else {\n        throw err;\n      }\n    }).then(comp => {\n      if (thisRequest !== pendingRequest && pendingRequest) {\n        return pendingRequest;\n      }\n      if ( true && !comp) {\n        warn$1(`Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`);\n      }\n      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === \"Module\")) {\n        comp = comp.default;\n      }\n      if ( true && comp && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isObject)(comp) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(comp)) {\n        throw new Error(`Invalid async component load result: ${comp}`);\n      }\n      resolvedComp = comp;\n      return comp;\n    }));\n  };\n  return defineComponent({\n    name: \"AsyncComponentWrapper\",\n    __asyncLoader: load,\n    get __asyncResolved() {\n      return resolvedComp;\n    },\n    setup() {\n      const instance = currentInstance;\n      if (resolvedComp) {\n        return () => createInnerComp(resolvedComp, instance);\n      }\n      const onError = err => {\n        pendingRequest = null;\n        handleError(err, instance, 13, !errorComponent);\n      };\n      if (suspensible && instance.suspense || isInSSRComponentSetup) {\n        return load().then(comp => {\n          return () => createInnerComp(comp, instance);\n        }).catch(err => {\n          onError(err);\n          return () => errorComponent ? createVNode(errorComponent, {\n            error: err\n          }) : null;\n        });\n      }\n      const loaded = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.ref)(false);\n      const error = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.ref)();\n      const delayed = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.ref)(!!delay);\n      if (delay) {\n        setTimeout(() => {\n          delayed.value = false;\n        }, delay);\n      }\n      if (timeout != null) {\n        setTimeout(() => {\n          if (!loaded.value && !error.value) {\n            const err = new Error(`Async component timed out after ${timeout}ms.`);\n            onError(err);\n            error.value = err;\n          }\n        }, timeout);\n      }\n      load().then(() => {\n        loaded.value = true;\n        if (instance.parent && isKeepAlive(instance.parent.vnode)) {\n          instance.parent.effect.dirty = true;\n          queueJob(instance.parent.update);\n        }\n      }).catch(err => {\n        onError(err);\n        error.value = err;\n      });\n      return () => {\n        if (loaded.value && resolvedComp) {\n          return createInnerComp(resolvedComp, instance);\n        } else if (error.value && errorComponent) {\n          return createVNode(errorComponent, {\n            error: error.value\n          });\n        } else if (loadingComponent && !delayed.value) {\n          return createVNode(loadingComponent);\n        }\n      };\n    }\n  });\n}\nfunction createInnerComp(comp, parent) {\n  const {\n    ref: ref2,\n    props,\n    children,\n    ce\n  } = parent.vnode;\n  const vnode = createVNode(comp, props, children);\n  vnode.ref = ref2;\n  vnode.ce = ce;\n  delete parent.vnode.ce;\n  return vnode;\n}\nconst isKeepAlive = vnode => vnode.type.__isKeepAlive;\nconst KeepAliveImpl = {\n  name: `KeepAlive`,\n  // Marker for special handling inside the renderer. We are not using a ===\n  // check directly on KeepAlive in the renderer, because importing it directly\n  // would prevent it from being tree-shaken.\n  __isKeepAlive: true,\n  props: {\n    include: [String, RegExp, Array],\n    exclude: [String, RegExp, Array],\n    max: [String, Number]\n  },\n  setup(props, {\n    slots\n  }) {\n    const instance = getCurrentInstance();\n    const sharedContext = instance.ctx;\n    if (!sharedContext.renderer) {\n      return () => {\n        const children = slots.default && slots.default();\n        return children && children.length === 1 ? children[0] : children;\n      };\n    }\n    const cache = /* @__PURE__ */new Map();\n    const keys = /* @__PURE__ */new Set();\n    let current = null;\n    if (true) {\n      instance.__v_cache = cache;\n    }\n    const parentSuspense = instance.suspense;\n    const {\n      renderer: {\n        p: patch,\n        m: move,\n        um: _unmount,\n        o: {\n          createElement\n        }\n      }\n    } = sharedContext;\n    const storageContainer = createElement(\"div\");\n    sharedContext.activate = (vnode, container, anchor, namespace, optimized) => {\n      const instance2 = vnode.component;\n      move(vnode, container, anchor, 0, parentSuspense);\n      patch(instance2.vnode, vnode, container, anchor, instance2, parentSuspense, namespace, vnode.slotScopeIds, optimized);\n      queuePostRenderEffect(() => {\n        instance2.isDeactivated = false;\n        if (instance2.a) {\n          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.invokeArrayFns)(instance2.a);\n        }\n        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;\n        if (vnodeHook) {\n          invokeVNodeHook(vnodeHook, instance2.parent, vnode);\n        }\n      }, parentSuspense);\n      if (true) {\n        devtoolsComponentAdded(instance2);\n      }\n    };\n    sharedContext.deactivate = vnode => {\n      const instance2 = vnode.component;\n      move(vnode, storageContainer, null, 1, parentSuspense);\n      queuePostRenderEffect(() => {\n        if (instance2.da) {\n          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.invokeArrayFns)(instance2.da);\n        }\n        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;\n        if (vnodeHook) {\n          invokeVNodeHook(vnodeHook, instance2.parent, vnode);\n        }\n        instance2.isDeactivated = true;\n      }, parentSuspense);\n      if (true) {\n        devtoolsComponentAdded(instance2);\n      }\n    };\n    function unmount(vnode) {\n      resetShapeFlag(vnode);\n      _unmount(vnode, instance, parentSuspense, true);\n    }\n    function pruneCache(filter) {\n      cache.forEach((vnode, key) => {\n        const name = getComponentName(vnode.type);\n        if (name && (!filter || !filter(name))) {\n          pruneCacheEntry(key);\n        }\n      });\n    }\n    function pruneCacheEntry(key) {\n      const cached = cache.get(key);\n      if (!current || !isSameVNodeType(cached, current)) {\n        unmount(cached);\n      } else if (current) {\n        resetShapeFlag(current);\n      }\n      cache.delete(key);\n      keys.delete(key);\n    }\n    watch(() => [props.include, props.exclude], ([include, exclude]) => {\n      include && pruneCache(name => matches(include, name));\n      exclude && pruneCache(name => !matches(exclude, name));\n    },\n    // prune post-render after `current` has been updated\n    {\n      flush: \"post\",\n      deep: true\n    });\n    let pendingCacheKey = null;\n    const cacheSubtree = () => {\n      if (pendingCacheKey != null) {\n        cache.set(pendingCacheKey, getInnerChild(instance.subTree));\n      }\n    };\n    onMounted(cacheSubtree);\n    onUpdated(cacheSubtree);\n    onBeforeUnmount(() => {\n      cache.forEach(cached => {\n        const {\n          subTree,\n          suspense\n        } = instance;\n        const vnode = getInnerChild(subTree);\n        if (cached.type === vnode.type && cached.key === vnode.key) {\n          resetShapeFlag(vnode);\n          const da = vnode.component.da;\n          da && queuePostRenderEffect(da, suspense);\n          return;\n        }\n        unmount(cached);\n      });\n    });\n    return () => {\n      pendingCacheKey = null;\n      if (!slots.default) {\n        return null;\n      }\n      const children = slots.default();\n      const rawVNode = children[0];\n      if (children.length > 1) {\n        if (true) {\n          warn$1(`KeepAlive should contain exactly one component child.`);\n        }\n        current = null;\n        return children;\n      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {\n        current = null;\n        return rawVNode;\n      }\n      let vnode = getInnerChild(rawVNode);\n      const comp = vnode.type;\n      const name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);\n      const {\n        include,\n        exclude,\n        max\n      } = props;\n      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {\n        current = vnode;\n        return rawVNode;\n      }\n      const key = vnode.key == null ? comp : vnode.key;\n      const cachedVNode = cache.get(key);\n      if (vnode.el) {\n        vnode = cloneVNode(vnode);\n        if (rawVNode.shapeFlag & 128) {\n          rawVNode.ssContent = vnode;\n        }\n      }\n      pendingCacheKey = key;\n      if (cachedVNode) {\n        vnode.el = cachedVNode.el;\n        vnode.component = cachedVNode.component;\n        if (vnode.transition) {\n          setTransitionHooks(vnode, vnode.transition);\n        }\n        vnode.shapeFlag |= 512;\n        keys.delete(key);\n        keys.add(key);\n      } else {\n        keys.add(key);\n        if (max && keys.size > parseInt(max, 10)) {\n          pruneCacheEntry(keys.values().next().value);\n        }\n      }\n      vnode.shapeFlag |= 256;\n      current = vnode;\n      return isSuspense(rawVNode.type) ? rawVNode : vnode;\n    };\n  }\n};\nconst KeepAlive = KeepAliveImpl;\nfunction matches(pattern, name) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(pattern)) {\n    return pattern.some(p => matches(p, name));\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isString)(pattern)) {\n    return pattern.split(\",\").includes(name);\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isRegExp)(pattern)) {\n    return pattern.test(name);\n  }\n  return false;\n}\nfunction onActivated(hook, target) {\n  registerKeepAliveHook(hook, \"a\", target);\n}\nfunction onDeactivated(hook, target) {\n  registerKeepAliveHook(hook, \"da\", target);\n}\nfunction registerKeepAliveHook(hook, type, target = currentInstance) {\n  const wrappedHook = hook.__wdc || (hook.__wdc = () => {\n    let current = target;\n    while (current) {\n      if (current.isDeactivated) {\n        return;\n      }\n      current = current.parent;\n    }\n    return hook();\n  });\n  injectHook(type, wrappedHook, target);\n  if (target) {\n    let current = target.parent;\n    while (current && current.parent) {\n      if (isKeepAlive(current.parent.vnode)) {\n        injectToKeepAliveRoot(wrappedHook, type, target, current);\n      }\n      current = current.parent;\n    }\n  }\n}\nfunction injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {\n  const injected = injectHook(type, hook, keepAliveRoot, true\n  /* prepend */);\n  onUnmounted(() => {\n    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.remove)(keepAliveRoot[type], injected);\n  }, target);\n}\nfunction resetShapeFlag(vnode) {\n  vnode.shapeFlag &= ~256;\n  vnode.shapeFlag &= ~512;\n}\nfunction getInnerChild(vnode) {\n  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;\n}\nfunction injectHook(type, hook, target = currentInstance, prepend = false) {\n  if (target) {\n    const hooks = target[type] || (target[type] = []);\n    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {\n      if (target.isUnmounted) {\n        return;\n      }\n      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.pauseTracking)();\n      setCurrentInstance(target);\n      const res = callWithAsyncErrorHandling(hook, target, type, args);\n      unsetCurrentInstance();\n      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.resetTracking)();\n      return res;\n    });\n    if (prepend) {\n      hooks.unshift(wrappedHook);\n    } else {\n      hooks.push(wrappedHook);\n    }\n    return wrappedHook;\n  } else if (true) {\n    const apiName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.toHandlerKey)(ErrorTypeStrings$1[type].replace(/ hook$/, \"\"));\n    warn$1(`${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup().` + ` If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);\n  }\n}\nconst createHook = lifecycle => (hook, target = currentInstance) =>\n// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)\n(!isInSSRComponentSetup || lifecycle === \"sp\") && injectHook(lifecycle, (...args) => hook(...args), target);\nconst onBeforeMount = createHook(\"bm\");\nconst onMounted = createHook(\"m\");\nconst onBeforeUpdate = createHook(\"bu\");\nconst onUpdated = createHook(\"u\");\nconst onBeforeUnmount = createHook(\"bum\");\nconst onUnmounted = createHook(\"um\");\nconst onServerPrefetch = createHook(\"sp\");\nconst onRenderTriggered = createHook(\"rtg\");\nconst onRenderTracked = createHook(\"rtc\");\nfunction onErrorCaptured(hook, target = currentInstance) {\n  injectHook(\"ec\", hook, target);\n}\nfunction renderList(source, renderItem, cache, index) {\n  let ret;\n  const cached = cache && cache[index];\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(source) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isString)(source)) {\n    ret = new Array(source.length);\n    for (let i = 0, l = source.length; i < l; i++) {\n      ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);\n    }\n  } else if (typeof source === \"number\") {\n    if ( true && !Number.isInteger(source)) {\n      warn$1(`The v-for range expect an integer value but got ${source}.`);\n    }\n    ret = new Array(source);\n    for (let i = 0; i < source; i++) {\n      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);\n    }\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isObject)(source)) {\n    if (source[Symbol.iterator]) {\n      ret = Array.from(source, (item, i) => renderItem(item, i, void 0, cached && cached[i]));\n    } else {\n      const keys = Object.keys(source);\n      ret = new Array(keys.length);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const key = keys[i];\n        ret[i] = renderItem(source[key], key, i, cached && cached[i]);\n      }\n    }\n  } else {\n    ret = [];\n  }\n  if (cache) {\n    cache[index] = ret;\n  }\n  return ret;\n}\nfunction createSlots(slots, dynamicSlots) {\n  for (let i = 0; i < dynamicSlots.length; i++) {\n    const slot = dynamicSlots[i];\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(slot)) {\n      for (let j = 0; j < slot.length; j++) {\n        slots[slot[j].name] = slot[j].fn;\n      }\n    } else if (slot) {\n      slots[slot.name] = slot.key ? (...args) => {\n        const res = slot.fn(...args);\n        if (res) res.key = slot.key;\n        return res;\n      } : slot.fn;\n    }\n  }\n  return slots;\n}\nfunction renderSlot(slots, name, props = {}, fallback, noSlotted) {\n  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {\n    if (name !== \"default\") props.name = name;\n    return createVNode(\"slot\", props, fallback && fallback());\n  }\n  let slot = slots[name];\n  if ( true && slot && slot.length > 1) {\n    warn$1(`SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`);\n    slot = () => [];\n  }\n  if (slot && slot._c) {\n    slot._d = false;\n  }\n  openBlock();\n  const validSlotContent = slot && ensureValidVNode(slot(props));\n  const rendered = createBlock(Fragment, {\n    key: props.key ||\n    // slot content array of a dynamic conditional slot may have a branch\n    // key attached in the `createSlots` helper, respect that\n    validSlotContent && validSlotContent.key || `_${name}`\n  }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);\n  if (!noSlotted && rendered.scopeId) {\n    rendered.slotScopeIds = [rendered.scopeId + \"-s\"];\n  }\n  if (slot && slot._c) {\n    slot._d = true;\n  }\n  return rendered;\n}\nfunction ensureValidVNode(vnodes) {\n  return vnodes.some(child => {\n    if (!isVNode(child)) return true;\n    if (child.type === Comment) return false;\n    if (child.type === Fragment && !ensureValidVNode(child.children)) return false;\n    return true;\n  }) ? vnodes : null;\n}\nfunction toHandlers(obj, preserveCaseIfNecessary) {\n  const ret = {};\n  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isObject)(obj)) {\n    warn$1(`v-on with no argument expects an object value.`);\n    return ret;\n  }\n  for (const key in obj) {\n    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.toHandlerKey)(key)] = obj[key];\n  }\n  return ret;\n}\nconst getPublicInstance = i => {\n  if (!i) return null;\n  if (isStatefulComponent(i)) return getExposeProxy(i) || i.proxy;\n  return getPublicInstance(i.parent);\n};\nconst publicPropertiesMap =\n// Move PURE marker to new line to workaround compiler discarding it\n// due to type annotation\n/* @__PURE__ */\n(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)( /* @__PURE__ */Object.create(null), {\n  $: i => i,\n  $el: i => i.vnode.el,\n  $data: i => i.data,\n  $props: i =>  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.shallowReadonly)(i.props) : 0,\n  $attrs: i =>  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.shallowReadonly)(i.attrs) : 0,\n  $slots: i =>  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.shallowReadonly)(i.slots) : 0,\n  $refs: i =>  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.shallowReadonly)(i.refs) : 0,\n  $parent: i => getPublicInstance(i.parent),\n  $root: i => getPublicInstance(i.root),\n  $emit: i => i.emit,\n  $options: i =>  true ? resolveMergedOptions(i) : 0,\n  $forceUpdate: i => i.f || (i.f = () => {\n    i.effect.dirty = true;\n    queueJob(i.update);\n  }),\n  $nextTick: i => i.n || (i.n = nextTick.bind(i.proxy)),\n  $watch: i =>  true ? instanceWatch.bind(i) : 0\n});\nconst isReservedPrefix = key => key === \"_\" || key === \"$\";\nconst hasSetupBinding = (state, key) => state !== _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ && !state.__isScriptSetup && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(state, key);\nconst PublicInstanceProxyHandlers = {\n  get({\n    _: instance\n  }, key) {\n    const {\n      ctx,\n      setupState,\n      data,\n      props,\n      accessCache,\n      type,\n      appContext\n    } = instance;\n    if ( true && key === \"__isVue\") {\n      return true;\n    }\n    let normalizedProps;\n    if (key[0] !== \"$\") {\n      const n = accessCache[key];\n      if (n !== void 0) {\n        switch (n) {\n          case 1 /* SETUP */:\n            return setupState[key];\n          case 2 /* DATA */:\n            return data[key];\n          case 4 /* CONTEXT */:\n            return ctx[key];\n          case 3 /* PROPS */:\n            return props[key];\n        }\n      } else if (hasSetupBinding(setupState, key)) {\n        accessCache[key] = 1 /* SETUP */;\n        return setupState[key];\n      } else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(data, key)) {\n        accessCache[key] = 2 /* DATA */;\n        return data[key];\n      } else if (\n      // only cache other properties when instance has declared (thus stable)\n      // props\n      (normalizedProps = instance.propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(normalizedProps, key)) {\n        accessCache[key] = 3 /* PROPS */;\n        return props[key];\n      } else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(ctx, key)) {\n        accessCache[key] = 4 /* CONTEXT */;\n        return ctx[key];\n      } else if ( false || shouldCacheAccess) {\n        accessCache[key] = 0 /* OTHER */;\n      }\n    }\n    const publicGetter = publicPropertiesMap[key];\n    let cssModule, globalProperties;\n    if (publicGetter) {\n      if (key === \"$attrs\") {\n        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.track)(instance, \"get\", key);\n         true && markAttrsAccessed();\n      } else if ( true && key === \"$slots\") {\n        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.track)(instance, \"get\", key);\n      }\n      return publicGetter(instance);\n    } else if (\n    // css module (injected by vue-loader)\n    (cssModule = type.__cssModules) && (cssModule = cssModule[key])) {\n      return cssModule;\n    } else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(ctx, key)) {\n      accessCache[key] = 4 /* CONTEXT */;\n      return ctx[key];\n    } else if (\n    // global properties\n    globalProperties = appContext.config.globalProperties, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(globalProperties, key)) {\n      {\n        return globalProperties[key];\n      }\n    } else if ( true && currentRenderingInstance && (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isString)(key) ||\n    // #1091 avoid internal isRef/isVNode checks on component instance leading\n    // to infinite warning loop\n    key.indexOf(\"__v\") !== 0)) {\n      if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ && isReservedPrefix(key[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(data, key)) {\n        warn$1(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved character (\"$\" or \"_\") and is not proxied on the render context.`);\n      } else if (instance === currentRenderingInstance) {\n        warn$1(`Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`);\n      }\n    }\n  },\n  set({\n    _: instance\n  }, key, value) {\n    const {\n      data,\n      setupState,\n      ctx\n    } = instance;\n    if (hasSetupBinding(setupState, key)) {\n      setupState[key] = value;\n      return true;\n    } else if ( true && setupState.__isScriptSetup && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(setupState, key)) {\n      warn$1(`Cannot mutate <script setup> binding \"${key}\" from Options API.`);\n      return false;\n    } else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(data, key)) {\n      data[key] = value;\n      return true;\n    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(instance.props, key)) {\n       true && warn$1(`Attempting to mutate prop \"${key}\". Props are readonly.`);\n      return false;\n    }\n    if (key[0] === \"$\" && key.slice(1) in instance) {\n       true && warn$1(`Attempting to mutate public property \"${key}\". Properties starting with $ are reserved and readonly.`);\n      return false;\n    } else {\n      if ( true && key in instance.appContext.config.globalProperties) {\n        Object.defineProperty(ctx, key, {\n          enumerable: true,\n          configurable: true,\n          value\n        });\n      } else {\n        ctx[key] = value;\n      }\n    }\n    return true;\n  },\n  has({\n    _: {\n      data,\n      setupState,\n      accessCache,\n      ctx,\n      appContext,\n      propsOptions\n    }\n  }, key) {\n    let normalizedProps;\n    return !!accessCache[key] || data !== _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(normalizedProps, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(ctx, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(publicPropertiesMap, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(appContext.config.globalProperties, key);\n  },\n  defineProperty(target, key, descriptor) {\n    if (descriptor.get != null) {\n      target._.accessCache[key] = 0;\n    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(descriptor, \"value\")) {\n      this.set(target, key, descriptor.value, null);\n    }\n    return Reflect.defineProperty(target, key, descriptor);\n  }\n};\nif (true) {\n  PublicInstanceProxyHandlers.ownKeys = target => {\n    warn$1(`Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`);\n    return Reflect.ownKeys(target);\n  };\n}\nconst RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)({}, PublicInstanceProxyHandlers, {\n  get(target, key) {\n    if (key === Symbol.unscopables) {\n      return;\n    }\n    return PublicInstanceProxyHandlers.get(target, key, target);\n  },\n  has(_, key) {\n    const has = key[0] !== \"_\" && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isGloballyAllowed)(key);\n    if ( true && !has && PublicInstanceProxyHandlers.has(_, key)) {\n      warn$1(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);\n    }\n    return has;\n  }\n});\nfunction createDevRenderContext(instance) {\n  const target = {};\n  Object.defineProperty(target, `_`, {\n    configurable: true,\n    enumerable: false,\n    get: () => instance\n  });\n  Object.keys(publicPropertiesMap).forEach(key => {\n    Object.defineProperty(target, key, {\n      configurable: true,\n      enumerable: false,\n      get: () => publicPropertiesMap[key](instance),\n      // intercepted by the proxy so no need for implementation,\n      // but needed to prevent set errors\n      set: _vue_shared__WEBPACK_IMPORTED_MODULE_2__.NOOP\n    });\n  });\n  return target;\n}\nfunction exposePropsOnRenderContext(instance) {\n  const {\n    ctx,\n    propsOptions: [propsOptions]\n  } = instance;\n  if (propsOptions) {\n    Object.keys(propsOptions).forEach(key => {\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => instance.props[key],\n        set: _vue_shared__WEBPACK_IMPORTED_MODULE_2__.NOOP\n      });\n    });\n  }\n}\nfunction exposeSetupStateOnRenderContext(instance) {\n  const {\n    ctx,\n    setupState\n  } = instance;\n  Object.keys((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.toRaw)(setupState)).forEach(key => {\n    if (!setupState.__isScriptSetup) {\n      if (isReservedPrefix(key[0])) {\n        warn$1(`setup() return property ${JSON.stringify(key)} should not start with \"$\" or \"_\" which are reserved prefixes for Vue internals.`);\n        return;\n      }\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => setupState[key],\n        set: _vue_shared__WEBPACK_IMPORTED_MODULE_2__.NOOP\n      });\n    }\n  });\n}\nconst warnRuntimeUsage = method => warn$1(`${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`);\nfunction defineProps() {\n  if (true) {\n    warnRuntimeUsage(`defineProps`);\n  }\n  return null;\n}\nfunction defineEmits() {\n  if (true) {\n    warnRuntimeUsage(`defineEmits`);\n  }\n  return null;\n}\nfunction defineExpose(exposed) {\n  if (true) {\n    warnRuntimeUsage(`defineExpose`);\n  }\n}\nfunction defineOptions(options) {\n  if (true) {\n    warnRuntimeUsage(`defineOptions`);\n  }\n}\nfunction defineSlots() {\n  if (true) {\n    warnRuntimeUsage(`defineSlots`);\n  }\n  return null;\n}\nfunction defineModel() {\n  if (true) {\n    warnRuntimeUsage(\"defineModel\");\n  }\n}\nfunction withDefaults(props, defaults) {\n  if (true) {\n    warnRuntimeUsage(`withDefaults`);\n  }\n  return null;\n}\nfunction useSlots() {\n  return getContext().slots;\n}\nfunction useAttrs() {\n  return getContext().attrs;\n}\nfunction useModel(props, name, options = _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ) {\n  const i = getCurrentInstance();\n  if ( true && !i) {\n    warn$1(`useModel() called without active instance.`);\n    return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.ref)();\n  }\n  if ( true && !i.propsOptions[0][name]) {\n    warn$1(`useModel() called with prop \"${name}\" which is not declared.`);\n    return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.ref)();\n  }\n  const camelizedName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.camelize)(name);\n  const hyphenatedName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hyphenate)(name);\n  const res = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.customRef)((track, trigger) => {\n    let localValue;\n    watchSyncEffect(() => {\n      const propValue = props[name];\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasChanged)(localValue, propValue)) {\n        localValue = propValue;\n        trigger();\n      }\n    });\n    return {\n      get() {\n        track();\n        return options.get ? options.get(localValue) : localValue;\n      },\n      set(value) {\n        const rawProps = i.vnode.props;\n        if (!(rawProps && (\n        // check if parent has passed v-model\n        name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && (`onUpdate:${name}` in rawProps || `onUpdate:${camelizedName}` in rawProps || `onUpdate:${hyphenatedName}` in rawProps)) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasChanged)(value, localValue)) {\n          localValue = value;\n          trigger();\n        }\n        i.emit(`update:${name}`, options.set ? options.set(value) : value);\n      }\n    };\n  });\n  const modifierKey = name === \"modelValue\" ? \"modelModifiers\" : `${name}Modifiers`;\n  res[Symbol.iterator] = () => {\n    let i2 = 0;\n    return {\n      next() {\n        if (i2 < 2) {\n          return {\n            value: i2++ ? props[modifierKey] || {} : res,\n            done: false\n          };\n        } else {\n          return {\n            done: true\n          };\n        }\n      }\n    };\n  };\n  return res;\n}\nfunction getContext() {\n  const i = getCurrentInstance();\n  if ( true && !i) {\n    warn$1(`useContext() called without active instance.`);\n  }\n  return i.setupContext || (i.setupContext = createSetupContext(i));\n}\nfunction normalizePropsOrEmits(props) {\n  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(props) ? props.reduce((normalized, p) => (normalized[p] = null, normalized), {}) : props;\n}\nfunction mergeDefaults(raw, defaults) {\n  const props = normalizePropsOrEmits(raw);\n  for (const key in defaults) {\n    if (key.startsWith(\"__skip\")) continue;\n    let opt = props[key];\n    if (opt) {\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(opt)) {\n        opt = props[key] = {\n          type: opt,\n          default: defaults[key]\n        };\n      } else {\n        opt.default = defaults[key];\n      }\n    } else if (opt === null) {\n      opt = props[key] = {\n        default: defaults[key]\n      };\n    } else if (true) {\n      warn$1(`props default key \"${key}\" has no corresponding declaration.`);\n    }\n    if (opt && defaults[`__skip_${key}`]) {\n      opt.skipFactory = true;\n    }\n  }\n  return props;\n}\nfunction mergeModels(a, b) {\n  if (!a || !b) return a || b;\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(a) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(b)) return a.concat(b);\n  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));\n}\nfunction createPropsRestProxy(props, excludedKeys) {\n  const ret = {};\n  for (const key in props) {\n    if (!excludedKeys.includes(key)) {\n      Object.defineProperty(ret, key, {\n        enumerable: true,\n        get: () => props[key]\n      });\n    }\n  }\n  return ret;\n}\nfunction withAsyncContext(getAwaitable) {\n  const ctx = getCurrentInstance();\n  if ( true && !ctx) {\n    warn$1(`withAsyncContext called without active current instance. This is likely a bug.`);\n  }\n  let awaitable = getAwaitable();\n  unsetCurrentInstance();\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isPromise)(awaitable)) {\n    awaitable = awaitable.catch(e => {\n      setCurrentInstance(ctx);\n      throw e;\n    });\n  }\n  return [awaitable, () => setCurrentInstance(ctx)];\n}\nfunction createDuplicateChecker() {\n  const cache = /* @__PURE__ */Object.create(null);\n  return (type, key) => {\n    if (cache[key]) {\n      warn$1(`${type} property \"${key}\" is already defined in ${cache[key]}.`);\n    } else {\n      cache[key] = type;\n    }\n  };\n}\nlet shouldCacheAccess = true;\nfunction applyOptions(instance) {\n  const options = resolveMergedOptions(instance);\n  const publicThis = instance.proxy;\n  const ctx = instance.ctx;\n  shouldCacheAccess = false;\n  if (options.beforeCreate) {\n    callHook(options.beforeCreate, instance, \"bc\");\n  }\n  const {\n    // state\n    data: dataOptions,\n    computed: computedOptions,\n    methods,\n    watch: watchOptions,\n    provide: provideOptions,\n    inject: injectOptions,\n    // lifecycle\n    created,\n    beforeMount,\n    mounted,\n    beforeUpdate,\n    updated,\n    activated,\n    deactivated,\n    beforeDestroy,\n    beforeUnmount,\n    destroyed,\n    unmounted,\n    render,\n    renderTracked,\n    renderTriggered,\n    errorCaptured,\n    serverPrefetch,\n    // public API\n    expose,\n    inheritAttrs,\n    // assets\n    components,\n    directives,\n    filters\n  } = options;\n  const checkDuplicateProperties =  true ? createDuplicateChecker() : 0;\n  if (true) {\n    const [propsOptions] = instance.propsOptions;\n    if (propsOptions) {\n      for (const key in propsOptions) {\n        checkDuplicateProperties(\"Props\" /* PROPS */, key);\n      }\n    }\n  }\n  if (injectOptions) {\n    resolveInjections(injectOptions, ctx, checkDuplicateProperties);\n  }\n  if (methods) {\n    for (const key in methods) {\n      const methodHandler = methods[key];\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(methodHandler)) {\n        if (true) {\n          Object.defineProperty(ctx, key, {\n            value: methodHandler.bind(publicThis),\n            configurable: true,\n            enumerable: true,\n            writable: true\n          });\n        } else {}\n        if (true) {\n          checkDuplicateProperties(\"Methods\" /* METHODS */, key);\n        }\n      } else if (true) {\n        warn$1(`Method \"${key}\" has type \"${typeof methodHandler}\" in the component definition. Did you reference the function correctly?`);\n      }\n    }\n  }\n  if (dataOptions) {\n    if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(dataOptions)) {\n      warn$1(`The data option must be a function. Plain object usage is no longer supported.`);\n    }\n    const data = dataOptions.call(publicThis, publicThis);\n    if ( true && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isPromise)(data)) {\n      warn$1(`data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`);\n    }\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isObject)(data)) {\n       true && warn$1(`data() should return an object.`);\n    } else {\n      instance.data = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.reactive)(data);\n      if (true) {\n        for (const key in data) {\n          checkDuplicateProperties(\"Data\" /* DATA */, key);\n          if (!isReservedPrefix(key[0])) {\n            Object.defineProperty(ctx, key, {\n              configurable: true,\n              enumerable: true,\n              get: () => data[key],\n              set: _vue_shared__WEBPACK_IMPORTED_MODULE_2__.NOOP\n            });\n          }\n        }\n      }\n    }\n  }\n  shouldCacheAccess = true;\n  if (computedOptions) {\n    for (const key in computedOptions) {\n      const opt = computedOptions[key];\n      const get = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(opt) ? opt.bind(publicThis, publicThis) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(opt.get) ? opt.get.bind(publicThis, publicThis) : _vue_shared__WEBPACK_IMPORTED_MODULE_2__.NOOP;\n      if ( true && get === _vue_shared__WEBPACK_IMPORTED_MODULE_2__.NOOP) {\n        warn$1(`Computed property \"${key}\" has no getter.`);\n      }\n      const set = !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(opt) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(opt.set) ? opt.set.bind(publicThis) :  true ? () => {\n        warn$1(`Write operation failed: computed property \"${key}\" is readonly.`);\n      } : 0;\n      const c = computed({\n        get,\n        set\n      });\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => c.value,\n        set: v => c.value = v\n      });\n      if (true) {\n        checkDuplicateProperties(\"Computed\" /* COMPUTED */, key);\n      }\n    }\n  }\n  if (watchOptions) {\n    for (const key in watchOptions) {\n      createWatcher(watchOptions[key], ctx, publicThis, key);\n    }\n  }\n  if (provideOptions) {\n    const provides = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(provideOptions) ? provideOptions.call(publicThis) : provideOptions;\n    Reflect.ownKeys(provides).forEach(key => {\n      provide(key, provides[key]);\n    });\n  }\n  if (created) {\n    callHook(created, instance, \"c\");\n  }\n  function registerLifecycleHook(register, hook) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(hook)) {\n      hook.forEach(_hook => register(_hook.bind(publicThis)));\n    } else if (hook) {\n      register(hook.bind(publicThis));\n    }\n  }\n  registerLifecycleHook(onBeforeMount, beforeMount);\n  registerLifecycleHook(onMounted, mounted);\n  registerLifecycleHook(onBeforeUpdate, beforeUpdate);\n  registerLifecycleHook(onUpdated, updated);\n  registerLifecycleHook(onActivated, activated);\n  registerLifecycleHook(onDeactivated, deactivated);\n  registerLifecycleHook(onErrorCaptured, errorCaptured);\n  registerLifecycleHook(onRenderTracked, renderTracked);\n  registerLifecycleHook(onRenderTriggered, renderTriggered);\n  registerLifecycleHook(onBeforeUnmount, beforeUnmount);\n  registerLifecycleHook(onUnmounted, unmounted);\n  registerLifecycleHook(onServerPrefetch, serverPrefetch);\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(expose)) {\n    if (expose.length) {\n      const exposed = instance.exposed || (instance.exposed = {});\n      expose.forEach(key => {\n        Object.defineProperty(exposed, key, {\n          get: () => publicThis[key],\n          set: val => publicThis[key] = val\n        });\n      });\n    } else if (!instance.exposed) {\n      instance.exposed = {};\n    }\n  }\n  if (render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_2__.NOOP) {\n    instance.render = render;\n  }\n  if (inheritAttrs != null) {\n    instance.inheritAttrs = inheritAttrs;\n  }\n  if (components) instance.components = components;\n  if (directives) instance.directives = directives;\n}\nfunction resolveInjections(injectOptions, ctx, checkDuplicateProperties = _vue_shared__WEBPACK_IMPORTED_MODULE_2__.NOOP) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(injectOptions)) {\n    injectOptions = normalizeInject(injectOptions);\n  }\n  for (const key in injectOptions) {\n    const opt = injectOptions[key];\n    let injected;\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isObject)(opt)) {\n      if (\"default\" in opt) {\n        injected = inject(opt.from || key, opt.default, true);\n      } else {\n        injected = inject(opt.from || key);\n      }\n    } else {\n      injected = inject(opt);\n    }\n    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.isRef)(injected)) {\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => injected.value,\n        set: v => injected.value = v\n      });\n    } else {\n      ctx[key] = injected;\n    }\n    if (true) {\n      checkDuplicateProperties(\"Inject\" /* INJECT */, key);\n    }\n  }\n}\nfunction callHook(hook, instance, type) {\n  callWithAsyncErrorHandling((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(hook) ? hook.map(h => h.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);\n}\nfunction createWatcher(raw, ctx, publicThis, key) {\n  const getter = key.includes(\".\") ? createPathGetter(publicThis, key) : () => publicThis[key];\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isString)(raw)) {\n    const handler = ctx[raw];\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(handler)) {\n      watch(getter, handler);\n    } else if (true) {\n      warn$1(`Invalid watch handler specified by key \"${raw}\"`, handler);\n    }\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(raw)) {\n    watch(getter, raw.bind(publicThis));\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isObject)(raw)) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(raw)) {\n      raw.forEach(r => createWatcher(r, ctx, publicThis, key));\n    } else {\n      const handler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(handler)) {\n        watch(getter, handler, raw);\n      } else if (true) {\n        warn$1(`Invalid watch handler specified by key \"${raw.handler}\"`, handler);\n      }\n    }\n  } else if (true) {\n    warn$1(`Invalid watch option: \"${key}\"`, raw);\n  }\n}\nfunction resolveMergedOptions(instance) {\n  const base = instance.type;\n  const {\n    mixins,\n    extends: extendsOptions\n  } = base;\n  const {\n    mixins: globalMixins,\n    optionsCache: cache,\n    config: {\n      optionMergeStrategies\n    }\n  } = instance.appContext;\n  const cached = cache.get(base);\n  let resolved;\n  if (cached) {\n    resolved = cached;\n  } else if (!globalMixins.length && !mixins && !extendsOptions) {\n    {\n      resolved = base;\n    }\n  } else {\n    resolved = {};\n    if (globalMixins.length) {\n      globalMixins.forEach(m => mergeOptions(resolved, m, optionMergeStrategies, true));\n    }\n    mergeOptions(resolved, base, optionMergeStrategies);\n  }\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isObject)(base)) {\n    cache.set(base, resolved);\n  }\n  return resolved;\n}\nfunction mergeOptions(to, from, strats, asMixin = false) {\n  const {\n    mixins,\n    extends: extendsOptions\n  } = from;\n  if (extendsOptions) {\n    mergeOptions(to, extendsOptions, strats, true);\n  }\n  if (mixins) {\n    mixins.forEach(m => mergeOptions(to, m, strats, true));\n  }\n  for (const key in from) {\n    if (asMixin && key === \"expose\") {\n       true && warn$1(`\"expose\" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`);\n    } else {\n      const strat = internalOptionMergeStrats[key] || strats && strats[key];\n      to[key] = strat ? strat(to[key], from[key]) : from[key];\n    }\n  }\n  return to;\n}\nconst internalOptionMergeStrats = {\n  data: mergeDataFn,\n  props: mergeEmitsOrPropsOptions,\n  emits: mergeEmitsOrPropsOptions,\n  // objects\n  methods: mergeObjectOptions,\n  computed: mergeObjectOptions,\n  // lifecycle\n  beforeCreate: mergeAsArray,\n  created: mergeAsArray,\n  beforeMount: mergeAsArray,\n  mounted: mergeAsArray,\n  beforeUpdate: mergeAsArray,\n  updated: mergeAsArray,\n  beforeDestroy: mergeAsArray,\n  beforeUnmount: mergeAsArray,\n  destroyed: mergeAsArray,\n  unmounted: mergeAsArray,\n  activated: mergeAsArray,\n  deactivated: mergeAsArray,\n  errorCaptured: mergeAsArray,\n  serverPrefetch: mergeAsArray,\n  // assets\n  components: mergeObjectOptions,\n  directives: mergeObjectOptions,\n  // watch\n  watch: mergeWatchOptions,\n  // provide / inject\n  provide: mergeDataFn,\n  inject: mergeInject\n};\nfunction mergeDataFn(to, from) {\n  if (!from) {\n    return to;\n  }\n  if (!to) {\n    return from;\n  }\n  return function mergedDataFn() {\n    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(to) ? to.call(this, this) : to, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(from) ? from.call(this, this) : from);\n  };\n}\nfunction mergeInject(to, from) {\n  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));\n}\nfunction normalizeInject(raw) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(raw)) {\n    const res = {};\n    for (let i = 0; i < raw.length; i++) {\n      res[raw[i]] = raw[i];\n    }\n    return res;\n  }\n  return raw;\n}\nfunction mergeAsArray(to, from) {\n  return to ? [...new Set([].concat(to, from))] : from;\n}\nfunction mergeObjectOptions(to, from) {\n  return to ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)( /* @__PURE__ */Object.create(null), to, from) : from;\n}\nfunction mergeEmitsOrPropsOptions(to, from) {\n  if (to) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(to) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(from)) {\n      return [... /* @__PURE__ */new Set([...to, ...from])];\n    }\n    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)( /* @__PURE__ */Object.create(null), normalizePropsOrEmits(to), normalizePropsOrEmits(from != null ? from : {}));\n  } else {\n    return from;\n  }\n}\nfunction mergeWatchOptions(to, from) {\n  if (!to) return from;\n  if (!from) return to;\n  const merged = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)( /* @__PURE__ */Object.create(null), to);\n  for (const key in from) {\n    merged[key] = mergeAsArray(to[key], from[key]);\n  }\n  return merged;\n}\nfunction createAppContext() {\n  return {\n    app: null,\n    config: {\n      isNativeTag: _vue_shared__WEBPACK_IMPORTED_MODULE_2__.NO,\n      performance: false,\n      globalProperties: {},\n      optionMergeStrategies: {},\n      errorHandler: void 0,\n      warnHandler: void 0,\n      compilerOptions: {}\n    },\n    mixins: [],\n    components: {},\n    directives: {},\n    provides: /* @__PURE__ */Object.create(null),\n    optionsCache: /* @__PURE__ */new WeakMap(),\n    propsCache: /* @__PURE__ */new WeakMap(),\n    emitsCache: /* @__PURE__ */new WeakMap()\n  };\n}\nlet uid$1 = 0;\nfunction createAppAPI(render, hydrate) {\n  return function createApp(rootComponent, rootProps = null) {\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(rootComponent)) {\n      rootComponent = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)({}, rootComponent);\n    }\n    if (rootProps != null && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isObject)(rootProps)) {\n       true && warn$1(`root props passed to app.mount() must be an object.`);\n      rootProps = null;\n    }\n    const context = createAppContext();\n    const installedPlugins = /* @__PURE__ */new WeakSet();\n    let isMounted = false;\n    const app = context.app = {\n      _uid: uid$1++,\n      _component: rootComponent,\n      _props: rootProps,\n      _container: null,\n      _context: context,\n      _instance: null,\n      version,\n      get config() {\n        return context.config;\n      },\n      set config(v) {\n        if (true) {\n          warn$1(`app.config cannot be replaced. Modify individual options instead.`);\n        }\n      },\n      use(plugin, ...options) {\n        if (installedPlugins.has(plugin)) {\n           true && warn$1(`Plugin has already been applied to target app.`);\n        } else if (plugin && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(plugin.install)) {\n          installedPlugins.add(plugin);\n          plugin.install(app, ...options);\n        } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(plugin)) {\n          installedPlugins.add(plugin);\n          plugin(app, ...options);\n        } else if (true) {\n          warn$1(`A plugin must either be a function or an object with an \"install\" function.`);\n        }\n        return app;\n      },\n      mixin(mixin) {\n        if (true) {\n          if (!context.mixins.includes(mixin)) {\n            context.mixins.push(mixin);\n          } else if (true) {\n            warn$1(\"Mixin has already been applied to target app\" + (mixin.name ? `: ${mixin.name}` : \"\"));\n          }\n        } else {}\n        return app;\n      },\n      component(name, component) {\n        if (true) {\n          validateComponentName(name, context.config);\n        }\n        if (!component) {\n          return context.components[name];\n        }\n        if ( true && context.components[name]) {\n          warn$1(`Component \"${name}\" has already been registered in target app.`);\n        }\n        context.components[name] = component;\n        return app;\n      },\n      directive(name, directive) {\n        if (true) {\n          validateDirectiveName(name);\n        }\n        if (!directive) {\n          return context.directives[name];\n        }\n        if ( true && context.directives[name]) {\n          warn$1(`Directive \"${name}\" has already been registered in target app.`);\n        }\n        context.directives[name] = directive;\n        return app;\n      },\n      mount(rootContainer, isHydrate, namespace) {\n        if (!isMounted) {\n          if ( true && rootContainer.__vue_app__) {\n            warn$1(`There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling \\`app.unmount()\\` first.`);\n          }\n          const vnode = createVNode(rootComponent, rootProps);\n          vnode.appContext = context;\n          if (namespace === true) {\n            namespace = \"svg\";\n          } else if (namespace === false) {\n            namespace = void 0;\n          }\n          if (true) {\n            context.reload = () => {\n              render(cloneVNode(vnode), rootContainer, namespace);\n            };\n          }\n          if (isHydrate && hydrate) {\n            hydrate(vnode, rootContainer);\n          } else {\n            render(vnode, rootContainer, namespace);\n          }\n          isMounted = true;\n          app._container = rootContainer;\n          rootContainer.__vue_app__ = app;\n          if (true) {\n            app._instance = vnode.component;\n            devtoolsInitApp(app, version);\n          }\n          return getExposeProxy(vnode.component) || vnode.component.proxy;\n        } else if (true) {\n          warn$1(`App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \\`const createMyApp = () => createApp(App)\\``);\n        }\n      },\n      unmount() {\n        if (isMounted) {\n          render(null, app._container);\n          if (true) {\n            app._instance = null;\n            devtoolsUnmountApp(app);\n          }\n          delete app._container.__vue_app__;\n        } else if (true) {\n          warn$1(`Cannot unmount an app that is not mounted.`);\n        }\n      },\n      provide(key, value) {\n        if ( true && key in context.provides) {\n          warn$1(`App already provides property with key \"${String(key)}\". It will be overwritten with the new value.`);\n        }\n        context.provides[key] = value;\n        return app;\n      },\n      runWithContext(fn) {\n        currentApp = app;\n        try {\n          return fn();\n        } finally {\n          currentApp = null;\n        }\n      }\n    };\n    return app;\n  };\n}\nlet currentApp = null;\nfunction provide(key, value) {\n  if (!currentInstance) {\n    if (true) {\n      warn$1(`provide() can only be used inside setup().`);\n    }\n  } else {\n    let provides = currentInstance.provides;\n    const parentProvides = currentInstance.parent && currentInstance.parent.provides;\n    if (parentProvides === provides) {\n      provides = currentInstance.provides = Object.create(parentProvides);\n    }\n    provides[key] = value;\n  }\n}\nfunction inject(key, defaultValue, treatDefaultAsFactory = false) {\n  const instance = currentInstance || currentRenderingInstance;\n  if (instance || currentApp) {\n    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;\n    if (provides && key in provides) {\n      return provides[key];\n    } else if (arguments.length > 1) {\n      return treatDefaultAsFactory && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;\n    } else if (true) {\n      warn$1(`injection \"${String(key)}\" not found.`);\n    }\n  } else if (true) {\n    warn$1(`inject() can only be used inside setup() or functional components.`);\n  }\n}\nfunction hasInjectionContext() {\n  return !!(currentInstance || currentRenderingInstance || currentApp);\n}\nfunction initProps(instance, rawProps, isStateful, isSSR = false) {\n  const props = {};\n  const attrs = {};\n  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.def)(attrs, InternalObjectKey, 1);\n  instance.propsDefaults = /* @__PURE__ */Object.create(null);\n  setFullProps(instance, rawProps, props, attrs);\n  for (const key in instance.propsOptions[0]) {\n    if (!(key in props)) {\n      props[key] = void 0;\n    }\n  }\n  if (true) {\n    validateProps(rawProps || {}, props, instance);\n  }\n  if (isStateful) {\n    instance.props = isSSR ? props : (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.shallowReactive)(props);\n  } else {\n    if (!instance.type.props) {\n      instance.props = attrs;\n    } else {\n      instance.props = props;\n    }\n  }\n  instance.attrs = attrs;\n}\nfunction isInHmrContext(instance) {\n  while (instance) {\n    if (instance.type.__hmrId) return true;\n    instance = instance.parent;\n  }\n}\nfunction updateProps(instance, rawProps, rawPrevProps, optimized) {\n  const {\n    props,\n    attrs,\n    vnode: {\n      patchFlag\n    }\n  } = instance;\n  const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.toRaw)(props);\n  const [options] = instance.propsOptions;\n  let hasAttrsChanged = false;\n  if (\n  // always force full diff in dev\n  // - #1942 if hmr is enabled with sfc component\n  // - vite#872 non-sfc component used by sfc component\n  !( true && isInHmrContext(instance)) && (optimized || patchFlag > 0) && !(patchFlag & 16)) {\n    if (patchFlag & 8) {\n      const propsToUpdate = instance.vnode.dynamicProps;\n      for (let i = 0; i < propsToUpdate.length; i++) {\n        let key = propsToUpdate[i];\n        if (isEmitListener(instance.emitsOptions, key)) {\n          continue;\n        }\n        const value = rawProps[key];\n        if (options) {\n          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(attrs, key)) {\n            if (value !== attrs[key]) {\n              attrs[key] = value;\n              hasAttrsChanged = true;\n            }\n          } else {\n            const camelizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.camelize)(key);\n            props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);\n          }\n        } else {\n          if (value !== attrs[key]) {\n            attrs[key] = value;\n            hasAttrsChanged = true;\n          }\n        }\n      }\n    }\n  } else {\n    if (setFullProps(instance, rawProps, props, attrs)) {\n      hasAttrsChanged = true;\n    }\n    let kebabKey;\n    for (const key in rawCurrentProps) {\n      if (!rawProps ||\n      // for camelCase\n      !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(rawProps, key) && (\n      // it's possible the original props was passed in as kebab-case\n      // and converted to camelCase (#955)\n      (kebabKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hyphenate)(key)) === key || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(rawProps, kebabKey))) {\n        if (options) {\n          if (rawPrevProps && (\n          // for camelCase\n          rawPrevProps[key] !== void 0 ||\n          // for kebab-case\n          rawPrevProps[kebabKey] !== void 0)) {\n            props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true);\n          }\n        } else {\n          delete props[key];\n        }\n      }\n    }\n    if (attrs !== rawCurrentProps) {\n      for (const key in attrs) {\n        if (!rawProps || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(rawProps, key) && true) {\n          delete attrs[key];\n          hasAttrsChanged = true;\n        }\n      }\n    }\n  }\n  if (hasAttrsChanged) {\n    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.trigger)(instance, \"set\", \"$attrs\");\n  }\n  if (true) {\n    validateProps(rawProps || {}, props, instance);\n  }\n}\nfunction setFullProps(instance, rawProps, props, attrs) {\n  const [options, needCastKeys] = instance.propsOptions;\n  let hasAttrsChanged = false;\n  let rawCastValues;\n  if (rawProps) {\n    for (let key in rawProps) {\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isReservedProp)(key)) {\n        continue;\n      }\n      const value = rawProps[key];\n      let camelKey;\n      if (options && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(options, camelKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.camelize)(key))) {\n        if (!needCastKeys || !needCastKeys.includes(camelKey)) {\n          props[camelKey] = value;\n        } else {\n          (rawCastValues || (rawCastValues = {}))[camelKey] = value;\n        }\n      } else if (!isEmitListener(instance.emitsOptions, key)) {\n        if (!(key in attrs) || value !== attrs[key]) {\n          attrs[key] = value;\n          hasAttrsChanged = true;\n        }\n      }\n    }\n  }\n  if (needCastKeys) {\n    const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.toRaw)(props);\n    const castValues = rawCastValues || _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ;\n    for (let i = 0; i < needCastKeys.length; i++) {\n      const key = needCastKeys[i];\n      props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(castValues, key));\n    }\n  }\n  return hasAttrsChanged;\n}\nfunction resolvePropValue(options, props, key, value, instance, isAbsent) {\n  const opt = options[key];\n  if (opt != null) {\n    const hasDefault = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(opt, \"default\");\n    if (hasDefault && value === void 0) {\n      const defaultValue = opt.default;\n      if (opt.type !== Function && !opt.skipFactory && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(defaultValue)) {\n        const {\n          propsDefaults\n        } = instance;\n        if (key in propsDefaults) {\n          value = propsDefaults[key];\n        } else {\n          setCurrentInstance(instance);\n          value = propsDefaults[key] = defaultValue.call(null, props);\n          unsetCurrentInstance();\n        }\n      } else {\n        value = defaultValue;\n      }\n    }\n    if (opt[0 /* shouldCast */]) {\n      if (isAbsent && !hasDefault) {\n        value = false;\n      } else if (opt[1 /* shouldCastTrue */] && (value === \"\" || value === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hyphenate)(key))) {\n        value = true;\n      }\n    }\n  }\n  return value;\n}\nfunction normalizePropsOptions(comp, appContext, asMixin = false) {\n  const cache = appContext.propsCache;\n  const cached = cache.get(comp);\n  if (cached) {\n    return cached;\n  }\n  const raw = comp.props;\n  const normalized = {};\n  const needCastKeys = [];\n  let hasExtends = false;\n  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(comp)) {\n    const extendProps = raw2 => {\n      hasExtends = true;\n      const [props, keys] = normalizePropsOptions(raw2, appContext, true);\n      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)(normalized, props);\n      if (keys) needCastKeys.push(...keys);\n    };\n    if (!asMixin && appContext.mixins.length) {\n      appContext.mixins.forEach(extendProps);\n    }\n    if (comp.extends) {\n      extendProps(comp.extends);\n    }\n    if (comp.mixins) {\n      comp.mixins.forEach(extendProps);\n    }\n  }\n  if (!raw && !hasExtends) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isObject)(comp)) {\n      cache.set(comp, _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_ARR);\n    }\n    return _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_ARR;\n  }\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(raw)) {\n    for (let i = 0; i < raw.length; i++) {\n      if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isString)(raw[i])) {\n        warn$1(`props must be strings when using array syntax.`, raw[i]);\n      }\n      const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.camelize)(raw[i]);\n      if (validatePropName(normalizedKey)) {\n        normalized[normalizedKey] = _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ;\n      }\n    }\n  } else if (raw) {\n    if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isObject)(raw)) {\n      warn$1(`invalid props options`, raw);\n    }\n    for (const key in raw) {\n      const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.camelize)(key);\n      if (validatePropName(normalizedKey)) {\n        const opt = raw[key];\n        const prop = normalized[normalizedKey] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(opt) ? {\n          type: opt\n        } : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)({}, opt);\n        if (prop) {\n          const booleanIndex = getTypeIndex(Boolean, prop.type);\n          const stringIndex = getTypeIndex(String, prop.type);\n          prop[0 /* shouldCast */] = booleanIndex > -1;\n          prop[1 /* shouldCastTrue */] = stringIndex < 0 || booleanIndex < stringIndex;\n          if (booleanIndex > -1 || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(prop, \"default\")) {\n            needCastKeys.push(normalizedKey);\n          }\n        }\n      }\n    }\n  }\n  const res = [normalized, needCastKeys];\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isObject)(comp)) {\n    cache.set(comp, res);\n  }\n  return res;\n}\nfunction validatePropName(key) {\n  if (key[0] !== \"$\") {\n    return true;\n  } else if (true) {\n    warn$1(`Invalid prop name: \"${key}\" is a reserved property.`);\n  }\n  return false;\n}\nfunction getType(ctor) {\n  const match = ctor && ctor.toString().match(/^\\s*(function|class) (\\w+)/);\n  return match ? match[2] : ctor === null ? \"null\" : \"\";\n}\nfunction isSameType(a, b) {\n  return getType(a) === getType(b);\n}\nfunction getTypeIndex(type, expectedTypes) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(expectedTypes)) {\n    return expectedTypes.findIndex(t => isSameType(t, type));\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(expectedTypes)) {\n    return isSameType(expectedTypes, type) ? 0 : -1;\n  }\n  return -1;\n}\nfunction validateProps(rawProps, props, instance) {\n  const resolvedValues = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.toRaw)(props);\n  const options = instance.propsOptions[0];\n  for (const key in options) {\n    let opt = options[key];\n    if (opt == null) continue;\n    validateProp(key, resolvedValues[key], opt,  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.shallowReadonly)(resolvedValues) : 0, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(rawProps, key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(rawProps, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hyphenate)(key)));\n  }\n}\nfunction validateProp(name, value, prop, props, isAbsent) {\n  const {\n    type,\n    required,\n    validator,\n    skipCheck\n  } = prop;\n  if (required && isAbsent) {\n    warn$1('Missing required prop: \"' + name + '\"');\n    return;\n  }\n  if (value == null && !required) {\n    return;\n  }\n  if (type != null && type !== true && !skipCheck) {\n    let isValid = false;\n    const types = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(type) ? type : [type];\n    const expectedTypes = [];\n    for (let i = 0; i < types.length && !isValid; i++) {\n      const {\n        valid,\n        expectedType\n      } = assertType(value, types[i]);\n      expectedTypes.push(expectedType || \"\");\n      isValid = valid;\n    }\n    if (!isValid) {\n      warn$1(getInvalidTypeMessage(name, value, expectedTypes));\n      return;\n    }\n  }\n  if (validator && !validator(value, props)) {\n    warn$1('Invalid prop: custom validator check failed for prop \"' + name + '\".');\n  }\n}\nconst isSimpleType = /* @__PURE__ */(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.makeMap)(\"String,Number,Boolean,Function,Symbol,BigInt\");\nfunction assertType(value, type) {\n  let valid;\n  const expectedType = getType(type);\n  if (isSimpleType(expectedType)) {\n    const t = typeof value;\n    valid = t === expectedType.toLowerCase();\n    if (!valid && t === \"object\") {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === \"Object\") {\n    valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isObject)(value);\n  } else if (expectedType === \"Array\") {\n    valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(value);\n  } else if (expectedType === \"null\") {\n    valid = value === null;\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid,\n    expectedType\n  };\n}\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\n  if (expectedTypes.length === 0) {\n    return `Prop type [] for prop \"${name}\" won't match anything. Did you mean to use type Array instead?`;\n  }\n  let message = `Invalid prop: type check failed for prop \"${name}\". Expected ${expectedTypes.map(_vue_shared__WEBPACK_IMPORTED_MODULE_2__.capitalize).join(\" | \")}`;\n  const expectedType = expectedTypes[0];\n  const receivedType = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.toRawType)(value);\n  const expectedValue = styleValue(value, expectedType);\n  const receivedValue = styleValue(value, receivedType);\n  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {\n    message += ` with value ${expectedValue}`;\n  }\n  message += `, got ${receivedType} `;\n  if (isExplicable(receivedType)) {\n    message += `with value ${receivedValue}.`;\n  }\n  return message;\n}\nfunction styleValue(value, type) {\n  if (type === \"String\") {\n    return `\"${value}\"`;\n  } else if (type === \"Number\") {\n    return `${Number(value)}`;\n  } else {\n    return `${value}`;\n  }\n}\nfunction isExplicable(type) {\n  const explicitTypes = [\"string\", \"number\", \"boolean\"];\n  return explicitTypes.some(elem => type.toLowerCase() === elem);\n}\nfunction isBoolean(...args) {\n  return args.some(elem => elem.toLowerCase() === \"boolean\");\n}\nconst isInternalKey = key => key[0] === \"_\" || key === \"$stable\";\nconst normalizeSlotValue = value => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];\nconst normalizeSlot = (key, rawSlot, ctx) => {\n  if (rawSlot._n) {\n    return rawSlot;\n  }\n  const normalized = withCtx((...args) => {\n    if ( true && currentInstance) {\n      warn$1(`Slot \"${key}\" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`);\n    }\n    return normalizeSlotValue(rawSlot(...args));\n  }, ctx);\n  normalized._c = false;\n  return normalized;\n};\nconst normalizeObjectSlots = (rawSlots, slots, instance) => {\n  const ctx = rawSlots._ctx;\n  for (const key in rawSlots) {\n    if (isInternalKey(key)) continue;\n    const value = rawSlots[key];\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(value)) {\n      slots[key] = normalizeSlot(key, value, ctx);\n    } else if (value != null) {\n      if (true) {\n        warn$1(`Non-function value encountered for slot \"${key}\". Prefer function slots for better performance.`);\n      }\n      const normalized = normalizeSlotValue(value);\n      slots[key] = () => normalized;\n    }\n  }\n};\nconst normalizeVNodeSlots = (instance, children) => {\n  if ( true && !isKeepAlive(instance.vnode) && true) {\n    warn$1(`Non-function value encountered for default slot. Prefer function slots for better performance.`);\n  }\n  const normalized = normalizeSlotValue(children);\n  instance.slots.default = () => normalized;\n};\nconst initSlots = (instance, children) => {\n  if (instance.vnode.shapeFlag & 32) {\n    const type = children._;\n    if (type) {\n      instance.slots = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.toRaw)(children);\n      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.def)(children, \"_\", type);\n    } else {\n      normalizeObjectSlots(children, instance.slots = {});\n    }\n  } else {\n    instance.slots = {};\n    if (children) {\n      normalizeVNodeSlots(instance, children);\n    }\n  }\n  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.def)(instance.slots, InternalObjectKey, 1);\n};\nconst updateSlots = (instance, children, optimized) => {\n  const {\n    vnode,\n    slots\n  } = instance;\n  let needDeletionCheck = true;\n  let deletionComparisonTarget = _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ;\n  if (vnode.shapeFlag & 32) {\n    const type = children._;\n    if (type) {\n      if ( true && isHmrUpdating) {\n        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)(slots, children);\n        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.trigger)(instance, \"set\", \"$slots\");\n      } else if (optimized && type === 1) {\n        needDeletionCheck = false;\n      } else {\n        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)(slots, children);\n        if (!optimized && type === 1) {\n          delete slots._;\n        }\n      }\n    } else {\n      needDeletionCheck = !children.$stable;\n      normalizeObjectSlots(children, slots);\n    }\n    deletionComparisonTarget = children;\n  } else if (children) {\n    normalizeVNodeSlots(instance, children);\n    deletionComparisonTarget = {\n      default: 1\n    };\n  }\n  if (needDeletionCheck) {\n    for (const key in slots) {\n      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {\n        delete slots[key];\n      }\n    }\n  }\n};\nfunction setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(rawRef)) {\n    rawRef.forEach((r, i) => setRef(r, oldRawRef && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));\n    return;\n  }\n  if (isAsyncWrapper(vnode) && !isUnmount) {\n    return;\n  }\n  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;\n  const value = isUnmount ? null : refValue;\n  const {\n    i: owner,\n    r: ref\n  } = rawRef;\n  if ( true && !owner) {\n    warn$1(`Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`);\n    return;\n  }\n  const oldRef = oldRawRef && oldRawRef.r;\n  const refs = owner.refs === _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ ? owner.refs = {} : owner.refs;\n  const setupState = owner.setupState;\n  if (oldRef != null && oldRef !== ref) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isString)(oldRef)) {\n      refs[oldRef] = null;\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(setupState, oldRef)) {\n        setupState[oldRef] = null;\n      }\n    } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.isRef)(oldRef)) {\n      oldRef.value = null;\n    }\n  }\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(ref)) {\n    callWithErrorHandling(ref, owner, 12, [value, refs]);\n  } else {\n    const _isString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isString)(ref);\n    const _isRef = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.isRef)(ref);\n    if (_isString || _isRef) {\n      const doSet = () => {\n        if (rawRef.f) {\n          const existing = _isString ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(setupState, ref) ? setupState[ref] : refs[ref] : ref.value;\n          if (isUnmount) {\n            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(existing) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.remove)(existing, refValue);\n          } else {\n            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(existing)) {\n              if (_isString) {\n                refs[ref] = [refValue];\n                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(setupState, ref)) {\n                  setupState[ref] = refs[ref];\n                }\n              } else {\n                ref.value = [refValue];\n                if (rawRef.k) refs[rawRef.k] = ref.value;\n              }\n            } else if (!existing.includes(refValue)) {\n              existing.push(refValue);\n            }\n          }\n        } else if (_isString) {\n          refs[ref] = value;\n          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(setupState, ref)) {\n            setupState[ref] = value;\n          }\n        } else if (_isRef) {\n          ref.value = value;\n          if (rawRef.k) refs[rawRef.k] = value;\n        } else if (true) {\n          warn$1(\"Invalid template ref type:\", ref, `(${typeof ref})`);\n        }\n      };\n      if (value) {\n        doSet.id = -1;\n        queuePostRenderEffect(doSet, parentSuspense);\n      } else {\n        doSet();\n      }\n    } else if (true) {\n      warn$1(\"Invalid template ref type:\", ref, `(${typeof ref})`);\n    }\n  }\n}\nlet hasMismatch = false;\nconst isSVGContainer = container => container.namespaceURI.includes(\"svg\") && container.tagName !== \"foreignObject\";\nconst isMathMLContainer = container => container.namespaceURI.includes(\"MathML\");\nconst getContainerType = container => {\n  if (isSVGContainer(container)) return \"svg\";\n  if (isMathMLContainer(container)) return \"mathml\";\n  return void 0;\n};\nconst isComment = node => node.nodeType === 8 /* COMMENT */;\nfunction createHydrationFunctions(rendererInternals) {\n  const {\n    mt: mountComponent,\n    p: patch,\n    o: {\n      patchProp,\n      createText,\n      nextSibling,\n      parentNode,\n      remove,\n      insert,\n      createComment\n    }\n  } = rendererInternals;\n  const hydrate = (vnode, container) => {\n    if (!container.hasChildNodes()) {\n      ( true) && warn$1(`Attempting to hydrate existing markup but container is empty. Performing full mount instead.`);\n      patch(null, vnode, container);\n      flushPostFlushCbs();\n      container._vnode = vnode;\n      return;\n    }\n    hasMismatch = false;\n    hydrateNode(container.firstChild, vnode, null, null, null);\n    flushPostFlushCbs();\n    container._vnode = vnode;\n    if (hasMismatch && true) {\n      console.error(`Hydration completed but contains mismatches.`);\n    }\n  };\n  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {\n    const isFragmentStart = isComment(node) && node.data === \"[\";\n    const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);\n    const {\n      type,\n      ref,\n      shapeFlag,\n      patchFlag\n    } = vnode;\n    let domType = node.nodeType;\n    vnode.el = node;\n    if (true) {\n      if (!(\"__vnode\" in node)) {\n        Object.defineProperty(node, \"__vnode\", {\n          value: vnode,\n          enumerable: false\n        });\n      }\n      if (!(\"__vueParentComponent\" in node)) {\n        Object.defineProperty(node, \"__vueParentComponent\", {\n          value: parentComponent,\n          enumerable: false\n        });\n      }\n    }\n    if (patchFlag === -2) {\n      optimized = false;\n      vnode.dynamicChildren = null;\n    }\n    let nextNode = null;\n    switch (type) {\n      case Text:\n        if (domType !== 3 /* TEXT */) {\n          if (vnode.children === \"\") {\n            insert(vnode.el = createText(\"\"), parentNode(node), node);\n            nextNode = node;\n          } else {\n            nextNode = onMismatch();\n          }\n        } else {\n          if (node.data !== vnode.children) {\n            hasMismatch = true;\n            ( true) && warn$1(`Hydration text mismatch in`, node.parentNode, `\n  - rendered on server: ${JSON.stringify(node.data)}\n  - expected on client: ${JSON.stringify(vnode.children)}`);\n            node.data = vnode.children;\n          }\n          nextNode = nextSibling(node);\n        }\n        break;\n      case Comment:\n        if (isTemplateNode(node)) {\n          nextNode = nextSibling(node);\n          replaceNode(vnode.el = node.content.firstChild, node, parentComponent);\n        } else if (domType !== 8 /* COMMENT */ || isFragmentStart) {\n          nextNode = onMismatch();\n        } else {\n          nextNode = nextSibling(node);\n        }\n        break;\n      case Static:\n        if (isFragmentStart) {\n          node = nextSibling(node);\n          domType = node.nodeType;\n        }\n        if (domType === 1 /* ELEMENT */ || domType === 3 /* TEXT */) {\n          nextNode = node;\n          const needToAdoptContent = !vnode.children.length;\n          for (let i = 0; i < vnode.staticCount; i++) {\n            if (needToAdoptContent) vnode.children += nextNode.nodeType === 1 /* ELEMENT */ ? nextNode.outerHTML : nextNode.data;\n            if (i === vnode.staticCount - 1) {\n              vnode.anchor = nextNode;\n            }\n            nextNode = nextSibling(nextNode);\n          }\n          return isFragmentStart ? nextSibling(nextNode) : nextNode;\n        } else {\n          onMismatch();\n        }\n        break;\n      case Fragment:\n        if (!isFragmentStart) {\n          nextNode = onMismatch();\n        } else {\n          nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\n        }\n        break;\n      default:\n        if (shapeFlag & 1) {\n          if ((domType !== 1 /* ELEMENT */ || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode(node)) {\n            nextNode = onMismatch();\n          } else {\n            nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\n          }\n        } else if (shapeFlag & 6) {\n          vnode.slotScopeIds = slotScopeIds;\n          const container = parentNode(node);\n          if (isFragmentStart) {\n            nextNode = locateClosingAnchor(node);\n          } else if (isComment(node) && node.data === \"teleport start\") {\n            nextNode = locateClosingAnchor(node, node.data, \"teleport end\");\n          } else {\n            nextNode = nextSibling(node);\n          }\n          mountComponent(vnode, container, null, parentComponent, parentSuspense, getContainerType(container), optimized);\n          if (isAsyncWrapper(vnode)) {\n            let subTree;\n            if (isFragmentStart) {\n              subTree = createVNode(Fragment);\n              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;\n            } else {\n              subTree = node.nodeType === 3 ? createTextVNode(\"\") : createVNode(\"div\");\n            }\n            subTree.el = node;\n            vnode.component.subTree = subTree;\n          }\n        } else if (shapeFlag & 64) {\n          if (domType !== 8 /* COMMENT */) {\n            nextNode = onMismatch();\n          } else {\n            nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);\n          }\n        } else if (shapeFlag & 128) {\n          nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, getContainerType(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);\n        } else if (true) {\n          warn$1(\"Invalid HostVNode type:\", type, `(${typeof type})`);\n        }\n    }\n    if (ref != null) {\n      setRef(ref, null, parentSuspense, vnode);\n    }\n    return nextNode;\n  };\n  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n    optimized = optimized || !!vnode.dynamicChildren;\n    const {\n      type,\n      props,\n      patchFlag,\n      shapeFlag,\n      dirs,\n      transition\n    } = vnode;\n    const forcePatch = type === \"input\" || type === \"option\";\n    if (true) {\n      if (dirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, \"created\");\n      }\n      let needCallTransitionHooks = false;\n      if (isTemplateNode(el)) {\n        needCallTransitionHooks = needTransition(parentSuspense, transition) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;\n        const content = el.content.firstChild;\n        if (needCallTransitionHooks) {\n          transition.beforeEnter(content);\n        }\n        replaceNode(content, el, parentComponent);\n        vnode.el = el = content;\n      }\n      if (shapeFlag & 16 &&\n      // skip if element has innerHTML / textContent\n      !(props && (props.innerHTML || props.textContent))) {\n        let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);\n        let hasWarned = false;\n        while (next) {\n          hasMismatch = true;\n          if (( true) && !hasWarned) {\n            warn$1(`Hydration children mismatch on`, el, `\nServer rendered element contains more child nodes than client vdom.`);\n            hasWarned = true;\n          }\n          const cur = next;\n          next = next.nextSibling;\n          remove(cur);\n        }\n      } else if (shapeFlag & 8) {\n        if (el.textContent !== vnode.children) {\n          hasMismatch = true;\n          ( true) && warn$1(`Hydration text content mismatch on`, el, `\n  - rendered on server: ${el.textContent}\n  - expected on client: ${vnode.children}`);\n          el.textContent = vnode.children;\n        }\n      }\n      if (props) {\n        if (true) {\n          for (const key in props) {\n            if ( true && propHasMismatch(el, key, props[key])) {\n              hasMismatch = true;\n            }\n            if (forcePatch && (key.endsWith(\"value\") || key === \"indeterminate\") || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isOn)(key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isReservedProp)(key) ||\n            // force hydrate v-bind with .prop modifiers\n            key[0] === \".\") {\n              patchProp(el, key, null, props[key], void 0, void 0, parentComponent);\n            }\n          }\n        } else {}\n      }\n      let vnodeHooks;\n      if (vnodeHooks = props && props.onVnodeBeforeMount) {\n        invokeVNodeHook(vnodeHooks, parentComponent, vnode);\n      }\n      if (dirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, \"beforeMount\");\n      }\n      if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {\n        queueEffectWithSuspense(() => {\n          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);\n          needCallTransitionHooks && transition.enter(el);\n          dirs && invokeDirectiveHook(vnode, null, parentComponent, \"mounted\");\n        }, parentSuspense);\n      }\n    }\n    return el.nextSibling;\n  };\n  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n    optimized = optimized || !!parentVNode.dynamicChildren;\n    const children = parentVNode.children;\n    const l = children.length;\n    let hasWarned = false;\n    for (let i = 0; i < l; i++) {\n      const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);\n      if (node) {\n        node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\n      } else if (vnode.type === Text && !vnode.children) {\n        continue;\n      } else {\n        hasMismatch = true;\n        if (( true) && !hasWarned) {\n          warn$1(`Hydration children mismatch on`, container, `\nServer rendered element contains fewer child nodes than client vdom.`);\n          hasWarned = true;\n        }\n        patch(null, vnode, container, null, parentComponent, parentSuspense, getContainerType(container), slotScopeIds);\n      }\n    }\n    return node;\n  };\n  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n    const {\n      slotScopeIds: fragmentSlotScopeIds\n    } = vnode;\n    if (fragmentSlotScopeIds) {\n      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;\n    }\n    const container = parentNode(node);\n    const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);\n    if (next && isComment(next) && next.data === \"]\") {\n      return nextSibling(vnode.anchor = next);\n    } else {\n      hasMismatch = true;\n      insert(vnode.anchor = createComment(`]`), container, next);\n      return next;\n    }\n  };\n  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {\n    hasMismatch = true;\n    ( true) && warn$1(`Hydration node mismatch:\n- rendered on server:`, node, node.nodeType === 3 /* TEXT */ ? `(text)` : isComment(node) && node.data === \"[\" ? `(start of fragment)` : ``, `\n- expected on client:`, vnode.type);\n    vnode.el = null;\n    if (isFragment) {\n      const end = locateClosingAnchor(node);\n      while (true) {\n        const next2 = nextSibling(node);\n        if (next2 && next2 !== end) {\n          remove(next2);\n        } else {\n          break;\n        }\n      }\n    }\n    const next = nextSibling(node);\n    const container = parentNode(node);\n    remove(node);\n    patch(null, vnode, container, next, parentComponent, parentSuspense, getContainerType(container), slotScopeIds);\n    return next;\n  };\n  const locateClosingAnchor = (node, open = \"[\", close = \"]\") => {\n    let match = 0;\n    while (node) {\n      node = nextSibling(node);\n      if (node && isComment(node)) {\n        if (node.data === open) match++;\n        if (node.data === close) {\n          if (match === 0) {\n            return nextSibling(node);\n          } else {\n            match--;\n          }\n        }\n      }\n    }\n    return node;\n  };\n  const replaceNode = (newNode, oldNode, parentComponent) => {\n    const parentNode2 = oldNode.parentNode;\n    if (parentNode2) {\n      parentNode2.replaceChild(newNode, oldNode);\n    }\n    let parent = parentComponent;\n    while (parent) {\n      if (parent.vnode.el === oldNode) {\n        parent.vnode.el = parent.subTree.el = newNode;\n      }\n      parent = parent.parent;\n    }\n  };\n  const isTemplateNode = node => {\n    return node.nodeType === 1 /* ELEMENT */ && node.tagName.toLowerCase() === \"template\";\n  };\n  return [hydrate, hydrateNode];\n}\nfunction propHasMismatch(el, key, clientValue) {\n  let mismatchType;\n  let mismatchKey;\n  let actual;\n  let expected;\n  if (key === \"class\") {\n    actual = toClassSet(el.getAttribute(\"class\") || \"\");\n    expected = toClassSet((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.normalizeClass)(clientValue));\n    if (!isSetEqual(actual, expected)) {\n      mismatchType = mismatchKey = `class`;\n    }\n  } else if (key === \"style\") {\n    actual = el.getAttribute(\"style\");\n    expected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isString)(clientValue) ? clientValue : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.stringifyStyle)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.normalizeStyle)(clientValue));\n    if (actual !== expected) {\n      mismatchType = mismatchKey = \"style\";\n    }\n  } else if (el instanceof SVGElement && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isKnownSvgAttr)(key) || el instanceof HTMLElement && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isBooleanAttr)(key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isKnownHtmlAttr)(key))) {\n    actual = el.hasAttribute(key) && el.getAttribute(key);\n    expected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isBooleanAttr)(key) ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.includeBooleanAttr)(clientValue) ? \"\" : false : clientValue == null ? false : String(clientValue);\n    if (actual !== expected) {\n      mismatchType = `attribute`;\n      mismatchKey = key;\n    }\n  }\n  if (mismatchType) {\n    const format = v => v === false ? `(not rendered)` : `${mismatchKey}=\"${v}\"`;\n    warn$1(`Hydration ${mismatchType} mismatch on`, el, `\n  - rendered on server: ${format(actual)}\n  - expected on client: ${format(expected)}\n  Note: this mismatch is check-only. The DOM will not be rectified in production due to performance overhead.\n  You should fix the source of the mismatch.`);\n    return true;\n  }\n  return false;\n}\nfunction toClassSet(str) {\n  return new Set(str.trim().split(/\\s+/));\n}\nfunction isSetEqual(a, b) {\n  if (a.size !== b.size) {\n    return false;\n  }\n  for (const s of a) {\n    if (!b.has(s)) {\n      return false;\n    }\n  }\n  return true;\n}\nlet supported;\nlet perf;\nfunction startMeasure(instance, type) {\n  if (instance.appContext.config.performance && isSupported()) {\n    perf.mark(`vue-${type}-${instance.uid}`);\n  }\n  if (true) {\n    devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());\n  }\n}\nfunction endMeasure(instance, type) {\n  if (instance.appContext.config.performance && isSupported()) {\n    const startTag = `vue-${type}-${instance.uid}`;\n    const endTag = startTag + `:end`;\n    perf.mark(endTag);\n    perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);\n    perf.clearMarks(startTag);\n    perf.clearMarks(endTag);\n  }\n  if (true) {\n    devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());\n  }\n}\nfunction isSupported() {\n  if (supported !== void 0) {\n    return supported;\n  }\n  if (typeof window !== \"undefined\" && window.performance) {\n    supported = true;\n    perf = window.performance;\n  } else {\n    supported = false;\n  }\n  return supported;\n}\nfunction initFeatureFlags() {\n  const needWarn = [];\n  if (false) {}\n  if (false) {}\n  if (typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ !== \"boolean\") {\n     true && needWarn.push(`__VUE_PROD_HYDRATION_MISMATCH_DETAILS__`);\n    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.getGlobalThis)().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = false;\n  }\n  if ( true && needWarn.length) {\n    const multi = needWarn.length > 1;\n    console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(\", \")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.\n\nFor more details, see https://link.vuejs.org/feature-flags.`);\n  }\n}\nconst queuePostRenderEffect = queueEffectWithSuspense;\nfunction createRenderer(options) {\n  return baseCreateRenderer(options);\n}\nfunction createHydrationRenderer(options) {\n  return baseCreateRenderer(options, createHydrationFunctions);\n}\nfunction baseCreateRenderer(options, createHydrationFns) {\n  {\n    initFeatureFlags();\n  }\n  const target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.getGlobalThis)();\n  target.__VUE__ = true;\n  if (true) {\n    setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);\n  }\n  const {\n    insert: hostInsert,\n    remove: hostRemove,\n    patchProp: hostPatchProp,\n    createElement: hostCreateElement,\n    createText: hostCreateText,\n    createComment: hostCreateComment,\n    setText: hostSetText,\n    setElementText: hostSetElementText,\n    parentNode: hostParentNode,\n    nextSibling: hostNextSibling,\n    setScopeId: hostSetScopeId = _vue_shared__WEBPACK_IMPORTED_MODULE_2__.NOOP,\n    insertStaticContent: hostInsertStaticContent\n  } = options;\n  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized =  true && isHmrUpdating ? false : !!n2.dynamicChildren) => {\n    if (n1 === n2) {\n      return;\n    }\n    if (n1 && !isSameVNodeType(n1, n2)) {\n      anchor = getNextHostNode(n1);\n      unmount(n1, parentComponent, parentSuspense, true);\n      n1 = null;\n    }\n    if (n2.patchFlag === -2) {\n      optimized = false;\n      n2.dynamicChildren = null;\n    }\n    const {\n      type,\n      ref,\n      shapeFlag\n    } = n2;\n    switch (type) {\n      case Text:\n        processText(n1, n2, container, anchor);\n        break;\n      case Comment:\n        processCommentNode(n1, n2, container, anchor);\n        break;\n      case Static:\n        if (n1 == null) {\n          mountStaticNode(n2, container, anchor, namespace);\n        } else if (true) {\n          patchStaticNode(n1, n2, container, namespace);\n        }\n        break;\n      case Fragment:\n        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);\n        break;\n      default:\n        if (shapeFlag & 1) {\n          processElement(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);\n        } else if (shapeFlag & 6) {\n          processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);\n        } else if (shapeFlag & 64) {\n          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals);\n        } else if (shapeFlag & 128) {\n          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals);\n        } else if (true) {\n          warn$1(\"Invalid VNode type:\", type, `(${typeof type})`);\n        }\n    }\n    if (ref != null && parentComponent) {\n      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);\n    }\n  };\n  const processText = (n1, n2, container, anchor) => {\n    if (n1 == null) {\n      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);\n    } else {\n      const el = n2.el = n1.el;\n      if (n2.children !== n1.children) {\n        hostSetText(el, n2.children);\n      }\n    }\n  };\n  const processCommentNode = (n1, n2, container, anchor) => {\n    if (n1 == null) {\n      hostInsert(n2.el = hostCreateComment(n2.children || \"\"), container, anchor);\n    } else {\n      n2.el = n1.el;\n    }\n  };\n  const mountStaticNode = (n2, container, anchor, namespace) => {\n    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, namespace, n2.el, n2.anchor);\n  };\n  const patchStaticNode = (n1, n2, container, namespace) => {\n    if (n2.children !== n1.children) {\n      const anchor = hostNextSibling(n1.anchor);\n      removeStaticNode(n1);\n      [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, namespace);\n    } else {\n      n2.el = n1.el;\n      n2.anchor = n1.anchor;\n    }\n  };\n  const moveStaticNode = ({\n    el,\n    anchor\n  }, container, nextSibling) => {\n    let next;\n    while (el && el !== anchor) {\n      next = hostNextSibling(el);\n      hostInsert(el, container, nextSibling);\n      el = next;\n    }\n    hostInsert(anchor, container, nextSibling);\n  };\n  const removeStaticNode = ({\n    el,\n    anchor\n  }) => {\n    let next;\n    while (el && el !== anchor) {\n      next = hostNextSibling(el);\n      hostRemove(el);\n      el = next;\n    }\n    hostRemove(anchor);\n  };\n  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    if (n2.type === \"svg\") {\n      namespace = \"svg\";\n    } else if (n2.type === \"math\") {\n      namespace = \"mathml\";\n    }\n    if (n1 == null) {\n      mountElement(n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);\n    } else {\n      patchElement(n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);\n    }\n  };\n  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    let el;\n    let vnodeHook;\n    const {\n      props,\n      shapeFlag,\n      transition,\n      dirs\n    } = vnode;\n    el = vnode.el = hostCreateElement(vnode.type, namespace, props && props.is, props);\n    if (shapeFlag & 8) {\n      hostSetElementText(el, vnode.children);\n    } else if (shapeFlag & 16) {\n      mountChildren(vnode.children, el, null, parentComponent, parentSuspense, resolveChildrenNamespace(vnode, namespace), slotScopeIds, optimized);\n    }\n    if (dirs) {\n      invokeDirectiveHook(vnode, null, parentComponent, \"created\");\n    }\n    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);\n    if (props) {\n      for (const key in props) {\n        if (key !== \"value\" && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isReservedProp)(key)) {\n          hostPatchProp(el, key, null, props[key], namespace, vnode.children, parentComponent, parentSuspense, unmountChildren);\n        }\n      }\n      if (\"value\" in props) {\n        hostPatchProp(el, \"value\", null, props.value, namespace);\n      }\n      if (vnodeHook = props.onVnodeBeforeMount) {\n        invokeVNodeHook(vnodeHook, parentComponent, vnode);\n      }\n    }\n    if (true) {\n      Object.defineProperty(el, \"__vnode\", {\n        value: vnode,\n        enumerable: false\n      });\n      Object.defineProperty(el, \"__vueParentComponent\", {\n        value: parentComponent,\n        enumerable: false\n      });\n    }\n    if (dirs) {\n      invokeDirectiveHook(vnode, null, parentComponent, \"beforeMount\");\n    }\n    const needCallTransitionHooks = needTransition(parentSuspense, transition);\n    if (needCallTransitionHooks) {\n      transition.beforeEnter(el);\n    }\n    hostInsert(el, container, anchor);\n    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\n        needCallTransitionHooks && transition.enter(el);\n        dirs && invokeDirectiveHook(vnode, null, parentComponent, \"mounted\");\n      }, parentSuspense);\n    }\n  };\n  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {\n    if (scopeId) {\n      hostSetScopeId(el, scopeId);\n    }\n    if (slotScopeIds) {\n      for (let i = 0; i < slotScopeIds.length; i++) {\n        hostSetScopeId(el, slotScopeIds[i]);\n      }\n    }\n    if (parentComponent) {\n      let subTree = parentComponent.subTree;\n      if ( true && subTree.patchFlag > 0 && subTree.patchFlag & 2048) {\n        subTree = filterSingleRoot(subTree.children) || subTree;\n      }\n      if (vnode === subTree) {\n        const parentVNode = parentComponent.vnode;\n        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);\n      }\n    }\n  };\n  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {\n    for (let i = start; i < children.length; i++) {\n      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);\n      patch(null, child, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);\n    }\n  };\n  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    const el = n2.el = n1.el;\n    let {\n      patchFlag,\n      dynamicChildren,\n      dirs\n    } = n2;\n    patchFlag |= n1.patchFlag & 16;\n    const oldProps = n1.props || _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ;\n    const newProps = n2.props || _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ;\n    let vnodeHook;\n    parentComponent && toggleRecurse(parentComponent, false);\n    if (vnodeHook = newProps.onVnodeBeforeUpdate) {\n      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\n    }\n    if (dirs) {\n      invokeDirectiveHook(n2, n1, parentComponent, \"beforeUpdate\");\n    }\n    parentComponent && toggleRecurse(parentComponent, true);\n    if ( true && isHmrUpdating) {\n      patchFlag = 0;\n      optimized = false;\n      dynamicChildren = null;\n    }\n    if (dynamicChildren) {\n      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, resolveChildrenNamespace(n2, namespace), slotScopeIds);\n      if (true) {\n        traverseStaticChildren(n1, n2);\n      }\n    } else if (!optimized) {\n      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, resolveChildrenNamespace(n2, namespace), slotScopeIds, false);\n    }\n    if (patchFlag > 0) {\n      if (patchFlag & 16) {\n        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, namespace);\n      } else {\n        if (patchFlag & 2) {\n          if (oldProps.class !== newProps.class) {\n            hostPatchProp(el, \"class\", null, newProps.class, namespace);\n          }\n        }\n        if (patchFlag & 4) {\n          hostPatchProp(el, \"style\", oldProps.style, newProps.style, namespace);\n        }\n        if (patchFlag & 8) {\n          const propsToUpdate = n2.dynamicProps;\n          for (let i = 0; i < propsToUpdate.length; i++) {\n            const key = propsToUpdate[i];\n            const prev = oldProps[key];\n            const next = newProps[key];\n            if (next !== prev || key === \"value\") {\n              hostPatchProp(el, key, prev, next, namespace, n1.children, parentComponent, parentSuspense, unmountChildren);\n            }\n          }\n        }\n      }\n      if (patchFlag & 1) {\n        if (n1.children !== n2.children) {\n          hostSetElementText(el, n2.children);\n        }\n      }\n    } else if (!optimized && dynamicChildren == null) {\n      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, namespace);\n    }\n    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\n        dirs && invokeDirectiveHook(n2, n1, parentComponent, \"updated\");\n      }, parentSuspense);\n    }\n  };\n  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {\n    for (let i = 0; i < newChildren.length; i++) {\n      const oldVNode = oldChildren[i];\n      const newVNode = newChildren[i];\n      const container =\n      // oldVNode may be an errored async setup() component inside Suspense\n      // which will not have a mounted element\n      oldVNode.el && (\n      // - In the case of a Fragment, we need to provide the actual parent\n      // of the Fragment itself so it can move its children.\n      oldVNode.type === Fragment ||\n      // - In the case of different nodes, there is going to be a replacement\n      // which also requires the correct parent container\n      !isSameVNodeType(oldVNode, newVNode) ||\n      // - In the case of a component, it could contain anything.\n      oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) :\n      // In other cases, the parent container is not actually used so we\n      // just pass the block element here to avoid a DOM parentNode call.\n      fallbackContainer;\n      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, true);\n    }\n  };\n  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, namespace) => {\n    if (oldProps !== newProps) {\n      if (oldProps !== _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ) {\n        for (const key in oldProps) {\n          if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isReservedProp)(key) && !(key in newProps)) {\n            hostPatchProp(el, key, oldProps[key], null, namespace, vnode.children, parentComponent, parentSuspense, unmountChildren);\n          }\n        }\n      }\n      for (const key in newProps) {\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isReservedProp)(key)) continue;\n        const next = newProps[key];\n        const prev = oldProps[key];\n        if (next !== prev && key !== \"value\") {\n          hostPatchProp(el, key, prev, next, namespace, vnode.children, parentComponent, parentSuspense, unmountChildren);\n        }\n      }\n      if (\"value\" in newProps) {\n        hostPatchProp(el, \"value\", oldProps.value, newProps.value, namespace);\n      }\n    }\n  };\n  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText(\"\");\n    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText(\"\");\n    let {\n      patchFlag,\n      dynamicChildren,\n      slotScopeIds: fragmentSlotScopeIds\n    } = n2;\n    if ( true && (\n    // #5523 dev root fragment may inherit directives\n    isHmrUpdating || patchFlag & 2048)) {\n      patchFlag = 0;\n      optimized = false;\n      dynamicChildren = null;\n    }\n    if (fragmentSlotScopeIds) {\n      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;\n    }\n    if (n1 == null) {\n      hostInsert(fragmentStartAnchor, container, anchor);\n      hostInsert(fragmentEndAnchor, container, anchor);\n      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);\n    } else {\n      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren &&\n      // #2715 the previous fragment could've been a BAILed one as a result\n      // of renderSlot() with no valid children\n      n1.dynamicChildren) {\n        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, namespace, slotScopeIds);\n        if (true) {\n          traverseStaticChildren(n1, n2);\n        } else {}\n      } else {\n        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);\n      }\n    }\n  };\n  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    n2.slotScopeIds = slotScopeIds;\n    if (n1 == null) {\n      if (n2.shapeFlag & 512) {\n        parentComponent.ctx.activate(n2, container, anchor, namespace, optimized);\n      } else {\n        mountComponent(n2, container, anchor, parentComponent, parentSuspense, namespace, optimized);\n      }\n    } else {\n      updateComponent(n1, n2, optimized);\n    }\n  };\n  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {\n    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);\n    if ( true && instance.type.__hmrId) {\n      registerHMR(instance);\n    }\n    if (true) {\n      pushWarningContext(initialVNode);\n      startMeasure(instance, `mount`);\n    }\n    if (isKeepAlive(initialVNode)) {\n      instance.ctx.renderer = internals;\n    }\n    {\n      if (true) {\n        startMeasure(instance, `init`);\n      }\n      setupComponent(instance);\n      if (true) {\n        endMeasure(instance, `init`);\n      }\n    }\n    if (instance.asyncDep) {\n      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);\n      if (!initialVNode.el) {\n        const placeholder = instance.subTree = createVNode(Comment);\n        processCommentNode(null, placeholder, container, anchor);\n      }\n    } else {\n      setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, namespace, optimized);\n    }\n    if (true) {\n      popWarningContext();\n      endMeasure(instance, `mount`);\n    }\n  };\n  const updateComponent = (n1, n2, optimized) => {\n    const instance = n2.component = n1.component;\n    if (shouldUpdateComponent(n1, n2, optimized)) {\n      if (instance.asyncDep && !instance.asyncResolved) {\n        if (true) {\n          pushWarningContext(n2);\n        }\n        updateComponentPreRender(instance, n2, optimized);\n        if (true) {\n          popWarningContext();\n        }\n        return;\n      } else {\n        instance.next = n2;\n        invalidateJob(instance.update);\n        instance.effect.dirty = true;\n        instance.update();\n      }\n    } else {\n      n2.el = n1.el;\n      instance.vnode = n2;\n    }\n  };\n  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {\n    const componentUpdateFn = () => {\n      if (!instance.isMounted) {\n        let vnodeHook;\n        const {\n          el,\n          props\n        } = initialVNode;\n        const {\n          bm,\n          m,\n          parent\n        } = instance;\n        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);\n        toggleRecurse(instance, false);\n        if (bm) {\n          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.invokeArrayFns)(bm);\n        }\n        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {\n          invokeVNodeHook(vnodeHook, parent, initialVNode);\n        }\n        toggleRecurse(instance, true);\n        if (el && hydrateNode) {\n          const hydrateSubTree = () => {\n            if (true) {\n              startMeasure(instance, `render`);\n            }\n            instance.subTree = renderComponentRoot(instance);\n            if (true) {\n              endMeasure(instance, `render`);\n            }\n            if (true) {\n              startMeasure(instance, `hydrate`);\n            }\n            hydrateNode(el, instance.subTree, instance, parentSuspense, null);\n            if (true) {\n              endMeasure(instance, `hydrate`);\n            }\n          };\n          if (isAsyncWrapperVNode) {\n            initialVNode.type.__asyncLoader().then(\n            // note: we are moving the render call into an async callback,\n            // which means it won't track dependencies - but it's ok because\n            // a server-rendered async wrapper is already in resolved state\n            // and it will never need to change.\n            () => !instance.isUnmounted && hydrateSubTree());\n          } else {\n            hydrateSubTree();\n          }\n        } else {\n          if (true) {\n            startMeasure(instance, `render`);\n          }\n          const subTree = instance.subTree = renderComponentRoot(instance);\n          if (true) {\n            endMeasure(instance, `render`);\n          }\n          if (true) {\n            startMeasure(instance, `patch`);\n          }\n          patch(null, subTree, container, anchor, instance, parentSuspense, namespace);\n          if (true) {\n            endMeasure(instance, `patch`);\n          }\n          initialVNode.el = subTree.el;\n        }\n        if (m) {\n          queuePostRenderEffect(m, parentSuspense);\n        }\n        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {\n          const scopedInitialVNode = initialVNode;\n          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);\n        }\n        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {\n          instance.a && queuePostRenderEffect(instance.a, parentSuspense);\n        }\n        instance.isMounted = true;\n        if (true) {\n          devtoolsComponentAdded(instance);\n        }\n        initialVNode = container = anchor = null;\n      } else {\n        let {\n          next,\n          bu,\n          u,\n          parent,\n          vnode\n        } = instance;\n        {\n          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);\n          if (nonHydratedAsyncRoot) {\n            if (next) {\n              next.el = vnode.el;\n              updateComponentPreRender(instance, next, optimized);\n            }\n            nonHydratedAsyncRoot.asyncDep.then(() => {\n              if (!instance.isUnmounted) {\n                componentUpdateFn();\n              }\n            });\n            return;\n          }\n        }\n        let originNext = next;\n        let vnodeHook;\n        if (true) {\n          pushWarningContext(next || instance.vnode);\n        }\n        toggleRecurse(instance, false);\n        if (next) {\n          next.el = vnode.el;\n          updateComponentPreRender(instance, next, optimized);\n        } else {\n          next = vnode;\n        }\n        if (bu) {\n          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.invokeArrayFns)(bu);\n        }\n        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {\n          invokeVNodeHook(vnodeHook, parent, next, vnode);\n        }\n        toggleRecurse(instance, true);\n        if (true) {\n          startMeasure(instance, `render`);\n        }\n        const nextTree = renderComponentRoot(instance);\n        if (true) {\n          endMeasure(instance, `render`);\n        }\n        const prevTree = instance.subTree;\n        instance.subTree = nextTree;\n        if (true) {\n          startMeasure(instance, `patch`);\n        }\n        patch(prevTree, nextTree,\n        // parent may have changed if it's in a teleport\n        hostParentNode(prevTree.el),\n        // anchor may have changed if it's in a fragment\n        getNextHostNode(prevTree), instance, parentSuspense, namespace);\n        if (true) {\n          endMeasure(instance, `patch`);\n        }\n        next.el = nextTree.el;\n        if (originNext === null) {\n          updateHOCHostEl(instance, nextTree.el);\n        }\n        if (u) {\n          queuePostRenderEffect(u, parentSuspense);\n        }\n        if (vnodeHook = next.props && next.props.onVnodeUpdated) {\n          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);\n        }\n        if (true) {\n          devtoolsComponentUpdated(instance);\n        }\n        if (true) {\n          popWarningContext();\n        }\n      }\n    };\n    const effect = instance.effect = new _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.ReactiveEffect(componentUpdateFn, _vue_shared__WEBPACK_IMPORTED_MODULE_2__.NOOP, () => queueJob(update), instance.scope\n    // track it in component's effect scope\n    );\n    const update = instance.update = () => {\n      if (effect.dirty) {\n        effect.run();\n      }\n    };\n    update.id = instance.uid;\n    toggleRecurse(instance, true);\n    if (true) {\n      effect.onTrack = instance.rtc ? e => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.invokeArrayFns)(instance.rtc, e) : void 0;\n      effect.onTrigger = instance.rtg ? e => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.invokeArrayFns)(instance.rtg, e) : void 0;\n      update.ownerInstance = instance;\n    }\n    update();\n  };\n  const updateComponentPreRender = (instance, nextVNode, optimized) => {\n    nextVNode.component = instance;\n    const prevProps = instance.vnode.props;\n    instance.vnode = nextVNode;\n    instance.next = null;\n    updateProps(instance, nextVNode.props, prevProps, optimized);\n    updateSlots(instance, nextVNode.children, optimized);\n    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.pauseTracking)();\n    flushPreFlushCbs(instance);\n    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.resetTracking)();\n  };\n  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {\n    const c1 = n1 && n1.children;\n    const prevShapeFlag = n1 ? n1.shapeFlag : 0;\n    const c2 = n2.children;\n    const {\n      patchFlag,\n      shapeFlag\n    } = n2;\n    if (patchFlag > 0) {\n      if (patchFlag & 128) {\n        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);\n        return;\n      } else if (patchFlag & 256) {\n        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);\n        return;\n      }\n    }\n    if (shapeFlag & 8) {\n      if (prevShapeFlag & 16) {\n        unmountChildren(c1, parentComponent, parentSuspense);\n      }\n      if (c2 !== c1) {\n        hostSetElementText(container, c2);\n      }\n    } else {\n      if (prevShapeFlag & 16) {\n        if (shapeFlag & 16) {\n          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);\n        } else {\n          unmountChildren(c1, parentComponent, parentSuspense, true);\n        }\n      } else {\n        if (prevShapeFlag & 8) {\n          hostSetElementText(container, \"\");\n        }\n        if (shapeFlag & 16) {\n          mountChildren(c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);\n        }\n      }\n    }\n  };\n  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    c1 = c1 || _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_ARR;\n    c2 = c2 || _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_ARR;\n    const oldLength = c1.length;\n    const newLength = c2.length;\n    const commonLength = Math.min(oldLength, newLength);\n    let i;\n    for (i = 0; i < commonLength; i++) {\n      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n      patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);\n    }\n    if (oldLength > newLength) {\n      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);\n    } else {\n      mountChildren(c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, commonLength);\n    }\n  };\n  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    let i = 0;\n    const l2 = c2.length;\n    let e1 = c1.length - 1;\n    let e2 = l2 - 1;\n    while (i <= e1 && i <= e2) {\n      const n1 = c1[i];\n      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n      if (isSameVNodeType(n1, n2)) {\n        patch(n1, n2, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);\n      } else {\n        break;\n      }\n      i++;\n    }\n    while (i <= e1 && i <= e2) {\n      const n1 = c1[e1];\n      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);\n      if (isSameVNodeType(n1, n2)) {\n        patch(n1, n2, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);\n      } else {\n        break;\n      }\n      e1--;\n      e2--;\n    }\n    if (i > e1) {\n      if (i <= e2) {\n        const nextPos = e2 + 1;\n        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;\n        while (i <= e2) {\n          patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);\n          i++;\n        }\n      }\n    } else if (i > e2) {\n      while (i <= e1) {\n        unmount(c1[i], parentComponent, parentSuspense, true);\n        i++;\n      }\n    } else {\n      const s1 = i;\n      const s2 = i;\n      const keyToNewIndexMap = /* @__PURE__ */new Map();\n      for (i = s2; i <= e2; i++) {\n        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n        if (nextChild.key != null) {\n          if ( true && keyToNewIndexMap.has(nextChild.key)) {\n            warn$1(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);\n          }\n          keyToNewIndexMap.set(nextChild.key, i);\n        }\n      }\n      let j;\n      let patched = 0;\n      const toBePatched = e2 - s2 + 1;\n      let moved = false;\n      let maxNewIndexSoFar = 0;\n      const newIndexToOldIndexMap = new Array(toBePatched);\n      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;\n      for (i = s1; i <= e1; i++) {\n        const prevChild = c1[i];\n        if (patched >= toBePatched) {\n          unmount(prevChild, parentComponent, parentSuspense, true);\n          continue;\n        }\n        let newIndex;\n        if (prevChild.key != null) {\n          newIndex = keyToNewIndexMap.get(prevChild.key);\n        } else {\n          for (j = s2; j <= e2; j++) {\n            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {\n              newIndex = j;\n              break;\n            }\n          }\n        }\n        if (newIndex === void 0) {\n          unmount(prevChild, parentComponent, parentSuspense, true);\n        } else {\n          newIndexToOldIndexMap[newIndex - s2] = i + 1;\n          if (newIndex >= maxNewIndexSoFar) {\n            maxNewIndexSoFar = newIndex;\n          } else {\n            moved = true;\n          }\n          patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);\n          patched++;\n        }\n      }\n      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_ARR;\n      j = increasingNewIndexSequence.length - 1;\n      for (i = toBePatched - 1; i >= 0; i--) {\n        const nextIndex = s2 + i;\n        const nextChild = c2[nextIndex];\n        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;\n        if (newIndexToOldIndexMap[i] === 0) {\n          patch(null, nextChild, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);\n        } else if (moved) {\n          if (j < 0 || i !== increasingNewIndexSequence[j]) {\n            move(nextChild, container, anchor, 2);\n          } else {\n            j--;\n          }\n        }\n      }\n    }\n  };\n  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {\n    const {\n      el,\n      type,\n      transition,\n      children,\n      shapeFlag\n    } = vnode;\n    if (shapeFlag & 6) {\n      move(vnode.component.subTree, container, anchor, moveType);\n      return;\n    }\n    if (shapeFlag & 128) {\n      vnode.suspense.move(container, anchor, moveType);\n      return;\n    }\n    if (shapeFlag & 64) {\n      type.move(vnode, container, anchor, internals);\n      return;\n    }\n    if (type === Fragment) {\n      hostInsert(el, container, anchor);\n      for (let i = 0; i < children.length; i++) {\n        move(children[i], container, anchor, moveType);\n      }\n      hostInsert(vnode.anchor, container, anchor);\n      return;\n    }\n    if (type === Static) {\n      moveStaticNode(vnode, container, anchor);\n      return;\n    }\n    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;\n    if (needTransition2) {\n      if (moveType === 0) {\n        transition.beforeEnter(el);\n        hostInsert(el, container, anchor);\n        queuePostRenderEffect(() => transition.enter(el), parentSuspense);\n      } else {\n        const {\n          leave,\n          delayLeave,\n          afterLeave\n        } = transition;\n        const remove2 = () => hostInsert(el, container, anchor);\n        const performLeave = () => {\n          leave(el, () => {\n            remove2();\n            afterLeave && afterLeave();\n          });\n        };\n        if (delayLeave) {\n          delayLeave(el, remove2, performLeave);\n        } else {\n          performLeave();\n        }\n      }\n    } else {\n      hostInsert(el, container, anchor);\n    }\n  };\n  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {\n    const {\n      type,\n      props,\n      ref,\n      children,\n      dynamicChildren,\n      shapeFlag,\n      patchFlag,\n      dirs\n    } = vnode;\n    if (ref != null) {\n      setRef(ref, null, parentSuspense, vnode, true);\n    }\n    if (shapeFlag & 256) {\n      parentComponent.ctx.deactivate(vnode);\n      return;\n    }\n    const shouldInvokeDirs = shapeFlag & 1 && dirs;\n    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);\n    let vnodeHook;\n    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {\n      invokeVNodeHook(vnodeHook, parentComponent, vnode);\n    }\n    if (shapeFlag & 6) {\n      unmountComponent(vnode.component, parentSuspense, doRemove);\n    } else {\n      if (shapeFlag & 128) {\n        vnode.suspense.unmount(parentSuspense, doRemove);\n        return;\n      }\n      if (shouldInvokeDirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, \"beforeUnmount\");\n      }\n      if (shapeFlag & 64) {\n        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);\n      } else if (dynamicChildren && (\n      // #1153: fast path should not be taken for non-stable (v-for) fragments\n      type !== Fragment || patchFlag > 0 && patchFlag & 64)) {\n        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);\n      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {\n        unmountChildren(children, parentComponent, parentSuspense);\n      }\n      if (doRemove) {\n        remove(vnode);\n      }\n    }\n    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\n        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, \"unmounted\");\n      }, parentSuspense);\n    }\n  };\n  const remove = vnode => {\n    const {\n      type,\n      el,\n      anchor,\n      transition\n    } = vnode;\n    if (type === Fragment) {\n      if ( true && vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {\n        vnode.children.forEach(child => {\n          if (child.type === Comment) {\n            hostRemove(child.el);\n          } else {\n            remove(child);\n          }\n        });\n      } else {\n        removeFragment(el, anchor);\n      }\n      return;\n    }\n    if (type === Static) {\n      removeStaticNode(vnode);\n      return;\n    }\n    const performRemove = () => {\n      hostRemove(el);\n      if (transition && !transition.persisted && transition.afterLeave) {\n        transition.afterLeave();\n      }\n    };\n    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {\n      const {\n        leave,\n        delayLeave\n      } = transition;\n      const performLeave = () => leave(el, performRemove);\n      if (delayLeave) {\n        delayLeave(vnode.el, performRemove, performLeave);\n      } else {\n        performLeave();\n      }\n    } else {\n      performRemove();\n    }\n  };\n  const removeFragment = (cur, end) => {\n    let next;\n    while (cur !== end) {\n      next = hostNextSibling(cur);\n      hostRemove(cur);\n      cur = next;\n    }\n    hostRemove(end);\n  };\n  const unmountComponent = (instance, parentSuspense, doRemove) => {\n    if ( true && instance.type.__hmrId) {\n      unregisterHMR(instance);\n    }\n    const {\n      bum,\n      scope,\n      update,\n      subTree,\n      um\n    } = instance;\n    if (bum) {\n      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.invokeArrayFns)(bum);\n    }\n    scope.stop();\n    if (update) {\n      update.active = false;\n      unmount(subTree, instance, parentSuspense, doRemove);\n    }\n    if (um) {\n      queuePostRenderEffect(um, parentSuspense);\n    }\n    queuePostRenderEffect(() => {\n      instance.isUnmounted = true;\n    }, parentSuspense);\n    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {\n      parentSuspense.deps--;\n      if (parentSuspense.deps === 0) {\n        parentSuspense.resolve();\n      }\n    }\n    if (true) {\n      devtoolsComponentRemoved(instance);\n    }\n  };\n  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {\n    for (let i = start; i < children.length; i++) {\n      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);\n    }\n  };\n  const getNextHostNode = vnode => {\n    if (vnode.shapeFlag & 6) {\n      return getNextHostNode(vnode.component.subTree);\n    }\n    if (vnode.shapeFlag & 128) {\n      return vnode.suspense.next();\n    }\n    return hostNextSibling(vnode.anchor || vnode.el);\n  };\n  const render = (vnode, container, namespace) => {\n    if (vnode == null) {\n      if (container._vnode) {\n        unmount(container._vnode, null, null, true);\n      }\n    } else {\n      patch(container._vnode || null, vnode, container, null, null, null, namespace);\n    }\n    flushPreFlushCbs();\n    flushPostFlushCbs();\n    container._vnode = vnode;\n  };\n  const internals = {\n    p: patch,\n    um: unmount,\n    m: move,\n    r: remove,\n    mt: mountComponent,\n    mc: mountChildren,\n    pc: patchChildren,\n    pbc: patchBlockChildren,\n    n: getNextHostNode,\n    o: options\n  };\n  let hydrate;\n  let hydrateNode;\n  if (createHydrationFns) {\n    [hydrate, hydrateNode] = createHydrationFns(internals);\n  }\n  return {\n    render,\n    hydrate,\n    createApp: createAppAPI(render, hydrate)\n  };\n}\nfunction resolveChildrenNamespace({\n  type,\n  props\n}, currentNamespace) {\n  return currentNamespace === \"svg\" && type === \"foreignObject\" || currentNamespace === \"mathml\" && type === \"annotation-xml\" && props && props.encoding && props.encoding.includes(\"html\") ? void 0 : currentNamespace;\n}\nfunction toggleRecurse({\n  effect,\n  update\n}, allowed) {\n  effect.allowRecurse = update.allowRecurse = allowed;\n}\nfunction needTransition(parentSuspense, transition) {\n  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;\n}\nfunction traverseStaticChildren(n1, n2, shallow = false) {\n  const ch1 = n1.children;\n  const ch2 = n2.children;\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(ch1) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(ch2)) {\n    for (let i = 0; i < ch1.length; i++) {\n      const c1 = ch1[i];\n      let c2 = ch2[i];\n      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {\n        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {\n          c2 = ch2[i] = cloneIfMounted(ch2[i]);\n          c2.el = c1.el;\n        }\n        if (!shallow) traverseStaticChildren(c1, c2);\n      }\n      if (c2.type === Text) {\n        c2.el = c1.el;\n      }\n      if ( true && c2.type === Comment && !c2.el) {\n        c2.el = c1.el;\n      }\n    }\n  }\n}\nfunction getSequence(arr) {\n  const p = arr.slice();\n  const result = [0];\n  let i, j, u, v, c;\n  const len = arr.length;\n  for (i = 0; i < len; i++) {\n    const arrI = arr[i];\n    if (arrI !== 0) {\n      j = result[result.length - 1];\n      if (arr[j] < arrI) {\n        p[i] = j;\n        result.push(i);\n        continue;\n      }\n      u = 0;\n      v = result.length - 1;\n      while (u < v) {\n        c = u + v >> 1;\n        if (arr[result[c]] < arrI) {\n          u = c + 1;\n        } else {\n          v = c;\n        }\n      }\n      if (arrI < arr[result[u]]) {\n        if (u > 0) {\n          p[i] = result[u - 1];\n        }\n        result[u] = i;\n      }\n    }\n  }\n  u = result.length;\n  v = result[u - 1];\n  while (u-- > 0) {\n    result[u] = v;\n    v = p[v];\n  }\n  return result;\n}\nfunction locateNonHydratedAsyncRoot(instance) {\n  const subComponent = instance.subTree.component;\n  if (subComponent) {\n    if (subComponent.asyncDep && !subComponent.asyncResolved) {\n      return subComponent;\n    } else {\n      return locateNonHydratedAsyncRoot(subComponent);\n    }\n  }\n}\nconst isTeleport = type => type.__isTeleport;\nconst isTeleportDisabled = props => props && (props.disabled || props.disabled === \"\");\nconst isTargetSVG = target => typeof SVGElement !== \"undefined\" && target instanceof SVGElement;\nconst isTargetMathML = target => typeof MathMLElement === \"function\" && target instanceof MathMLElement;\nconst resolveTarget = (props, select) => {\n  const targetSelector = props && props.to;\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isString)(targetSelector)) {\n    if (!select) {\n       true && warn$1(`Current renderer does not support string target for Teleports. (missing querySelector renderer option)`);\n      return null;\n    } else {\n      const target = select(targetSelector);\n      if (!target) {\n         true && warn$1(`Failed to locate Teleport target with selector \"${targetSelector}\". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`);\n      }\n      return target;\n    }\n  } else {\n    if ( true && !targetSelector && !isTeleportDisabled(props)) {\n      warn$1(`Invalid Teleport target: ${targetSelector}`);\n    }\n    return targetSelector;\n  }\n};\nconst TeleportImpl = {\n  name: \"Teleport\",\n  __isTeleport: true,\n  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {\n    const {\n      mc: mountChildren,\n      pc: patchChildren,\n      pbc: patchBlockChildren,\n      o: {\n        insert,\n        querySelector,\n        createText,\n        createComment\n      }\n    } = internals;\n    const disabled = isTeleportDisabled(n2.props);\n    let {\n      shapeFlag,\n      children,\n      dynamicChildren\n    } = n2;\n    if ( true && isHmrUpdating) {\n      optimized = false;\n      dynamicChildren = null;\n    }\n    if (n1 == null) {\n      const placeholder = n2.el =  true ? createComment(\"teleport start\") : 0;\n      const mainAnchor = n2.anchor =  true ? createComment(\"teleport end\") : 0;\n      insert(placeholder, container, anchor);\n      insert(mainAnchor, container, anchor);\n      const target = n2.target = resolveTarget(n2.props, querySelector);\n      const targetAnchor = n2.targetAnchor = createText(\"\");\n      if (target) {\n        insert(targetAnchor, target);\n        if (namespace === \"svg\" || isTargetSVG(target)) {\n          namespace = \"svg\";\n        } else if (namespace === \"mathml\" || isTargetMathML(target)) {\n          namespace = \"mathml\";\n        }\n      } else if ( true && !disabled) {\n        warn$1(\"Invalid Teleport target on mount:\", target, `(${typeof target})`);\n      }\n      const mount = (container2, anchor2) => {\n        if (shapeFlag & 16) {\n          mountChildren(children, container2, anchor2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);\n        }\n      };\n      if (disabled) {\n        mount(container, mainAnchor);\n      } else if (target) {\n        mount(target, targetAnchor);\n      }\n    } else {\n      n2.el = n1.el;\n      const mainAnchor = n2.anchor = n1.anchor;\n      const target = n2.target = n1.target;\n      const targetAnchor = n2.targetAnchor = n1.targetAnchor;\n      const wasDisabled = isTeleportDisabled(n1.props);\n      const currentContainer = wasDisabled ? container : target;\n      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;\n      if (namespace === \"svg\" || isTargetSVG(target)) {\n        namespace = \"svg\";\n      } else if (namespace === \"mathml\" || isTargetMathML(target)) {\n        namespace = \"mathml\";\n      }\n      if (dynamicChildren) {\n        patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, namespace, slotScopeIds);\n        traverseStaticChildren(n1, n2, true);\n      } else if (!optimized) {\n        patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, false);\n      }\n      if (disabled) {\n        if (!wasDisabled) {\n          moveTeleport(n2, container, mainAnchor, internals, 1);\n        } else {\n          if (n2.props && n1.props && n2.props.to !== n1.props.to) {\n            n2.props.to = n1.props.to;\n          }\n        }\n      } else {\n        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {\n          const nextTarget = n2.target = resolveTarget(n2.props, querySelector);\n          if (nextTarget) {\n            moveTeleport(n2, nextTarget, null, internals, 0);\n          } else if (true) {\n            warn$1(\"Invalid Teleport target on update:\", target, `(${typeof target})`);\n          }\n        } else if (wasDisabled) {\n          moveTeleport(n2, target, targetAnchor, internals, 1);\n        }\n      }\n    }\n    updateCssVars(n2);\n  },\n  remove(vnode, parentComponent, parentSuspense, optimized, {\n    um: unmount,\n    o: {\n      remove: hostRemove\n    }\n  }, doRemove) {\n    const {\n      shapeFlag,\n      children,\n      anchor,\n      targetAnchor,\n      target,\n      props\n    } = vnode;\n    if (target) {\n      hostRemove(targetAnchor);\n    }\n    doRemove && hostRemove(anchor);\n    if (shapeFlag & 16) {\n      const shouldRemove = doRemove || !isTeleportDisabled(props);\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        unmount(child, parentComponent, parentSuspense, shouldRemove, !!child.dynamicChildren);\n      }\n    }\n  },\n  move: moveTeleport,\n  hydrate: hydrateTeleport\n};\nfunction moveTeleport(vnode, container, parentAnchor, {\n  o: {\n    insert\n  },\n  m: move\n}, moveType = 2) {\n  if (moveType === 0) {\n    insert(vnode.targetAnchor, container, parentAnchor);\n  }\n  const {\n    el,\n    anchor,\n    shapeFlag,\n    children,\n    props\n  } = vnode;\n  const isReorder = moveType === 2;\n  if (isReorder) {\n    insert(el, container, parentAnchor);\n  }\n  if (!isReorder || isTeleportDisabled(props)) {\n    if (shapeFlag & 16) {\n      for (let i = 0; i < children.length; i++) {\n        move(children[i], container, parentAnchor, 2);\n      }\n    }\n  }\n  if (isReorder) {\n    insert(anchor, container, parentAnchor);\n  }\n}\nfunction hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {\n  o: {\n    nextSibling,\n    parentNode,\n    querySelector\n  }\n}, hydrateChildren) {\n  const target = vnode.target = resolveTarget(vnode.props, querySelector);\n  if (target) {\n    const targetNode = target._lpa || target.firstChild;\n    if (vnode.shapeFlag & 16) {\n      if (isTeleportDisabled(vnode.props)) {\n        vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);\n        vnode.targetAnchor = targetNode;\n      } else {\n        vnode.anchor = nextSibling(node);\n        let targetAnchor = targetNode;\n        while (targetAnchor) {\n          targetAnchor = nextSibling(targetAnchor);\n          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === \"teleport anchor\") {\n            vnode.targetAnchor = targetAnchor;\n            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);\n            break;\n          }\n        }\n        hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);\n      }\n    }\n    updateCssVars(vnode);\n  }\n  return vnode.anchor && nextSibling(vnode.anchor);\n}\nconst Teleport = TeleportImpl;\nfunction updateCssVars(vnode) {\n  const ctx = vnode.ctx;\n  if (ctx && ctx.ut) {\n    let node = vnode.children[0].el;\n    while (node && node !== vnode.targetAnchor) {\n      if (node.nodeType === 1) node.setAttribute(\"data-v-owner\", ctx.uid);\n      node = node.nextSibling;\n    }\n    ctx.ut();\n  }\n}\nconst Fragment = Symbol.for(\"v-fgt\");\nconst Text = Symbol.for(\"v-txt\");\nconst Comment = Symbol.for(\"v-cmt\");\nconst Static = Symbol.for(\"v-stc\");\nconst blockStack = [];\nlet currentBlock = null;\nfunction openBlock(disableTracking = false) {\n  blockStack.push(currentBlock = disableTracking ? null : []);\n}\nfunction closeBlock() {\n  blockStack.pop();\n  currentBlock = blockStack[blockStack.length - 1] || null;\n}\nlet isBlockTreeEnabled = 1;\nfunction setBlockTracking(value) {\n  isBlockTreeEnabled += value;\n}\nfunction setupBlock(vnode) {\n  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_ARR : null;\n  closeBlock();\n  if (isBlockTreeEnabled > 0 && currentBlock) {\n    currentBlock.push(vnode);\n  }\n  return vnode;\n}\nfunction createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {\n  return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));\n}\nfunction createBlock(type, props, children, patchFlag, dynamicProps) {\n  return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true));\n}\nfunction isVNode(value) {\n  return value ? value.__v_isVNode === true : false;\n}\nfunction isSameVNodeType(n1, n2) {\n  if ( true && n2.shapeFlag & 6 && hmrDirtyComponents.has(n2.type)) {\n    n1.shapeFlag &= ~256;\n    n2.shapeFlag &= ~512;\n    return false;\n  }\n  return n1.type === n2.type && n1.key === n2.key;\n}\nlet vnodeArgsTransformer;\nfunction transformVNodeArgs(transformer) {\n  vnodeArgsTransformer = transformer;\n}\nconst createVNodeWithArgsTransform = (...args) => {\n  return _createVNode(...(vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args));\n};\nconst InternalObjectKey = `__vInternal`;\nconst normalizeKey = ({\n  key\n}) => key != null ? key : null;\nconst normalizeRef = ({\n  ref,\n  ref_key,\n  ref_for\n}) => {\n  if (typeof ref === \"number\") {\n    ref = \"\" + ref;\n  }\n  return ref != null ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isString)(ref) || (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.isRef)(ref) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(ref) ? {\n    i: currentRenderingInstance,\n    r: ref,\n    k: ref_key,\n    f: !!ref_for\n  } : ref : null;\n};\nfunction createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {\n  const vnode = {\n    __v_isVNode: true,\n    __v_skip: true,\n    type,\n    props,\n    key: props && normalizeKey(props),\n    ref: props && normalizeRef(props),\n    scopeId: currentScopeId,\n    slotScopeIds: null,\n    children,\n    component: null,\n    suspense: null,\n    ssContent: null,\n    ssFallback: null,\n    dirs: null,\n    transition: null,\n    el: null,\n    anchor: null,\n    target: null,\n    targetAnchor: null,\n    staticCount: 0,\n    shapeFlag,\n    patchFlag,\n    dynamicProps,\n    dynamicChildren: null,\n    appContext: null,\n    ctx: currentRenderingInstance\n  };\n  if (needFullChildrenNormalization) {\n    normalizeChildren(vnode, children);\n    if (shapeFlag & 128) {\n      type.normalize(vnode);\n    }\n  } else if (children) {\n    vnode.shapeFlag |= (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isString)(children) ? 8 : 16;\n  }\n  if ( true && vnode.key !== vnode.key) {\n    warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);\n  }\n  if (isBlockTreeEnabled > 0 &&\n  // avoid a block node from tracking itself\n  !isBlockNode &&\n  // has current parent block\n  currentBlock && (\n  // presence of a patch flag indicates this node needs patching on updates.\n  // component nodes also should always be patched, because even if the\n  // component doesn't need to update, it needs to persist the instance on to\n  // the next vnode so that it can be properly unmounted later.\n  vnode.patchFlag > 0 || shapeFlag & 6) &&\n  // the EVENTS flag is only for hydration and if it is the only flag, the\n  // vnode should not be considered dynamic due to handler caching.\n  vnode.patchFlag !== 32) {\n    currentBlock.push(vnode);\n  }\n  return vnode;\n}\nconst createVNode =  true ? createVNodeWithArgsTransform : 0;\nfunction _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\n  if (!type || type === NULL_DYNAMIC_COMPONENT) {\n    if ( true && !type) {\n      warn$1(`Invalid vnode type when creating vnode: ${type}.`);\n    }\n    type = Comment;\n  }\n  if (isVNode(type)) {\n    const cloned = cloneVNode(type, props, true\n    /* mergeRef: true */);\n    if (children) {\n      normalizeChildren(cloned, children);\n    }\n    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {\n      if (cloned.shapeFlag & 6) {\n        currentBlock[currentBlock.indexOf(type)] = cloned;\n      } else {\n        currentBlock.push(cloned);\n      }\n    }\n    cloned.patchFlag |= -2;\n    return cloned;\n  }\n  if (isClassComponent(type)) {\n    type = type.__vccOpts;\n  }\n  if (props) {\n    props = guardReactiveProps(props);\n    let {\n      class: klass,\n      style\n    } = props;\n    if (klass && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isString)(klass)) {\n      props.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.normalizeClass)(klass);\n    }\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isObject)(style)) {\n      if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.isProxy)(style) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(style)) {\n        style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)({}, style);\n      }\n      props.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.normalizeStyle)(style);\n    }\n  }\n  const shapeFlag = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isString)(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isObject)(type) ? 4 : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(type) ? 2 : 0;\n  if ( true && shapeFlag & 4 && (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.isProxy)(type)) {\n    type = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.toRaw)(type);\n    warn$1(`Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with \\`markRaw\\` or using \\`shallowRef\\` instead of \\`ref\\`.`, `\nComponent that was made reactive: `, type);\n  }\n  return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);\n}\nfunction guardReactiveProps(props) {\n  if (!props) return null;\n  return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.isProxy)(props) || InternalObjectKey in props ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)({}, props) : props;\n}\nfunction cloneVNode(vnode, extraProps, mergeRef = false) {\n  const {\n    props,\n    ref,\n    patchFlag,\n    children\n  } = vnode;\n  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\n  const cloned = {\n    __v_isVNode: true,\n    __v_skip: true,\n    type: vnode.type,\n    props: mergedProps,\n    key: mergedProps && normalizeKey(mergedProps),\n    ref: extraProps && extraProps.ref ?\n    // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\n    // if the vnode itself already has a ref, cloneVNode will need to merge\n    // the refs so the single vnode can be set on multiple refs\n    mergeRef && ref ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref,\n    scopeId: vnode.scopeId,\n    slotScopeIds: vnode.slotScopeIds,\n    children:  true && patchFlag === -1 && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(children) ? children.map(deepCloneVNode) : children,\n    target: vnode.target,\n    targetAnchor: vnode.targetAnchor,\n    staticCount: vnode.staticCount,\n    shapeFlag: vnode.shapeFlag,\n    // if the vnode is cloned with extra props, we can no longer assume its\n    // existing patch flag to be reliable and need to add the FULL_PROPS flag.\n    // note: preserve flag for fragments since they use the flag for children\n    // fast paths only.\n    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,\n    dynamicProps: vnode.dynamicProps,\n    dynamicChildren: vnode.dynamicChildren,\n    appContext: vnode.appContext,\n    dirs: vnode.dirs,\n    transition: vnode.transition,\n    // These should technically only be non-null on mounted VNodes. However,\n    // they *should* be copied for kept-alive vnodes. So we just always copy\n    // them since them being non-null during a mount doesn't affect the logic as\n    // they will simply be overwritten.\n    component: vnode.component,\n    suspense: vnode.suspense,\n    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\n    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\n    el: vnode.el,\n    anchor: vnode.anchor,\n    ctx: vnode.ctx,\n    ce: vnode.ce\n  };\n  return cloned;\n}\nfunction deepCloneVNode(vnode) {\n  const cloned = cloneVNode(vnode);\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(vnode.children)) {\n    cloned.children = vnode.children.map(deepCloneVNode);\n  }\n  return cloned;\n}\nfunction createTextVNode(text = \" \", flag = 0) {\n  return createVNode(Text, null, text, flag);\n}\nfunction createStaticVNode(content, numberOfNodes) {\n  const vnode = createVNode(Static, null, content);\n  vnode.staticCount = numberOfNodes;\n  return vnode;\n}\nfunction createCommentVNode(text = \"\", asBlock = false) {\n  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);\n}\nfunction normalizeVNode(child) {\n  if (child == null || typeof child === \"boolean\") {\n    return createVNode(Comment);\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(child)) {\n    return createVNode(Fragment, null,\n    // #3666, avoid reference pollution when reusing vnode\n    child.slice());\n  } else if (typeof child === \"object\") {\n    return cloneIfMounted(child);\n  } else {\n    return createVNode(Text, null, String(child));\n  }\n}\nfunction cloneIfMounted(child) {\n  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);\n}\nfunction normalizeChildren(vnode, children) {\n  let type = 0;\n  const {\n    shapeFlag\n  } = vnode;\n  if (children == null) {\n    children = null;\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(children)) {\n    type = 16;\n  } else if (typeof children === \"object\") {\n    if (shapeFlag & (1 | 64)) {\n      const slot = children.default;\n      if (slot) {\n        slot._c && (slot._d = false);\n        normalizeChildren(vnode, slot());\n        slot._c && (slot._d = true);\n      }\n      return;\n    } else {\n      type = 32;\n      const slotFlag = children._;\n      if (!slotFlag && !(InternalObjectKey in children)) {\n        children._ctx = currentRenderingInstance;\n      } else if (slotFlag === 3 && currentRenderingInstance) {\n        if (currentRenderingInstance.slots._ === 1) {\n          children._ = 1;\n        } else {\n          children._ = 2;\n          vnode.patchFlag |= 1024;\n        }\n      }\n    }\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(children)) {\n    children = {\n      default: children,\n      _ctx: currentRenderingInstance\n    };\n    type = 32;\n  } else {\n    children = String(children);\n    if (shapeFlag & 64) {\n      type = 16;\n      children = [createTextVNode(children)];\n    } else {\n      type = 8;\n    }\n  }\n  vnode.children = children;\n  vnode.shapeFlag |= type;\n}\nfunction mergeProps(...args) {\n  const ret = {};\n  for (let i = 0; i < args.length; i++) {\n    const toMerge = args[i];\n    for (const key in toMerge) {\n      if (key === \"class\") {\n        if (ret.class !== toMerge.class) {\n          ret.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.normalizeClass)([ret.class, toMerge.class]);\n        }\n      } else if (key === \"style\") {\n        ret.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.normalizeStyle)([ret.style, toMerge.style]);\n      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isOn)(key)) {\n        const existing = ret[key];\n        const incoming = toMerge[key];\n        if (incoming && existing !== incoming && !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(existing) && existing.includes(incoming))) {\n          ret[key] = existing ? [].concat(existing, incoming) : incoming;\n        }\n      } else if (key !== \"\") {\n        ret[key] = toMerge[key];\n      }\n    }\n  }\n  return ret;\n}\nfunction invokeVNodeHook(hook, instance, vnode, prevVNode = null) {\n  callWithAsyncErrorHandling(hook, instance, 7, [vnode, prevVNode]);\n}\nconst emptyAppContext = createAppContext();\nlet uid = 0;\nfunction createComponentInstance(vnode, parent, suspense) {\n  const type = vnode.type;\n  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;\n  const instance = {\n    uid: uid++,\n    vnode,\n    type,\n    parent,\n    appContext,\n    root: null,\n    // to be immediately set\n    next: null,\n    subTree: null,\n    // will be set synchronously right after creation\n    effect: null,\n    update: null,\n    // will be set synchronously right after creation\n    scope: new _vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.EffectScope(true\n    /* detached */),\n    render: null,\n    proxy: null,\n    exposed: null,\n    exposeProxy: null,\n    withProxy: null,\n    provides: parent ? parent.provides : Object.create(appContext.provides),\n    accessCache: null,\n    renderCache: [],\n    // local resolved assets\n    components: null,\n    directives: null,\n    // resolved props and emits options\n    propsOptions: normalizePropsOptions(type, appContext),\n    emitsOptions: normalizeEmitsOptions(type, appContext),\n    // emit\n    emit: null,\n    // to be set immediately\n    emitted: null,\n    // props default value\n    propsDefaults: _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ,\n    // inheritAttrs\n    inheritAttrs: type.inheritAttrs,\n    // state\n    ctx: _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ,\n    data: _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ,\n    props: _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ,\n    attrs: _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ,\n    slots: _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ,\n    refs: _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ,\n    setupState: _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ,\n    setupContext: null,\n    attrsProxy: null,\n    slotsProxy: null,\n    // suspense related\n    suspense,\n    suspenseId: suspense ? suspense.pendingId : 0,\n    asyncDep: null,\n    asyncResolved: false,\n    // lifecycle hooks\n    // not using enums here because it results in computed properties\n    isMounted: false,\n    isUnmounted: false,\n    isDeactivated: false,\n    bc: null,\n    c: null,\n    bm: null,\n    m: null,\n    bu: null,\n    u: null,\n    um: null,\n    bum: null,\n    da: null,\n    a: null,\n    rtg: null,\n    rtc: null,\n    ec: null,\n    sp: null\n  };\n  if (true) {\n    instance.ctx = createDevRenderContext(instance);\n  } else {}\n  instance.root = parent ? parent.root : instance;\n  instance.emit = emit.bind(null, instance);\n  if (vnode.ce) {\n    vnode.ce(instance);\n  }\n  return instance;\n}\nlet currentInstance = null;\nconst getCurrentInstance = () => currentInstance || currentRenderingInstance;\nlet internalSetCurrentInstance;\nlet setInSSRSetupState;\n{\n  const g = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.getGlobalThis)();\n  const registerGlobalSetter = (key, setter) => {\n    let setters;\n    if (!(setters = g[key])) setters = g[key] = [];\n    setters.push(setter);\n    return v => {\n      if (setters.length > 1) setters.forEach(set => set(v));else setters[0](v);\n    };\n  };\n  internalSetCurrentInstance = registerGlobalSetter(`__VUE_INSTANCE_SETTERS__`, v => currentInstance = v);\n  setInSSRSetupState = registerGlobalSetter(`__VUE_SSR_SETTERS__`, v => isInSSRComponentSetup = v);\n}\nconst setCurrentInstance = instance => {\n  internalSetCurrentInstance(instance);\n  instance.scope.on();\n};\nconst unsetCurrentInstance = () => {\n  currentInstance && currentInstance.scope.off();\n  internalSetCurrentInstance(null);\n};\nconst isBuiltInTag = /* @__PURE__ */(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.makeMap)(\"slot,component\");\nfunction validateComponentName(name, config) {\n  const appIsNativeTag = config.isNativeTag || _vue_shared__WEBPACK_IMPORTED_MODULE_2__.NO;\n  if (isBuiltInTag(name) || appIsNativeTag(name)) {\n    warn$1(\"Do not use built-in or reserved HTML elements as component id: \" + name);\n  }\n}\nfunction isStatefulComponent(instance) {\n  return instance.vnode.shapeFlag & 4;\n}\nlet isInSSRComponentSetup = false;\nfunction setupComponent(instance, isSSR = false) {\n  isSSR && setInSSRSetupState(isSSR);\n  const {\n    props,\n    children\n  } = instance.vnode;\n  const isStateful = isStatefulComponent(instance);\n  initProps(instance, props, isStateful, isSSR);\n  initSlots(instance, children);\n  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;\n  isSSR && setInSSRSetupState(false);\n  return setupResult;\n}\nfunction setupStatefulComponent(instance, isSSR) {\n  var _a;\n  const Component = instance.type;\n  if (true) {\n    if (Component.name) {\n      validateComponentName(Component.name, instance.appContext.config);\n    }\n    if (Component.components) {\n      const names = Object.keys(Component.components);\n      for (let i = 0; i < names.length; i++) {\n        validateComponentName(names[i], instance.appContext.config);\n      }\n    }\n    if (Component.directives) {\n      const names = Object.keys(Component.directives);\n      for (let i = 0; i < names.length; i++) {\n        validateDirectiveName(names[i]);\n      }\n    }\n    if (Component.compilerOptions && isRuntimeOnly()) {\n      warn$1(`\"compilerOptions\" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`);\n    }\n  }\n  instance.accessCache = /* @__PURE__ */Object.create(null);\n  instance.proxy = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.markRaw)(new Proxy(instance.ctx, PublicInstanceProxyHandlers));\n  if (true) {\n    exposePropsOnRenderContext(instance);\n  }\n  const {\n    setup\n  } = Component;\n  if (setup) {\n    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;\n    setCurrentInstance(instance);\n    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.pauseTracking)();\n    const setupResult = callWithErrorHandling(setup, instance, 0, [ true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.shallowReadonly)(instance.props) : 0, setupContext]);\n    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.resetTracking)();\n    unsetCurrentInstance();\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isPromise)(setupResult)) {\n      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);\n      if (isSSR) {\n        return setupResult.then(resolvedResult => {\n          handleSetupResult(instance, resolvedResult, isSSR);\n        }).catch(e => {\n          handleError(e, instance, 0);\n        });\n      } else {\n        instance.asyncDep = setupResult;\n        if ( true && !instance.suspense) {\n          const name = (_a = Component.name) != null ? _a : \"Anonymous\";\n          warn$1(`Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`);\n        }\n      }\n    } else {\n      handleSetupResult(instance, setupResult, isSSR);\n    }\n  } else {\n    finishComponentSetup(instance, isSSR);\n  }\n}\nfunction handleSetupResult(instance, setupResult, isSSR) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(setupResult)) {\n    if (instance.type.__ssrInlineRender) {\n      instance.ssrRender = setupResult;\n    } else {\n      instance.render = setupResult;\n    }\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isObject)(setupResult)) {\n    if ( true && isVNode(setupResult)) {\n      warn$1(`setup() should not return VNodes directly - return a render function instead.`);\n    }\n    if (true) {\n      instance.devtoolsRawSetupState = setupResult;\n    }\n    instance.setupState = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.proxyRefs)(setupResult);\n    if (true) {\n      exposeSetupStateOnRenderContext(instance);\n    }\n  } else if ( true && setupResult !== void 0) {\n    warn$1(`setup() should return an object. Received: ${setupResult === null ? \"null\" : typeof setupResult}`);\n  }\n  finishComponentSetup(instance, isSSR);\n}\nlet compile;\nlet installWithProxy;\nfunction registerRuntimeCompiler(_compile) {\n  compile = _compile;\n  installWithProxy = i => {\n    if (i.render._rc) {\n      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);\n    }\n  };\n}\nconst isRuntimeOnly = () => !compile;\nfunction finishComponentSetup(instance, isSSR, skipOptions) {\n  const Component = instance.type;\n  if (!instance.render) {\n    if (!isSSR && compile && !Component.render) {\n      const template = Component.template || resolveMergedOptions(instance).template;\n      if (template) {\n        if (true) {\n          startMeasure(instance, `compile`);\n        }\n        const {\n          isCustomElement,\n          compilerOptions\n        } = instance.appContext.config;\n        const {\n          delimiters,\n          compilerOptions: componentCompilerOptions\n        } = Component;\n        const finalCompilerOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)({\n          isCustomElement,\n          delimiters\n        }, compilerOptions), componentCompilerOptions);\n        Component.render = compile(template, finalCompilerOptions);\n        if (true) {\n          endMeasure(instance, `compile`);\n        }\n      }\n    }\n    instance.render = Component.render || _vue_shared__WEBPACK_IMPORTED_MODULE_2__.NOOP;\n    if (installWithProxy) {\n      installWithProxy(instance);\n    }\n  }\n  if (true) {\n    setCurrentInstance(instance);\n    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.pauseTracking)();\n    try {\n      applyOptions(instance);\n    } finally {\n      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.resetTracking)();\n      unsetCurrentInstance();\n    }\n  }\n  if ( true && !Component.render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_2__.NOOP && !isSSR) {\n    if (!compile && Component.template) {\n      warn$1(`Component provided template option but runtime compilation is not supported in this build of Vue.` + ` Configure your bundler to alias \"vue\" to \"vue/dist/vue.esm-bundler.js\".`);\n    } else {\n      warn$1(`Component is missing template or render function.`);\n    }\n  }\n}\nfunction getAttrsProxy(instance) {\n  return instance.attrsProxy || (instance.attrsProxy = new Proxy(instance.attrs,  true ? {\n    get(target, key) {\n      markAttrsAccessed();\n      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.track)(instance, \"get\", \"$attrs\");\n      return target[key];\n    },\n    set() {\n      warn$1(`setupContext.attrs is readonly.`);\n      return false;\n    },\n    deleteProperty() {\n      warn$1(`setupContext.attrs is readonly.`);\n      return false;\n    }\n  } : 0));\n}\nfunction getSlotsProxy(instance) {\n  return instance.slotsProxy || (instance.slotsProxy = new Proxy(instance.slots, {\n    get(target, key) {\n      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.track)(instance, \"get\", \"$slots\");\n      return target[key];\n    }\n  }));\n}\nfunction createSetupContext(instance) {\n  const expose = exposed => {\n    if (true) {\n      if (instance.exposed) {\n        warn$1(`expose() should be called only once per setup().`);\n      }\n      if (exposed != null) {\n        let exposedType = typeof exposed;\n        if (exposedType === \"object\") {\n          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(exposed)) {\n            exposedType = \"array\";\n          } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.isRef)(exposed)) {\n            exposedType = \"ref\";\n          }\n        }\n        if (exposedType !== \"object\") {\n          warn$1(`expose() should be passed a plain object, received ${exposedType}.`);\n        }\n      }\n    }\n    instance.exposed = exposed || {};\n  };\n  if (true) {\n    return Object.freeze({\n      get attrs() {\n        return getAttrsProxy(instance);\n      },\n      get slots() {\n        return getSlotsProxy(instance);\n      },\n      get emit() {\n        return (event, ...args) => instance.emit(event, ...args);\n      },\n      expose\n    });\n  } else {}\n}\nfunction getExposeProxy(instance) {\n  if (instance.exposed) {\n    return instance.exposeProxy || (instance.exposeProxy = new Proxy((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.proxyRefs)((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.markRaw)(instance.exposed)), {\n      get(target, key) {\n        if (key in target) {\n          return target[key];\n        } else if (key in publicPropertiesMap) {\n          return publicPropertiesMap[key](instance);\n        }\n      },\n      has(target, key) {\n        return key in target || key in publicPropertiesMap;\n      }\n    }));\n  }\n}\nconst classifyRE = /(?:^|[-_])(\\w)/g;\nconst classify = str => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, \"\");\nfunction getComponentName(Component, includeInferred = true) {\n  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;\n}\nfunction formatComponentName(instance, Component, isRoot = false) {\n  let name = getComponentName(Component);\n  if (!name && Component.__file) {\n    const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/);\n    if (match) {\n      name = match[1];\n    }\n  }\n  if (!name && instance && instance.parent) {\n    const inferFromRegistry = registry => {\n      for (const key in registry) {\n        if (registry[key] === Component) {\n          return key;\n        }\n      }\n    };\n    name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);\n  }\n  return name ? classify(name) : isRoot ? `App` : `Anonymous`;\n}\nfunction isClassComponent(value) {\n  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(value) && \"__vccOpts\" in value;\n}\nconst computed = (getterOrOptions, debugOptions) => {\n  return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.computed)(getterOrOptions, debugOptions, isInSSRComponentSetup);\n};\nfunction h(type, propsOrChildren, children) {\n  const l = arguments.length;\n  if (l === 2) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isObject)(propsOrChildren) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(propsOrChildren)) {\n      if (isVNode(propsOrChildren)) {\n        return createVNode(type, null, [propsOrChildren]);\n      }\n      return createVNode(type, propsOrChildren);\n    } else {\n      return createVNode(type, null, propsOrChildren);\n    }\n  } else {\n    if (l > 3) {\n      children = Array.prototype.slice.call(arguments, 2);\n    } else if (l === 3 && isVNode(children)) {\n      children = [children];\n    }\n    return createVNode(type, propsOrChildren, children);\n  }\n}\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"]);\n}\nfunction initCustomFormatter() {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  const vueStyle = {\n    style: \"color:#3ba776\"\n  };\n  const numberStyle = {\n    style: \"color:#1677ff\"\n  };\n  const stringStyle = {\n    style: \"color:#f5222d\"\n  };\n  const keywordStyle = {\n    style: \"color:#eb2f96\"\n  };\n  const formatter = {\n    header(obj) {\n      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isObject)(obj)) {\n        return null;\n      }\n      if (obj.__isVue) {\n        return [\"div\", vueStyle, `VueInstance`];\n      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.isRef)(obj)) {\n        return [\"div\", {}, [\"span\", vueStyle, genRefFlag(obj)], \"<\", formatValue(obj.value), `>`];\n      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.isReactive)(obj)) {\n        return [\"div\", {}, [\"span\", vueStyle, isShallow(obj) ? \"ShallowReactive\" : \"Reactive\"], \"<\", formatValue(obj), `>${(0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.isReadonly)(obj) ? ` (readonly)` : ``}`];\n      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.isReadonly)(obj)) {\n        return [\"div\", {}, [\"span\", vueStyle, isShallow(obj) ? \"ShallowReadonly\" : \"Readonly\"], \"<\", formatValue(obj), \">\"];\n      }\n      return null;\n    },\n    hasBody(obj) {\n      return obj && obj.__isVue;\n    },\n    body(obj) {\n      if (obj && obj.__isVue) {\n        return [\"div\", {}, ...formatInstance(obj.$)];\n      }\n    }\n  };\n  function formatInstance(instance) {\n    const blocks = [];\n    if (instance.type.props && instance.props) {\n      blocks.push(createInstanceBlock(\"props\", (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.toRaw)(instance.props)));\n    }\n    if (instance.setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ) {\n      blocks.push(createInstanceBlock(\"setup\", instance.setupState));\n    }\n    if (instance.data !== _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ) {\n      blocks.push(createInstanceBlock(\"data\", (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.toRaw)(instance.data)));\n    }\n    const computed = extractKeys(instance, \"computed\");\n    if (computed) {\n      blocks.push(createInstanceBlock(\"computed\", computed));\n    }\n    const injected = extractKeys(instance, \"inject\");\n    if (injected) {\n      blocks.push(createInstanceBlock(\"injected\", injected));\n    }\n    blocks.push([\"div\", {}, [\"span\", {\n      style: keywordStyle.style + \";opacity:0.66\"\n    }, \"$ (internal): \"], [\"object\", {\n      object: instance\n    }]]);\n    return blocks;\n  }\n  function createInstanceBlock(type, target) {\n    target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)({}, target);\n    if (!Object.keys(target).length) {\n      return [\"span\", {}];\n    }\n    return [\"div\", {\n      style: \"line-height:1.25em;margin-bottom:0.6em\"\n    }, [\"div\", {\n      style: \"color:#476582\"\n    }, type], [\"div\", {\n      style: \"padding-left:1.25em\"\n    }, ...Object.keys(target).map(key => {\n      return [\"div\", {}, [\"span\", keywordStyle, key + \": \"], formatValue(target[key], false)];\n    })]];\n  }\n  function formatValue(v, asRaw = true) {\n    if (typeof v === \"number\") {\n      return [\"span\", numberStyle, v];\n    } else if (typeof v === \"string\") {\n      return [\"span\", stringStyle, JSON.stringify(v)];\n    } else if (typeof v === \"boolean\") {\n      return [\"span\", keywordStyle, v];\n    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isObject)(v)) {\n      return [\"object\", {\n        object: asRaw ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_1__.toRaw)(v) : v\n      }];\n    } else {\n      return [\"span\", stringStyle, String(v)];\n    }\n  }\n  function extractKeys(instance, type) {\n    const Comp = instance.type;\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(Comp)) {\n      return;\n    }\n    const extracted = {};\n    for (const key in instance.ctx) {\n      if (isKeyOfType(Comp, key, type)) {\n        extracted[key] = instance.ctx[key];\n      }\n    }\n    return extracted;\n  }\n  function isKeyOfType(Comp, key, type) {\n    const opts = Comp[type];\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(opts) && opts.includes(key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isObject)(opts) && key in opts) {\n      return true;\n    }\n    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {\n      return true;\n    }\n    if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {\n      return true;\n    }\n  }\n  function genRefFlag(v) {\n    if (isShallow(v)) {\n      return `ShallowRef`;\n    }\n    if (v.effect) {\n      return `ComputedRef`;\n    }\n    return `Ref`;\n  }\n  if (window.devtoolsFormatters) {\n    window.devtoolsFormatters.push(formatter);\n  } else {\n    window.devtoolsFormatters = [formatter];\n  }\n}\nfunction withMemo(memo, render, cache, index) {\n  const cached = cache[index];\n  if (cached && isMemoSame(cached, memo)) {\n    return cached;\n  }\n  const ret = render();\n  ret.memo = memo.slice();\n  return cache[index] = ret;\n}\nfunction isMemoSame(cached, memo) {\n  const prev = cached.memo;\n  if (prev.length != memo.length) {\n    return false;\n  }\n  for (let i = 0; i < prev.length; i++) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hasChanged)(prev[i], memo[i])) {\n      return false;\n    }\n  }\n  if (isBlockTreeEnabled > 0 && currentBlock) {\n    currentBlock.push(cached);\n  }\n  return true;\n}\nconst version = \"3.4.5\";\nconst warn =  true ? warn$1 : 0;\nconst ErrorTypeStrings = ErrorTypeStrings$1;\nconst devtools =  true ? devtools$1 : 0;\nconst setDevtoolsHook =  true ? setDevtoolsHook$1 : 0;\nconst _ssrUtils = {\n  createComponentInstance,\n  setupComponent,\n  renderComponentRoot,\n  setCurrentRenderingInstance,\n  isVNode: isVNode,\n  normalizeVNode\n};\nconst ssrUtils = _ssrUtils;\nconst resolveFilter = null;\nconst compatUtils = null;\nconst DeprecationTypes = null;\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js?");

/***/ }),

/***/ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseTransition: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.BaseTransition; },\n/* harmony export */   BaseTransitionPropsValidators: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.BaseTransitionPropsValidators; },\n/* harmony export */   Comment: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.Comment; },\n/* harmony export */   DeprecationTypes: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.DeprecationTypes; },\n/* harmony export */   EffectScope: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.EffectScope; },\n/* harmony export */   ErrorCodes: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.ErrorCodes; },\n/* harmony export */   ErrorTypeStrings: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.ErrorTypeStrings; },\n/* harmony export */   Fragment: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.Fragment; },\n/* harmony export */   KeepAlive: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.KeepAlive; },\n/* harmony export */   ReactiveEffect: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.ReactiveEffect; },\n/* harmony export */   Static: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.Static; },\n/* harmony export */   Suspense: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.Suspense; },\n/* harmony export */   Teleport: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.Teleport; },\n/* harmony export */   Text: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.Text; },\n/* harmony export */   TrackOpTypes: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.TrackOpTypes; },\n/* harmony export */   Transition: function() { return /* binding */ Transition; },\n/* harmony export */   TransitionGroup: function() { return /* binding */ TransitionGroup; },\n/* harmony export */   TriggerOpTypes: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.TriggerOpTypes; },\n/* harmony export */   VueElement: function() { return /* binding */ VueElement; },\n/* harmony export */   assertNumber: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.assertNumber; },\n/* harmony export */   callWithAsyncErrorHandling: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.callWithAsyncErrorHandling; },\n/* harmony export */   callWithErrorHandling: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.callWithErrorHandling; },\n/* harmony export */   camelize: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.camelize; },\n/* harmony export */   capitalize: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.capitalize; },\n/* harmony export */   cloneVNode: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.cloneVNode; },\n/* harmony export */   compatUtils: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.compatUtils; },\n/* harmony export */   computed: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.computed; },\n/* harmony export */   createApp: function() { return /* binding */ createApp; },\n/* harmony export */   createBlock: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.createBlock; },\n/* harmony export */   createCommentVNode: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.createCommentVNode; },\n/* harmony export */   createElementBlock: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.createElementBlock; },\n/* harmony export */   createElementVNode: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.createElementVNode; },\n/* harmony export */   createHydrationRenderer: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.createHydrationRenderer; },\n/* harmony export */   createPropsRestProxy: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.createPropsRestProxy; },\n/* harmony export */   createRenderer: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.createRenderer; },\n/* harmony export */   createSSRApp: function() { return /* binding */ createSSRApp; },\n/* harmony export */   createSlots: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.createSlots; },\n/* harmony export */   createStaticVNode: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.createStaticVNode; },\n/* harmony export */   createTextVNode: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.createTextVNode; },\n/* harmony export */   createVNode: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.createVNode; },\n/* harmony export */   customRef: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.customRef; },\n/* harmony export */   defineAsyncComponent: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.defineAsyncComponent; },\n/* harmony export */   defineComponent: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.defineComponent; },\n/* harmony export */   defineCustomElement: function() { return /* binding */ defineCustomElement; },\n/* harmony export */   defineEmits: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.defineEmits; },\n/* harmony export */   defineExpose: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.defineExpose; },\n/* harmony export */   defineModel: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.defineModel; },\n/* harmony export */   defineOptions: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.defineOptions; },\n/* harmony export */   defineProps: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.defineProps; },\n/* harmony export */   defineSSRCustomElement: function() { return /* binding */ defineSSRCustomElement; },\n/* harmony export */   defineSlots: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.defineSlots; },\n/* harmony export */   devtools: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.devtools; },\n/* harmony export */   effect: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.effect; },\n/* harmony export */   effectScope: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.effectScope; },\n/* harmony export */   getCurrentInstance: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.getCurrentInstance; },\n/* harmony export */   getCurrentScope: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.getCurrentScope; },\n/* harmony export */   getTransitionRawChildren: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.getTransitionRawChildren; },\n/* harmony export */   guardReactiveProps: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.guardReactiveProps; },\n/* harmony export */   h: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.h; },\n/* harmony export */   handleError: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.handleError; },\n/* harmony export */   hasInjectionContext: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.hasInjectionContext; },\n/* harmony export */   hydrate: function() { return /* binding */ hydrate; },\n/* harmony export */   initCustomFormatter: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.initCustomFormatter; },\n/* harmony export */   initDirectivesForSSR: function() { return /* binding */ initDirectivesForSSR; },\n/* harmony export */   inject: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.inject; },\n/* harmony export */   isMemoSame: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.isMemoSame; },\n/* harmony export */   isProxy: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.isProxy; },\n/* harmony export */   isReactive: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.isReactive; },\n/* harmony export */   isReadonly: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.isReadonly; },\n/* harmony export */   isRef: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.isRef; },\n/* harmony export */   isRuntimeOnly: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.isRuntimeOnly; },\n/* harmony export */   isShallow: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.isShallow; },\n/* harmony export */   isVNode: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.isVNode; },\n/* harmony export */   markRaw: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.markRaw; },\n/* harmony export */   mergeDefaults: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.mergeDefaults; },\n/* harmony export */   mergeModels: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.mergeModels; },\n/* harmony export */   mergeProps: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.mergeProps; },\n/* harmony export */   nextTick: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.nextTick; },\n/* harmony export */   normalizeClass: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.normalizeClass; },\n/* harmony export */   normalizeProps: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.normalizeProps; },\n/* harmony export */   normalizeStyle: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle; },\n/* harmony export */   onActivated: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.onActivated; },\n/* harmony export */   onBeforeMount: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.onBeforeMount; },\n/* harmony export */   onBeforeUnmount: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.onBeforeUnmount; },\n/* harmony export */   onBeforeUpdate: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.onBeforeUpdate; },\n/* harmony export */   onDeactivated: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.onDeactivated; },\n/* harmony export */   onErrorCaptured: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.onErrorCaptured; },\n/* harmony export */   onMounted: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.onMounted; },\n/* harmony export */   onRenderTracked: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.onRenderTracked; },\n/* harmony export */   onRenderTriggered: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.onRenderTriggered; },\n/* harmony export */   onScopeDispose: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.onScopeDispose; },\n/* harmony export */   onServerPrefetch: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.onServerPrefetch; },\n/* harmony export */   onUnmounted: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.onUnmounted; },\n/* harmony export */   onUpdated: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.onUpdated; },\n/* harmony export */   openBlock: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.openBlock; },\n/* harmony export */   popScopeId: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.popScopeId; },\n/* harmony export */   provide: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.provide; },\n/* harmony export */   proxyRefs: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.proxyRefs; },\n/* harmony export */   pushScopeId: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.pushScopeId; },\n/* harmony export */   queuePostFlushCb: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.queuePostFlushCb; },\n/* harmony export */   reactive: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.reactive; },\n/* harmony export */   readonly: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.readonly; },\n/* harmony export */   ref: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.ref; },\n/* harmony export */   registerRuntimeCompiler: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.registerRuntimeCompiler; },\n/* harmony export */   render: function() { return /* binding */ render; },\n/* harmony export */   renderList: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.renderList; },\n/* harmony export */   renderSlot: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.renderSlot; },\n/* harmony export */   resolveComponent: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.resolveComponent; },\n/* harmony export */   resolveDirective: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.resolveDirective; },\n/* harmony export */   resolveDynamicComponent: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.resolveDynamicComponent; },\n/* harmony export */   resolveFilter: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.resolveFilter; },\n/* harmony export */   resolveTransitionHooks: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.resolveTransitionHooks; },\n/* harmony export */   setBlockTracking: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.setBlockTracking; },\n/* harmony export */   setDevtoolsHook: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.setDevtoolsHook; },\n/* harmony export */   setTransitionHooks: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.setTransitionHooks; },\n/* harmony export */   shallowReactive: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.shallowReactive; },\n/* harmony export */   shallowReadonly: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.shallowReadonly; },\n/* harmony export */   shallowRef: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.shallowRef; },\n/* harmony export */   ssrContextKey: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.ssrContextKey; },\n/* harmony export */   ssrUtils: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.ssrUtils; },\n/* harmony export */   stop: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.stop; },\n/* harmony export */   toDisplayString: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.toDisplayString; },\n/* harmony export */   toHandlerKey: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey; },\n/* harmony export */   toHandlers: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.toHandlers; },\n/* harmony export */   toRaw: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.toRaw; },\n/* harmony export */   toRef: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.toRef; },\n/* harmony export */   toRefs: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.toRefs; },\n/* harmony export */   toValue: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.toValue; },\n/* harmony export */   transformVNodeArgs: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.transformVNodeArgs; },\n/* harmony export */   triggerRef: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.triggerRef; },\n/* harmony export */   unref: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.unref; },\n/* harmony export */   useAttrs: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.useAttrs; },\n/* harmony export */   useCssModule: function() { return /* binding */ useCssModule; },\n/* harmony export */   useCssVars: function() { return /* binding */ useCssVars; },\n/* harmony export */   useModel: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.useModel; },\n/* harmony export */   useSSRContext: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.useSSRContext; },\n/* harmony export */   useSlots: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.useSlots; },\n/* harmony export */   useTransitionState: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.useTransitionState; },\n/* harmony export */   vModelCheckbox: function() { return /* binding */ vModelCheckbox; },\n/* harmony export */   vModelDynamic: function() { return /* binding */ vModelDynamic; },\n/* harmony export */   vModelRadio: function() { return /* binding */ vModelRadio; },\n/* harmony export */   vModelSelect: function() { return /* binding */ vModelSelect; },\n/* harmony export */   vModelText: function() { return /* binding */ vModelText; },\n/* harmony export */   vShow: function() { return /* binding */ vShow; },\n/* harmony export */   version: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.version; },\n/* harmony export */   warn: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.warn; },\n/* harmony export */   watch: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.watch; },\n/* harmony export */   watchEffect: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.watchEffect; },\n/* harmony export */   watchPostEffect: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.watchPostEffect; },\n/* harmony export */   watchSyncEffect: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.watchSyncEffect; },\n/* harmony export */   withAsyncContext: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.withAsyncContext; },\n/* harmony export */   withCtx: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.withCtx; },\n/* harmony export */   withDefaults: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.withDefaults; },\n/* harmony export */   withDirectives: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.withDirectives; },\n/* harmony export */   withKeys: function() { return /* binding */ withKeys; },\n/* harmony export */   withMemo: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.withMemo; },\n/* harmony export */   withModifiers: function() { return /* binding */ withModifiers; },\n/* harmony export */   withScopeId: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.withScopeId; }\n/* harmony export */ });\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.push.js */ \"./node_modules/core-js/modules/es.array.push.js\");\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/runtime-core */ \"./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js\");\n/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/shared */ \"./node_modules/@vue/shared/dist/shared.esm-bundler.js\");\n/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vue/runtime-core */ \"./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js\");\n\n\n\n\nconst svgNS = \"http://www.w3.org/2000/svg\";\nconst mathmlNS = \"http://www.w3.org/1998/Math/MathML\";\nconst doc = typeof document !== \"undefined\" ? document : null;\nconst templateContainer = doc && /* @__PURE__ */doc.createElement(\"template\");\nconst nodeOps = {\n  insert: (child, parent, anchor) => {\n    parent.insertBefore(child, anchor || null);\n  },\n  remove: child => {\n    const parent = child.parentNode;\n    if (parent) {\n      parent.removeChild(child);\n    }\n  },\n  createElement: (tag, namespace, is, props) => {\n    const el = namespace === \"svg\" ? doc.createElementNS(svgNS, tag) : namespace === \"mathml\" ? doc.createElementNS(mathmlNS, tag) : doc.createElement(tag, is ? {\n      is\n    } : void 0);\n    if (tag === \"select\" && props && props.multiple != null) {\n      el.setAttribute(\"multiple\", props.multiple);\n    }\n    return el;\n  },\n  createText: text => doc.createTextNode(text),\n  createComment: text => doc.createComment(text),\n  setText: (node, text) => {\n    node.nodeValue = text;\n  },\n  setElementText: (el, text) => {\n    el.textContent = text;\n  },\n  parentNode: node => node.parentNode,\n  nextSibling: node => node.nextSibling,\n  querySelector: selector => doc.querySelector(selector),\n  setScopeId(el, id) {\n    el.setAttribute(id, \"\");\n  },\n  // __UNSAFE__\n  // Reason: innerHTML.\n  // Static content here can only come from compiled templates.\n  // As long as the user only uses trusted templates, this is safe.\n  insertStaticContent(content, parent, anchor, namespace, start, end) {\n    const before = anchor ? anchor.previousSibling : parent.lastChild;\n    if (start && (start === end || start.nextSibling)) {\n      while (true) {\n        parent.insertBefore(start.cloneNode(true), anchor);\n        if (start === end || !(start = start.nextSibling)) break;\n      }\n    } else {\n      templateContainer.innerHTML = namespace === \"svg\" ? `<svg>${content}</svg>` : namespace === \"mathml\" ? `<math>${content}</math>` : content;\n      const template = templateContainer.content;\n      if (namespace === \"svg\" || namespace === \"mathml\") {\n        const wrapper = template.firstChild;\n        while (wrapper.firstChild) {\n          template.appendChild(wrapper.firstChild);\n        }\n        template.removeChild(wrapper);\n      }\n      parent.insertBefore(template, anchor);\n    }\n    return [\n    // first\n    before ? before.nextSibling : parent.firstChild,\n    // last\n    anchor ? anchor.previousSibling : parent.lastChild];\n  }\n};\nconst TRANSITION = \"transition\";\nconst ANIMATION = \"animation\";\nconst vtcKey = Symbol(\"_vtc\");\nconst Transition = (props, {\n  slots\n}) => (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.h)(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.BaseTransition, resolveTransitionProps(props), slots);\nTransition.displayName = \"Transition\";\nconst DOMTransitionPropsValidators = {\n  name: String,\n  type: String,\n  css: {\n    type: Boolean,\n    default: true\n  },\n  duration: [String, Number, Object],\n  enterFromClass: String,\n  enterActiveClass: String,\n  enterToClass: String,\n  appearFromClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  leaveFromClass: String,\n  leaveActiveClass: String,\n  leaveToClass: String\n};\nconst TransitionPropsValidators = Transition.props = /* @__PURE__ */(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)({}, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.BaseTransitionPropsValidators, DOMTransitionPropsValidators);\nconst callHook = (hook, args = []) => {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(hook)) {\n    hook.forEach(h2 => h2(...args));\n  } else if (hook) {\n    hook(...args);\n  }\n};\nconst hasExplicitCallback = hook => {\n  return hook ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(hook) ? hook.some(h2 => h2.length > 1) : hook.length > 1 : false;\n};\nfunction resolveTransitionProps(rawProps) {\n  const baseProps = {};\n  for (const key in rawProps) {\n    if (!(key in DOMTransitionPropsValidators)) {\n      baseProps[key] = rawProps[key];\n    }\n  }\n  if (rawProps.css === false) {\n    return baseProps;\n  }\n  const {\n    name = \"v\",\n    type,\n    duration,\n    enterFromClass = `${name}-enter-from`,\n    enterActiveClass = `${name}-enter-active`,\n    enterToClass = `${name}-enter-to`,\n    appearFromClass = enterFromClass,\n    appearActiveClass = enterActiveClass,\n    appearToClass = enterToClass,\n    leaveFromClass = `${name}-leave-from`,\n    leaveActiveClass = `${name}-leave-active`,\n    leaveToClass = `${name}-leave-to`\n  } = rawProps;\n  const durations = normalizeDuration(duration);\n  const enterDuration = durations && durations[0];\n  const leaveDuration = durations && durations[1];\n  const {\n    onBeforeEnter,\n    onEnter,\n    onEnterCancelled,\n    onLeave,\n    onLeaveCancelled,\n    onBeforeAppear = onBeforeEnter,\n    onAppear = onEnter,\n    onAppearCancelled = onEnterCancelled\n  } = baseProps;\n  const finishEnter = (el, isAppear, done) => {\n    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);\n    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);\n    done && done();\n  };\n  const finishLeave = (el, done) => {\n    el._isLeaving = false;\n    removeTransitionClass(el, leaveFromClass);\n    removeTransitionClass(el, leaveToClass);\n    removeTransitionClass(el, leaveActiveClass);\n    done && done();\n  };\n  const makeEnterHook = isAppear => {\n    return (el, done) => {\n      const hook = isAppear ? onAppear : onEnter;\n      const resolve = () => finishEnter(el, isAppear, done);\n      callHook(hook, [el, resolve]);\n      nextFrame(() => {\n        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);\n        addTransitionClass(el, isAppear ? appearToClass : enterToClass);\n        if (!hasExplicitCallback(hook)) {\n          whenTransitionEnds(el, type, enterDuration, resolve);\n        }\n      });\n    };\n  };\n  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)(baseProps, {\n    onBeforeEnter(el) {\n      callHook(onBeforeEnter, [el]);\n      addTransitionClass(el, enterFromClass);\n      addTransitionClass(el, enterActiveClass);\n    },\n    onBeforeAppear(el) {\n      callHook(onBeforeAppear, [el]);\n      addTransitionClass(el, appearFromClass);\n      addTransitionClass(el, appearActiveClass);\n    },\n    onEnter: makeEnterHook(false),\n    onAppear: makeEnterHook(true),\n    onLeave(el, done) {\n      el._isLeaving = true;\n      const resolve = () => finishLeave(el, done);\n      addTransitionClass(el, leaveFromClass);\n      forceReflow();\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(() => {\n        if (!el._isLeaving) {\n          return;\n        }\n        removeTransitionClass(el, leaveFromClass);\n        addTransitionClass(el, leaveToClass);\n        if (!hasExplicitCallback(onLeave)) {\n          whenTransitionEnds(el, type, leaveDuration, resolve);\n        }\n      });\n      callHook(onLeave, [el, resolve]);\n    },\n    onEnterCancelled(el) {\n      finishEnter(el, false);\n      callHook(onEnterCancelled, [el]);\n    },\n    onAppearCancelled(el) {\n      finishEnter(el, true);\n      callHook(onAppearCancelled, [el]);\n    },\n    onLeaveCancelled(el) {\n      finishLeave(el);\n      callHook(onLeaveCancelled, [el]);\n    }\n  });\n}\nfunction normalizeDuration(duration) {\n  if (duration == null) {\n    return null;\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isObject)(duration)) {\n    return [NumberOf(duration.enter), NumberOf(duration.leave)];\n  } else {\n    const n = NumberOf(duration);\n    return [n, n];\n  }\n}\nfunction NumberOf(val) {\n  const res = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.toNumber)(val);\n  if (true) {\n    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(res, \"<transition> explicit duration\");\n  }\n  return res;\n}\nfunction addTransitionClass(el, cls) {\n  cls.split(/\\s+/).forEach(c => c && el.classList.add(c));\n  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */new Set())).add(cls);\n}\nfunction removeTransitionClass(el, cls) {\n  cls.split(/\\s+/).forEach(c => c && el.classList.remove(c));\n  const _vtc = el[vtcKey];\n  if (_vtc) {\n    _vtc.delete(cls);\n    if (!_vtc.size) {\n      el[vtcKey] = void 0;\n    }\n  }\n}\nfunction nextFrame(cb) {\n  requestAnimationFrame(() => {\n    requestAnimationFrame(cb);\n  });\n}\nlet endId = 0;\nfunction whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {\n  const id = el._endId = ++endId;\n  const resolveIfNotStale = () => {\n    if (id === el._endId) {\n      resolve();\n    }\n  };\n  if (explicitTimeout) {\n    return setTimeout(resolveIfNotStale, explicitTimeout);\n  }\n  const {\n    type,\n    timeout,\n    propCount\n  } = getTransitionInfo(el, expectedType);\n  if (!type) {\n    return resolve();\n  }\n  const endEvent = type + \"end\";\n  let ended = 0;\n  const end = () => {\n    el.removeEventListener(endEvent, onEnd);\n    resolveIfNotStale();\n  };\n  const onEnd = e => {\n    if (e.target === el && ++ended >= propCount) {\n      end();\n    }\n  };\n  setTimeout(() => {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(endEvent, onEnd);\n}\nfunction getTransitionInfo(el, expectedType) {\n  const styles = window.getComputedStyle(el);\n  const getStyleProperties = key => (styles[key] || \"\").split(\", \");\n  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);\n  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);\n  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);\n  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);\n  const animationTimeout = getTimeout(animationDelays, animationDurations);\n  let type = null;\n  let timeout = 0;\n  let propCount = 0;\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n  }\n  const hasTransform = type === TRANSITION && /\\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION}Property`).toString());\n  return {\n    type,\n    timeout,\n    propCount,\n    hasTransform\n  };\n}\nfunction getTimeout(delays, durations) {\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));\n}\nfunction toMs(s) {\n  if (s === \"auto\") return 0;\n  return Number(s.slice(0, -1).replace(\",\", \".\")) * 1e3;\n}\nfunction forceReflow() {\n  return document.body.offsetHeight;\n}\nfunction patchClass(el, value, isSVG) {\n  const transitionClasses = el[vtcKey];\n  if (transitionClasses) {\n    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(\" \");\n  }\n  if (value == null) {\n    el.removeAttribute(\"class\");\n  } else if (isSVG) {\n    el.setAttribute(\"class\", value);\n  } else {\n    el.className = value;\n  }\n}\nconst vShowOldKey = Symbol(\"_vod\");\nconst vShow = {\n  beforeMount(el, {\n    value\n  }, {\n    transition\n  }) {\n    el[vShowOldKey] = el.style.display === \"none\" ? \"\" : el.style.display;\n    if (transition && value) {\n      transition.beforeEnter(el);\n    } else {\n      setDisplay(el, value);\n    }\n  },\n  mounted(el, {\n    value\n  }, {\n    transition\n  }) {\n    if (transition && value) {\n      transition.enter(el);\n    }\n  },\n  updated(el, {\n    value,\n    oldValue\n  }, {\n    transition\n  }) {\n    if (!value === !oldValue) return;\n    if (transition) {\n      if (value) {\n        transition.beforeEnter(el);\n        setDisplay(el, true);\n        transition.enter(el);\n      } else {\n        transition.leave(el, () => {\n          setDisplay(el, false);\n        });\n      }\n    } else {\n      setDisplay(el, value);\n    }\n  },\n  beforeUnmount(el, {\n    value\n  }) {\n    setDisplay(el, value);\n  }\n};\nfunction setDisplay(el, value) {\n  el.style.display = value ? el[vShowOldKey] : \"none\";\n}\nfunction initVShowForSSR() {\n  vShow.getSSRProps = ({\n    value\n  }) => {\n    if (!value) {\n      return {\n        style: {\n          display: \"none\"\n        }\n      };\n    }\n  };\n}\nconst CSS_VAR_TEXT = Symbol( true ? \"CSS_VAR_TEXT\" : 0);\nfunction useCssVars(getter) {\n  const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.getCurrentInstance)();\n  if (!instance) {\n     true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.warn)(`useCssVars is called without current active component instance.`);\n    return;\n  }\n  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {\n    Array.from(document.querySelectorAll(`[data-v-owner=\"${instance.uid}\"]`)).forEach(node => setVarsOnNode(node, vars));\n  };\n  const setVars = () => {\n    const vars = getter(instance.proxy);\n    setVarsOnVNode(instance.subTree, vars);\n    updateTeleports(vars);\n  };\n  (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.watchPostEffect)(setVars);\n  (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.onMounted)(() => {\n    const ob = new MutationObserver(setVars);\n    ob.observe(instance.subTree.el.parentNode, {\n      childList: true\n    });\n    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.onUnmounted)(() => ob.disconnect());\n  });\n}\nfunction setVarsOnVNode(vnode, vars) {\n  if (vnode.shapeFlag & 128) {\n    const suspense = vnode.suspense;\n    vnode = suspense.activeBranch;\n    if (suspense.pendingBranch && !suspense.isHydrating) {\n      suspense.effects.push(() => {\n        setVarsOnVNode(suspense.activeBranch, vars);\n      });\n    }\n  }\n  while (vnode.component) {\n    vnode = vnode.component.subTree;\n  }\n  if (vnode.shapeFlag & 1 && vnode.el) {\n    setVarsOnNode(vnode.el, vars);\n  } else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.Fragment) {\n    vnode.children.forEach(c => setVarsOnVNode(c, vars));\n  } else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.Static) {\n    let {\n      el,\n      anchor\n    } = vnode;\n    while (el) {\n      setVarsOnNode(el, vars);\n      if (el === anchor) break;\n      el = el.nextSibling;\n    }\n  }\n}\nfunction setVarsOnNode(el, vars) {\n  if (el.nodeType === 1) {\n    const style = el.style;\n    let cssText = \"\";\n    for (const key in vars) {\n      style.setProperty(`--${key}`, vars[key]);\n      cssText += `--${key}: ${vars[key]};`;\n    }\n    style[CSS_VAR_TEXT] = cssText;\n  }\n}\nfunction patchStyle(el, prev, next) {\n  const style = el.style;\n  const isCssString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isString)(next);\n  if (next && !isCssString) {\n    if (prev && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isString)(prev)) {\n      for (const key in prev) {\n        if (next[key] == null) {\n          setStyle(style, key, \"\");\n        }\n      }\n    }\n    for (const key in next) {\n      setStyle(style, key, next[key]);\n    }\n  } else {\n    const currentDisplay = style.display;\n    if (isCssString) {\n      if (prev !== next) {\n        const cssVarText = style[CSS_VAR_TEXT];\n        if (cssVarText) {\n          next += \";\" + cssVarText;\n        }\n        style.cssText = next;\n      }\n    } else if (prev) {\n      el.removeAttribute(\"style\");\n    }\n    if (vShowOldKey in el) {\n      style.display = currentDisplay;\n    }\n  }\n}\nconst semicolonRE = /[^\\\\];\\s*$/;\nconst importantRE = /\\s*!important$/;\nfunction setStyle(style, name, val) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(val)) {\n    val.forEach(v => setStyle(style, name, v));\n  } else {\n    if (val == null) val = \"\";\n    if (true) {\n      if (semicolonRE.test(val)) {\n        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.warn)(`Unexpected semicolon at the end of '${name}' style value: '${val}'`);\n      }\n    }\n    if (name.startsWith(\"--\")) {\n      style.setProperty(name, val);\n    } else {\n      const prefixed = autoPrefix(style, name);\n      if (importantRE.test(val)) {\n        style.setProperty((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hyphenate)(prefixed), val.replace(importantRE, \"\"), \"important\");\n      } else {\n        style[prefixed] = val;\n      }\n    }\n  }\n}\nconst prefixes = [\"Webkit\", \"Moz\", \"ms\"];\nconst prefixCache = {};\nfunction autoPrefix(style, rawName) {\n  const cached = prefixCache[rawName];\n  if (cached) {\n    return cached;\n  }\n  let name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.camelize)(rawName);\n  if (name !== \"filter\" && name in style) {\n    return prefixCache[rawName] = name;\n  }\n  name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.capitalize)(name);\n  for (let i = 0; i < prefixes.length; i++) {\n    const prefixed = prefixes[i] + name;\n    if (prefixed in style) {\n      return prefixCache[rawName] = prefixed;\n    }\n  }\n  return rawName;\n}\nconst xlinkNS = \"http://www.w3.org/1999/xlink\";\nfunction patchAttr(el, key, value, isSVG, instance) {\n  if (isSVG && key.startsWith(\"xlink:\")) {\n    if (value == null) {\n      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    const isBoolean = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isSpecialBooleanAttr)(key);\n    if (value == null || isBoolean && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.includeBooleanAttr)(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, isBoolean ? \"\" : value);\n    }\n  }\n}\nfunction patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {\n  if (key === \"innerHTML\" || key === \"textContent\") {\n    if (prevChildren) {\n      unmountChildren(prevChildren, parentComponent, parentSuspense);\n    }\n    el[key] = value == null ? \"\" : value;\n    return;\n  }\n  const tag = el.tagName;\n  if (key === \"value\" && tag !== \"PROGRESS\" &&\n  // custom elements may use _value internally\n  !tag.includes(\"-\")) {\n    el._value = value;\n    const oldValue = tag === \"OPTION\" ? el.getAttribute(\"value\") : el.value;\n    const newValue = value == null ? \"\" : value;\n    if (oldValue !== newValue) {\n      el.value = newValue;\n    }\n    if (value == null) {\n      el.removeAttribute(key);\n    }\n    return;\n  }\n  let needRemove = false;\n  if (value === \"\" || value == null) {\n    const type = typeof el[key];\n    if (type === \"boolean\") {\n      value = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.includeBooleanAttr)(value);\n    } else if (value == null && type === \"string\") {\n      value = \"\";\n      needRemove = true;\n    } else if (type === \"number\") {\n      value = 0;\n      needRemove = true;\n    }\n  }\n  try {\n    el[key] = value;\n  } catch (e) {\n    if ( true && !needRemove) {\n      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.warn)(`Failed setting prop \"${key}\" on <${tag.toLowerCase()}>: value ${value} is invalid.`, e);\n    }\n  }\n  needRemove && el.removeAttribute(key);\n}\nfunction addEventListener(el, event, handler, options) {\n  el.addEventListener(event, handler, options);\n}\nfunction removeEventListener(el, event, handler, options) {\n  el.removeEventListener(event, handler, options);\n}\nconst veiKey = Symbol(\"_vei\");\nfunction patchEvent(el, rawName, prevValue, nextValue, instance = null) {\n  const invokers = el[veiKey] || (el[veiKey] = {});\n  const existingInvoker = invokers[rawName];\n  if (nextValue && existingInvoker) {\n    existingInvoker.value = nextValue;\n  } else {\n    const [name, options] = parseName(rawName);\n    if (nextValue) {\n      const invoker = invokers[rawName] = createInvoker(nextValue, instance);\n      addEventListener(el, name, invoker, options);\n    } else if (existingInvoker) {\n      removeEventListener(el, name, existingInvoker, options);\n      invokers[rawName] = void 0;\n    }\n  }\n}\nconst optionsModifierRE = /(?:Once|Passive|Capture)$/;\nfunction parseName(name) {\n  let options;\n  if (optionsModifierRE.test(name)) {\n    options = {};\n    let m;\n    while (m = name.match(optionsModifierRE)) {\n      name = name.slice(0, name.length - m[0].length);\n      options[m[0].toLowerCase()] = true;\n    }\n  }\n  const event = name[2] === \":\" ? name.slice(3) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hyphenate)(name.slice(2));\n  return [event, options];\n}\nlet cachedNow = 0;\nconst p = /* @__PURE__ */Promise.resolve();\nconst getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());\nfunction createInvoker(initialValue, instance) {\n  const invoker = e => {\n    if (!e._vts) {\n      e._vts = Date.now();\n    } else if (e._vts <= invoker.attached) {\n      return;\n    }\n    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.callWithAsyncErrorHandling)(patchStopImmediatePropagation(e, invoker.value), instance, 5, [e]);\n  };\n  invoker.value = initialValue;\n  invoker.attached = getNow();\n  return invoker;\n}\nfunction patchStopImmediatePropagation(e, value) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(value)) {\n    const originalStop = e.stopImmediatePropagation;\n    e.stopImmediatePropagation = () => {\n      originalStop.call(e);\n      e._stopped = true;\n    };\n    return value.map(fn => e2 => !e2._stopped && fn && fn(e2));\n  } else {\n    return value;\n  }\n}\nconst isNativeOn = key => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 &&\n// lowercase letter\nkey.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;\nconst patchProp = (el, key, prevValue, nextValue, namespace, prevChildren, parentComponent, parentSuspense, unmountChildren) => {\n  const isSVG = namespace === \"svg\";\n  if (key === \"class\") {\n    patchClass(el, nextValue, isSVG);\n  } else if (key === \"style\") {\n    patchStyle(el, prevValue, nextValue);\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isOn)(key)) {\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isModelListener)(key)) {\n      patchEvent(el, key, prevValue, nextValue, parentComponent);\n    }\n  } else if (key[0] === \".\" ? (key = key.slice(1), true) : key[0] === \"^\" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {\n    patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);\n  } else {\n    if (key === \"true-value\") {\n      el._trueValue = nextValue;\n    } else if (key === \"false-value\") {\n      el._falseValue = nextValue;\n    }\n    patchAttr(el, key, nextValue, isSVG);\n  }\n};\nfunction shouldSetAsProp(el, key, value, isSVG) {\n  if (isSVG) {\n    if (key === \"innerHTML\" || key === \"textContent\") {\n      return true;\n    }\n    if (key in el && isNativeOn(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(value)) {\n      return true;\n    }\n    return false;\n  }\n  if (key === \"spellcheck\" || key === \"draggable\" || key === \"translate\") {\n    return false;\n  }\n  if (key === \"form\") {\n    return false;\n  }\n  if (key === \"list\" && el.tagName === \"INPUT\") {\n    return false;\n  }\n  if (key === \"type\" && el.tagName === \"TEXTAREA\") {\n    return false;\n  }\n  if (key === \"width\" || key === \"height\") {\n    const tag = el.tagName;\n    if (tag === \"IMG\" || tag === \"VIDEO\" || tag === \"CANVAS\" || tag === \"SOURCE\") {\n      return false;\n    }\n  }\n  if (isNativeOn(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isString)(value)) {\n    return false;\n  }\n  return key in el;\n}\n\n/*! #__NO_SIDE_EFFECTS__ */\n// @__NO_SIDE_EFFECTS__\nfunction defineCustomElement(options, hydrate2) {\n  const Comp = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.defineComponent)(options);\n  class VueCustomElement extends VueElement {\n    constructor(initialProps) {\n      super(Comp, initialProps, hydrate2);\n    }\n  }\n  VueCustomElement.def = Comp;\n  return VueCustomElement;\n}\n/*! #__NO_SIDE_EFFECTS__ */\nconst defineSSRCustomElement = /* @__NO_SIDE_EFFECTS__ */options => {\n  return /* @__PURE__ */defineCustomElement(options, hydrate);\n};\nconst BaseClass = typeof HTMLElement !== \"undefined\" ? HTMLElement : class {};\nclass VueElement extends BaseClass {\n  constructor(_def, _props = {}, hydrate2) {\n    super();\n    this._def = _def;\n    this._props = _props;\n    /**\n     * @internal\n     */\n    this._instance = null;\n    this._connected = false;\n    this._resolved = false;\n    this._numberProps = null;\n    this._ob = null;\n    if (this.shadowRoot && hydrate2) {\n      hydrate2(this._createVNode(), this.shadowRoot);\n    } else {\n      if ( true && this.shadowRoot) {\n        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.warn)(`Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use \\`defineSSRCustomElement\\`.`);\n      }\n      this.attachShadow({\n        mode: \"open\"\n      });\n      if (!this._def.__asyncLoader) {\n        this._resolveProps(this._def);\n      }\n    }\n  }\n  connectedCallback() {\n    this._connected = true;\n    if (!this._instance) {\n      if (this._resolved) {\n        this._update();\n      } else {\n        this._resolveDef();\n      }\n    }\n  }\n  disconnectedCallback() {\n    this._connected = false;\n    if (this._ob) {\n      this._ob.disconnect();\n      this._ob = null;\n    }\n    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.nextTick)(() => {\n      if (!this._connected) {\n        render(null, this.shadowRoot);\n        this._instance = null;\n      }\n    });\n  }\n  /**\n   * resolve inner component definition (handle possible async component)\n   */\n  _resolveDef() {\n    this._resolved = true;\n    for (let i = 0; i < this.attributes.length; i++) {\n      this._setAttr(this.attributes[i].name);\n    }\n    this._ob = new MutationObserver(mutations => {\n      for (const m of mutations) {\n        this._setAttr(m.attributeName);\n      }\n    });\n    this._ob.observe(this, {\n      attributes: true\n    });\n    const resolve = (def, isAsync = false) => {\n      const {\n        props,\n        styles\n      } = def;\n      let numberProps;\n      if (props && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(props)) {\n        for (const key in props) {\n          const opt = props[key];\n          if (opt === Number || opt && opt.type === Number) {\n            if (key in this._props) {\n              this._props[key] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.toNumber)(this._props[key]);\n            }\n            (numberProps || (numberProps = /* @__PURE__ */Object.create(null)))[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.camelize)(key)] = true;\n          }\n        }\n      }\n      this._numberProps = numberProps;\n      if (isAsync) {\n        this._resolveProps(def);\n      }\n      this._applyStyles(styles);\n      this._update();\n    };\n    const asyncDef = this._def.__asyncLoader;\n    if (asyncDef) {\n      asyncDef().then(def => resolve(def, true));\n    } else {\n      resolve(this._def);\n    }\n  }\n  _resolveProps(def) {\n    const {\n      props\n    } = def;\n    const declaredPropKeys = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(props) ? props : Object.keys(props || {});\n    for (const key of Object.keys(this)) {\n      if (key[0] !== \"_\" && declaredPropKeys.includes(key)) {\n        this._setProp(key, this[key], true, false);\n      }\n    }\n    for (const key of declaredPropKeys.map(_vue_shared__WEBPACK_IMPORTED_MODULE_2__.camelize)) {\n      Object.defineProperty(this, key, {\n        get() {\n          return this._getProp(key);\n        },\n        set(val) {\n          this._setProp(key, val);\n        }\n      });\n    }\n  }\n  _setAttr(key) {\n    let value = this.getAttribute(key);\n    const camelKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.camelize)(key);\n    if (this._numberProps && this._numberProps[camelKey]) {\n      value = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.toNumber)(value);\n    }\n    this._setProp(camelKey, value, false);\n  }\n  /**\n   * @internal\n   */\n  _getProp(key) {\n    return this._props[key];\n  }\n  /**\n   * @internal\n   */\n  _setProp(key, val, shouldReflect = true, shouldUpdate = true) {\n    if (val !== this._props[key]) {\n      this._props[key] = val;\n      if (shouldUpdate && this._instance) {\n        this._update();\n      }\n      if (shouldReflect) {\n        if (val === true) {\n          this.setAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hyphenate)(key), \"\");\n        } else if (typeof val === \"string\" || typeof val === \"number\") {\n          this.setAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hyphenate)(key), val + \"\");\n        } else if (!val) {\n          this.removeAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hyphenate)(key));\n        }\n      }\n    }\n  }\n  _update() {\n    render(this._createVNode(), this.shadowRoot);\n  }\n  _createVNode() {\n    const vnode = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.createVNode)(this._def, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)({}, this._props));\n    if (!this._instance) {\n      vnode.ce = instance => {\n        this._instance = instance;\n        instance.isCE = true;\n        if (true) {\n          instance.ceReload = newStyles => {\n            if (this._styles) {\n              this._styles.forEach(s => this.shadowRoot.removeChild(s));\n              this._styles.length = 0;\n            }\n            this._applyStyles(newStyles);\n            this._instance = null;\n            this._update();\n          };\n        }\n        const dispatch = (event, args) => {\n          this.dispatchEvent(new CustomEvent(event, {\n            detail: args\n          }));\n        };\n        instance.emit = (event, ...args) => {\n          dispatch(event, args);\n          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hyphenate)(event) !== event) {\n            dispatch((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hyphenate)(event), args);\n          }\n        };\n        let parent = this;\n        while (parent = parent && (parent.parentNode || parent.host)) {\n          if (parent instanceof VueElement) {\n            instance.parent = parent._instance;\n            instance.provides = parent._instance.provides;\n            break;\n          }\n        }\n      };\n    }\n    return vnode;\n  }\n  _applyStyles(styles) {\n    if (styles) {\n      styles.forEach(css => {\n        const s = document.createElement(\"style\");\n        s.textContent = css;\n        this.shadowRoot.appendChild(s);\n        if (true) {\n          (this._styles || (this._styles = [])).push(s);\n        }\n      });\n    }\n  }\n}\nfunction useCssModule(name = \"$style\") {\n  {\n    const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.getCurrentInstance)();\n    if (!instance) {\n       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.warn)(`useCssModule must be called inside setup()`);\n      return _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ;\n    }\n    const modules = instance.type.__cssModules;\n    if (!modules) {\n       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.warn)(`Current instance does not have CSS modules injected.`);\n      return _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ;\n    }\n    const mod = modules[name];\n    if (!mod) {\n       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.warn)(`Current instance does not have CSS module named \"${name}\".`);\n      return _vue_shared__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ;\n    }\n    return mod;\n  }\n}\nconst positionMap = /* @__PURE__ */new WeakMap();\nconst newPositionMap = /* @__PURE__ */new WeakMap();\nconst moveCbKey = Symbol(\"_moveCb\");\nconst enterCbKey = Symbol(\"_enterCb\");\nconst TransitionGroupImpl = {\n  name: \"TransitionGroup\",\n  props: /* @__PURE__ */(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)({}, TransitionPropsValidators, {\n    tag: String,\n    moveClass: String\n  }),\n  setup(props, {\n    slots\n  }) {\n    const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.getCurrentInstance)();\n    const state = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.useTransitionState)();\n    let prevChildren;\n    let children;\n    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.onUpdated)(() => {\n      if (!prevChildren.length) {\n        return;\n      }\n      const moveClass = props.moveClass || `${props.name || \"v\"}-move`;\n      if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {\n        return;\n      }\n      prevChildren.forEach(callPendingCbs);\n      prevChildren.forEach(recordPosition);\n      const movedChildren = prevChildren.filter(applyTranslation);\n      forceReflow();\n      movedChildren.forEach(c => {\n        const el = c.el;\n        const style = el.style;\n        addTransitionClass(el, moveClass);\n        style.transform = style.webkitTransform = style.transitionDuration = \"\";\n        const cb = el[moveCbKey] = e => {\n          if (e && e.target !== el) {\n            return;\n          }\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(\"transitionend\", cb);\n            el[moveCbKey] = null;\n            removeTransitionClass(el, moveClass);\n          }\n        };\n        el.addEventListener(\"transitionend\", cb);\n      });\n    });\n    return () => {\n      const rawProps = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_3__.toRaw)(props);\n      const cssTransitionProps = resolveTransitionProps(rawProps);\n      let tag = rawProps.tag || _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.Fragment;\n      prevChildren = children;\n      children = slots.default ? (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.getTransitionRawChildren)(slots.default()) : [];\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        if (child.key != null) {\n          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.setTransitionHooks)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.resolveTransitionHooks)(child, cssTransitionProps, state, instance));\n        } else if (true) {\n          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.warn)(`<TransitionGroup> children must be keyed.`);\n        }\n      }\n      if (prevChildren) {\n        for (let i = 0; i < prevChildren.length; i++) {\n          const child = prevChildren[i];\n          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.setTransitionHooks)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.resolveTransitionHooks)(child, cssTransitionProps, state, instance));\n          positionMap.set(child, child.el.getBoundingClientRect());\n        }\n      }\n      return (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.createVNode)(tag, null, children);\n    };\n  }\n};\nconst removeMode = props => delete props.mode;\n/* @__PURE__ */\nremoveMode(TransitionGroupImpl.props);\nconst TransitionGroup = TransitionGroupImpl;\nfunction callPendingCbs(c) {\n  const el = c.el;\n  if (el[moveCbKey]) {\n    el[moveCbKey]();\n  }\n  if (el[enterCbKey]) {\n    el[enterCbKey]();\n  }\n}\nfunction recordPosition(c) {\n  newPositionMap.set(c, c.el.getBoundingClientRect());\n}\nfunction applyTranslation(c) {\n  const oldPos = positionMap.get(c);\n  const newPos = newPositionMap.get(c);\n  const dx = oldPos.left - newPos.left;\n  const dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    const s = c.el.style;\n    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;\n    s.transitionDuration = \"0s\";\n    return c;\n  }\n}\nfunction hasCSSTransform(el, root, moveClass) {\n  const clone = el.cloneNode();\n  const _vtc = el[vtcKey];\n  if (_vtc) {\n    _vtc.forEach(cls => {\n      cls.split(/\\s+/).forEach(c => c && clone.classList.remove(c));\n    });\n  }\n  moveClass.split(/\\s+/).forEach(c => c && clone.classList.add(c));\n  clone.style.display = \"none\";\n  const container = root.nodeType === 1 ? root : root.parentNode;\n  container.appendChild(clone);\n  const {\n    hasTransform\n  } = getTransitionInfo(clone);\n  container.removeChild(clone);\n  return hasTransform;\n}\nconst getModelAssigner = vnode => {\n  const fn = vnode.props[\"onUpdate:modelValue\"] || false;\n  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(fn) ? value => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.invokeArrayFns)(fn, value) : fn;\n};\nfunction onCompositionStart(e) {\n  e.target.composing = true;\n}\nfunction onCompositionEnd(e) {\n  const target = e.target;\n  if (target.composing) {\n    target.composing = false;\n    target.dispatchEvent(new Event(\"input\"));\n  }\n}\nconst assignKey = Symbol(\"_assign\");\nconst vModelText = {\n  created(el, {\n    modifiers: {\n      lazy,\n      trim,\n      number\n    }\n  }, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n    const castToNumber = number || vnode.props && vnode.props.type === \"number\";\n    addEventListener(el, lazy ? \"change\" : \"input\", e => {\n      if (e.target.composing) return;\n      let domValue = el.value;\n      if (trim) {\n        domValue = domValue.trim();\n      }\n      if (castToNumber) {\n        domValue = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.looseToNumber)(domValue);\n      }\n      el[assignKey](domValue);\n    });\n    if (trim) {\n      addEventListener(el, \"change\", () => {\n        el.value = el.value.trim();\n      });\n    }\n    if (!lazy) {\n      addEventListener(el, \"compositionstart\", onCompositionStart);\n      addEventListener(el, \"compositionend\", onCompositionEnd);\n      addEventListener(el, \"change\", onCompositionEnd);\n    }\n  },\n  // set value on mounted so it's after min/max for type=\"range\"\n  mounted(el, {\n    value\n  }) {\n    el.value = value == null ? \"\" : value;\n  },\n  beforeUpdate(el, {\n    value,\n    modifiers: {\n      lazy,\n      trim,\n      number\n    }\n  }, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n    if (el.composing) return;\n    const elValue = number || el.type === \"number\" ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.looseToNumber)(el.value) : el.value;\n    const newValue = value == null ? \"\" : value;\n    if (elValue === newValue) {\n      return;\n    }\n    if (document.activeElement === el && el.type !== \"range\") {\n      if (lazy) {\n        return;\n      }\n      if (trim && el.value.trim() === newValue) {\n        return;\n      }\n    }\n    el.value = newValue;\n  }\n};\nconst vModelCheckbox = {\n  // #4096 array checkboxes need to be deep traversed\n  deep: true,\n  created(el, _, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n    addEventListener(el, \"change\", () => {\n      const modelValue = el._modelValue;\n      const elementValue = getValue(el);\n      const checked = el.checked;\n      const assign = el[assignKey];\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(modelValue)) {\n        const index = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.looseIndexOf)(modelValue, elementValue);\n        const found = index !== -1;\n        if (checked && !found) {\n          assign(modelValue.concat(elementValue));\n        } else if (!checked && found) {\n          const filtered = [...modelValue];\n          filtered.splice(index, 1);\n          assign(filtered);\n        }\n      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isSet)(modelValue)) {\n        const cloned = new Set(modelValue);\n        if (checked) {\n          cloned.add(elementValue);\n        } else {\n          cloned.delete(elementValue);\n        }\n        assign(cloned);\n      } else {\n        assign(getCheckboxValue(el, checked));\n      }\n    });\n  },\n  // set initial checked on mount to wait for true-value/false-value\n  mounted: setChecked,\n  beforeUpdate(el, binding, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n    setChecked(el, binding, vnode);\n  }\n};\nfunction setChecked(el, {\n  value,\n  oldValue\n}, vnode) {\n  el._modelValue = value;\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(value)) {\n    el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.looseIndexOf)(value, vnode.props.value) > -1;\n  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isSet)(value)) {\n    el.checked = value.has(vnode.props.value);\n  } else if (value !== oldValue) {\n    el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.looseEqual)(value, getCheckboxValue(el, true));\n  }\n}\nconst vModelRadio = {\n  created(el, {\n    value\n  }, vnode) {\n    el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.looseEqual)(value, vnode.props.value);\n    el[assignKey] = getModelAssigner(vnode);\n    addEventListener(el, \"change\", () => {\n      el[assignKey](getValue(el));\n    });\n  },\n  beforeUpdate(el, {\n    value,\n    oldValue\n  }, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n    if (value !== oldValue) {\n      el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.looseEqual)(value, vnode.props.value);\n    }\n  }\n};\nconst vModelSelect = {\n  // <select multiple> value need to be deep traversed\n  deep: true,\n  created(el, {\n    value,\n    modifiers: {\n      number\n    }\n  }, vnode) {\n    const isSetModel = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isSet)(value);\n    addEventListener(el, \"change\", () => {\n      const selectedVal = Array.prototype.filter.call(el.options, o => o.selected).map(o => number ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.looseToNumber)(getValue(o)) : getValue(o));\n      el[assignKey](el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);\n    });\n    el[assignKey] = getModelAssigner(vnode);\n  },\n  // set value in mounted & updated because <select> relies on its children\n  // <option>s.\n  mounted(el, {\n    value\n  }) {\n    setSelected(el, value);\n  },\n  beforeUpdate(el, _binding, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n  },\n  updated(el, {\n    value\n  }) {\n    setSelected(el, value);\n  }\n};\nfunction setSelected(el, value) {\n  const isMultiple = el.multiple;\n  if (isMultiple && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(value) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isSet)(value)) {\n     true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.warn)(`<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);\n    return;\n  }\n  for (let i = 0, l = el.options.length; i < l; i++) {\n    const option = el.options[i];\n    const optionValue = getValue(option);\n    if (isMultiple) {\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(value)) {\n        option.selected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.looseIndexOf)(value, optionValue) > -1;\n      } else {\n        option.selected = value.has(optionValue);\n      }\n    } else {\n      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.looseEqual)(getValue(option), value)) {\n        if (el.selectedIndex !== i) el.selectedIndex = i;\n        return;\n      }\n    }\n  }\n  if (!isMultiple && el.selectedIndex !== -1) {\n    el.selectedIndex = -1;\n  }\n}\nfunction getValue(el) {\n  return \"_value\" in el ? el._value : el.value;\n}\nfunction getCheckboxValue(el, checked) {\n  const key = checked ? \"_trueValue\" : \"_falseValue\";\n  return key in el ? el[key] : checked;\n}\nconst vModelDynamic = {\n  created(el, binding, vnode) {\n    callModelHook(el, binding, vnode, null, \"created\");\n  },\n  mounted(el, binding, vnode) {\n    callModelHook(el, binding, vnode, null, \"mounted\");\n  },\n  beforeUpdate(el, binding, vnode, prevVNode) {\n    callModelHook(el, binding, vnode, prevVNode, \"beforeUpdate\");\n  },\n  updated(el, binding, vnode, prevVNode) {\n    callModelHook(el, binding, vnode, prevVNode, \"updated\");\n  }\n};\nfunction resolveDynamicModel(tagName, type) {\n  switch (tagName) {\n    case \"SELECT\":\n      return vModelSelect;\n    case \"TEXTAREA\":\n      return vModelText;\n    default:\n      switch (type) {\n        case \"checkbox\":\n          return vModelCheckbox;\n        case \"radio\":\n          return vModelRadio;\n        default:\n          return vModelText;\n      }\n  }\n}\nfunction callModelHook(el, binding, vnode, prevVNode, hook) {\n  const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);\n  const fn = modelToUse[hook];\n  fn && fn(el, binding, vnode, prevVNode);\n}\nfunction initVModelForSSR() {\n  vModelText.getSSRProps = ({\n    value\n  }) => ({\n    value\n  });\n  vModelRadio.getSSRProps = ({\n    value\n  }, vnode) => {\n    if (vnode.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.looseEqual)(vnode.props.value, value)) {\n      return {\n        checked: true\n      };\n    }\n  };\n  vModelCheckbox.getSSRProps = ({\n    value\n  }, vnode) => {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isArray)(value)) {\n      if (vnode.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.looseIndexOf)(value, vnode.props.value) > -1) {\n        return {\n          checked: true\n        };\n      }\n    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isSet)(value)) {\n      if (vnode.props && value.has(vnode.props.value)) {\n        return {\n          checked: true\n        };\n      }\n    } else if (value) {\n      return {\n        checked: true\n      };\n    }\n  };\n  vModelDynamic.getSSRProps = (binding, vnode) => {\n    if (typeof vnode.type !== \"string\") {\n      return;\n    }\n    const modelToUse = resolveDynamicModel(\n    // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase\n    vnode.type.toUpperCase(), vnode.props && vnode.props.type);\n    if (modelToUse.getSSRProps) {\n      return modelToUse.getSSRProps(binding, vnode);\n    }\n  };\n}\nconst systemModifiers = [\"ctrl\", \"shift\", \"alt\", \"meta\"];\nconst modifierGuards = {\n  stop: e => e.stopPropagation(),\n  prevent: e => e.preventDefault(),\n  self: e => e.target !== e.currentTarget,\n  ctrl: e => !e.ctrlKey,\n  shift: e => !e.shiftKey,\n  alt: e => !e.altKey,\n  meta: e => !e.metaKey,\n  left: e => \"button\" in e && e.button !== 0,\n  middle: e => \"button\" in e && e.button !== 1,\n  right: e => \"button\" in e && e.button !== 2,\n  exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))\n};\nconst withModifiers = (fn, modifiers) => {\n  const cache = fn._withMods || (fn._withMods = {});\n  const cacheKey = modifiers.join(\".\");\n  return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {\n    for (let i = 0; i < modifiers.length; i++) {\n      const guard = modifierGuards[modifiers[i]];\n      if (guard && guard(event, modifiers)) return;\n    }\n    return fn(event, ...args);\n  });\n};\nconst keyNames = {\n  esc: \"escape\",\n  space: \" \",\n  up: \"arrow-up\",\n  left: \"arrow-left\",\n  right: \"arrow-right\",\n  down: \"arrow-down\",\n  delete: \"backspace\"\n};\nconst withKeys = (fn, modifiers) => {\n  const cache = fn._withKeys || (fn._withKeys = {});\n  const cacheKey = modifiers.join(\".\");\n  return cache[cacheKey] || (cache[cacheKey] = event => {\n    if (!(\"key\" in event)) {\n      return;\n    }\n    const eventKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.hyphenate)(event.key);\n    if (modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {\n      return fn(event);\n    }\n  });\n};\nconst rendererOptions = /* @__PURE__ */(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)({\n  patchProp\n}, nodeOps);\nlet renderer;\nlet enabledHydration = false;\nfunction ensureRenderer() {\n  return renderer || (renderer = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.createRenderer)(rendererOptions));\n}\nfunction ensureHydrationRenderer() {\n  renderer = enabledHydration ? renderer : (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.createHydrationRenderer)(rendererOptions);\n  enabledHydration = true;\n  return renderer;\n}\nconst render = (...args) => {\n  ensureRenderer().render(...args);\n};\nconst hydrate = (...args) => {\n  ensureHydrationRenderer().hydrate(...args);\n};\nconst createApp = (...args) => {\n  const app = ensureRenderer().createApp(...args);\n  if (true) {\n    injectNativeTagCheck(app);\n    injectCompilerOptionsCheck(app);\n  }\n  const {\n    mount\n  } = app;\n  app.mount = containerOrSelector => {\n    const container = normalizeContainer(containerOrSelector);\n    if (!container) return;\n    const component = app._component;\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isFunction)(component) && !component.render && !component.template) {\n      component.template = container.innerHTML;\n    }\n    container.innerHTML = \"\";\n    const proxy = mount(container, false, resolveRootNamespace(container));\n    if (container instanceof Element) {\n      container.removeAttribute(\"v-cloak\");\n      container.setAttribute(\"data-v-app\", \"\");\n    }\n    return proxy;\n  };\n  return app;\n};\nconst createSSRApp = (...args) => {\n  const app = ensureHydrationRenderer().createApp(...args);\n  if (true) {\n    injectNativeTagCheck(app);\n    injectCompilerOptionsCheck(app);\n  }\n  const {\n    mount\n  } = app;\n  app.mount = containerOrSelector => {\n    const container = normalizeContainer(containerOrSelector);\n    if (container) {\n      return mount(container, true, resolveRootNamespace(container));\n    }\n  };\n  return app;\n};\nfunction resolveRootNamespace(container) {\n  if (container instanceof SVGElement) {\n    return \"svg\";\n  }\n  if (typeof MathMLElement === \"function\" && container instanceof MathMLElement) {\n    return \"mathml\";\n  }\n}\nfunction injectNativeTagCheck(app) {\n  Object.defineProperty(app.config, \"isNativeTag\", {\n    value: tag => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isSVGTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isMathMLTag)(tag),\n    writable: false\n  });\n}\nfunction injectCompilerOptionsCheck(app) {\n  if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.isRuntimeOnly)()) {\n    const isCustomElement = app.config.isCustomElement;\n    Object.defineProperty(app.config, \"isCustomElement\", {\n      get() {\n        return isCustomElement;\n      },\n      set() {\n        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.warn)(`The \\`isCustomElement\\` config option is deprecated. Use \\`compilerOptions.isCustomElement\\` instead.`);\n      }\n    });\n    const compilerOptions = app.config.compilerOptions;\n    const msg = `The \\`compilerOptions\\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka \"full build\"). Since you are using the runtime-only build, \\`compilerOptions\\` must be passed to \\`@vue/compiler-dom\\` in the build setup instead.\n- For vue-loader: pass it via vue-loader's \\`compilerOptions\\` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;\n    Object.defineProperty(app.config, \"compilerOptions\", {\n      get() {\n        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.warn)(msg);\n        return compilerOptions;\n      },\n      set() {\n        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.warn)(msg);\n      }\n    });\n  }\n}\nfunction normalizeContainer(container) {\n  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isString)(container)) {\n    const res = document.querySelector(container);\n    if ( true && !res) {\n      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.warn)(`Failed to mount app: mount target selector \"${container}\" returned null.`);\n    }\n    return res;\n  }\n  if ( true && window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === \"closed\") {\n    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.warn)(`mounting on a ShadowRoot with \\`{mode: \"closed\"}\\` may lead to unpredictable bugs`);\n  }\n  return container;\n}\nlet ssrDirectiveInitialized = false;\nconst initDirectivesForSSR = () => {\n  if (!ssrDirectiveInitialized) {\n    ssrDirectiveInitialized = true;\n    initVModelForSSR();\n    initVShowForSSR();\n  }\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js?");

/***/ }),

/***/ "./node_modules/@vue/shared/dist/shared.esm-bundler.js":
/*!*************************************************************!*\
  !*** ./node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EMPTY_ARR: function() { return /* binding */ EMPTY_ARR; },\n/* harmony export */   EMPTY_OBJ: function() { return /* binding */ EMPTY_OBJ; },\n/* harmony export */   NO: function() { return /* binding */ NO; },\n/* harmony export */   NOOP: function() { return /* binding */ NOOP; },\n/* harmony export */   PatchFlagNames: function() { return /* binding */ PatchFlagNames; },\n/* harmony export */   PatchFlags: function() { return /* binding */ PatchFlags; },\n/* harmony export */   ShapeFlags: function() { return /* binding */ ShapeFlags; },\n/* harmony export */   SlotFlags: function() { return /* binding */ SlotFlags; },\n/* harmony export */   camelize: function() { return /* binding */ camelize; },\n/* harmony export */   capitalize: function() { return /* binding */ capitalize; },\n/* harmony export */   def: function() { return /* binding */ def; },\n/* harmony export */   escapeHtml: function() { return /* binding */ escapeHtml; },\n/* harmony export */   escapeHtmlComment: function() { return /* binding */ escapeHtmlComment; },\n/* harmony export */   extend: function() { return /* binding */ extend; },\n/* harmony export */   genPropsAccessExp: function() { return /* binding */ genPropsAccessExp; },\n/* harmony export */   generateCodeFrame: function() { return /* binding */ generateCodeFrame; },\n/* harmony export */   getGlobalThis: function() { return /* binding */ getGlobalThis; },\n/* harmony export */   hasChanged: function() { return /* binding */ hasChanged; },\n/* harmony export */   hasOwn: function() { return /* binding */ hasOwn; },\n/* harmony export */   hyphenate: function() { return /* binding */ hyphenate; },\n/* harmony export */   includeBooleanAttr: function() { return /* binding */ includeBooleanAttr; },\n/* harmony export */   invokeArrayFns: function() { return /* binding */ invokeArrayFns; },\n/* harmony export */   isArray: function() { return /* binding */ isArray; },\n/* harmony export */   isBooleanAttr: function() { return /* binding */ isBooleanAttr; },\n/* harmony export */   isBuiltInDirective: function() { return /* binding */ isBuiltInDirective; },\n/* harmony export */   isDate: function() { return /* binding */ isDate; },\n/* harmony export */   isFunction: function() { return /* binding */ isFunction; },\n/* harmony export */   isGloballyAllowed: function() { return /* binding */ isGloballyAllowed; },\n/* harmony export */   isGloballyWhitelisted: function() { return /* binding */ isGloballyWhitelisted; },\n/* harmony export */   isHTMLTag: function() { return /* binding */ isHTMLTag; },\n/* harmony export */   isIntegerKey: function() { return /* binding */ isIntegerKey; },\n/* harmony export */   isKnownHtmlAttr: function() { return /* binding */ isKnownHtmlAttr; },\n/* harmony export */   isKnownSvgAttr: function() { return /* binding */ isKnownSvgAttr; },\n/* harmony export */   isMap: function() { return /* binding */ isMap; },\n/* harmony export */   isMathMLTag: function() { return /* binding */ isMathMLTag; },\n/* harmony export */   isModelListener: function() { return /* binding */ isModelListener; },\n/* harmony export */   isObject: function() { return /* binding */ isObject; },\n/* harmony export */   isOn: function() { return /* binding */ isOn; },\n/* harmony export */   isPlainObject: function() { return /* binding */ isPlainObject; },\n/* harmony export */   isPromise: function() { return /* binding */ isPromise; },\n/* harmony export */   isRegExp: function() { return /* binding */ isRegExp; },\n/* harmony export */   isReservedProp: function() { return /* binding */ isReservedProp; },\n/* harmony export */   isSSRSafeAttrName: function() { return /* binding */ isSSRSafeAttrName; },\n/* harmony export */   isSVGTag: function() { return /* binding */ isSVGTag; },\n/* harmony export */   isSet: function() { return /* binding */ isSet; },\n/* harmony export */   isSpecialBooleanAttr: function() { return /* binding */ isSpecialBooleanAttr; },\n/* harmony export */   isString: function() { return /* binding */ isString; },\n/* harmony export */   isSymbol: function() { return /* binding */ isSymbol; },\n/* harmony export */   isVoidTag: function() { return /* binding */ isVoidTag; },\n/* harmony export */   looseEqual: function() { return /* binding */ looseEqual; },\n/* harmony export */   looseIndexOf: function() { return /* binding */ looseIndexOf; },\n/* harmony export */   looseToNumber: function() { return /* binding */ looseToNumber; },\n/* harmony export */   makeMap: function() { return /* binding */ makeMap; },\n/* harmony export */   normalizeClass: function() { return /* binding */ normalizeClass; },\n/* harmony export */   normalizeProps: function() { return /* binding */ normalizeProps; },\n/* harmony export */   normalizeStyle: function() { return /* binding */ normalizeStyle; },\n/* harmony export */   objectToString: function() { return /* binding */ objectToString; },\n/* harmony export */   parseStringStyle: function() { return /* binding */ parseStringStyle; },\n/* harmony export */   propsToAttrMap: function() { return /* binding */ propsToAttrMap; },\n/* harmony export */   remove: function() { return /* binding */ remove; },\n/* harmony export */   slotFlagsText: function() { return /* binding */ slotFlagsText; },\n/* harmony export */   stringifyStyle: function() { return /* binding */ stringifyStyle; },\n/* harmony export */   toDisplayString: function() { return /* binding */ toDisplayString; },\n/* harmony export */   toHandlerKey: function() { return /* binding */ toHandlerKey; },\n/* harmony export */   toNumber: function() { return /* binding */ toNumber; },\n/* harmony export */   toRawType: function() { return /* binding */ toRawType; },\n/* harmony export */   toTypeString: function() { return /* binding */ toTypeString; }\n/* harmony export */ });\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.push.js */ \"./node_modules/core-js/modules/es.array.push.js\");\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction makeMap(str, expectsLowerCase) {\n  const set = new Set(str.split(\",\"));\n  return expectsLowerCase ? val => set.has(val.toLowerCase()) : val => set.has(val);\n}\nconst EMPTY_OBJ =  true ? Object.freeze({}) : 0;\nconst EMPTY_ARR =  true ? Object.freeze([]) : 0;\nconst NOOP = () => {};\nconst NO = () => false;\nconst isOn = key => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && (\n// uppercase letter\nkey.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);\nconst isModelListener = key => key.startsWith(\"onUpdate:\");\nconst extend = Object.assign;\nconst remove = (arr, el) => {\n  const i = arr.indexOf(el);\n  if (i > -1) {\n    arr.splice(i, 1);\n  }\n};\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\nconst isArray = Array.isArray;\nconst isMap = val => toTypeString(val) === \"[object Map]\";\nconst isSet = val => toTypeString(val) === \"[object Set]\";\nconst isDate = val => toTypeString(val) === \"[object Date]\";\nconst isRegExp = val => toTypeString(val) === \"[object RegExp]\";\nconst isFunction = val => typeof val === \"function\";\nconst isString = val => typeof val === \"string\";\nconst isSymbol = val => typeof val === \"symbol\";\nconst isObject = val => val !== null && typeof val === \"object\";\nconst isPromise = val => {\n  return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);\n};\nconst objectToString = Object.prototype.toString;\nconst toTypeString = value => objectToString.call(value);\nconst toRawType = value => {\n  return toTypeString(value).slice(8, -1);\n};\nconst isPlainObject = val => toTypeString(val) === \"[object Object]\";\nconst isIntegerKey = key => isString(key) && key !== \"NaN\" && key[0] !== \"-\" && \"\" + parseInt(key, 10) === key;\nconst isReservedProp = /* @__PURE__ */makeMap(\n// the leading comma is intentional so empty string \"\" is also included\n\",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted\");\nconst isBuiltInDirective = /* @__PURE__ */makeMap(\"bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo\");\nconst cacheStringFunction = fn => {\n  const cache = /* @__PURE__ */Object.create(null);\n  return str => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n};\nconst camelizeRE = /-(\\w)/g;\nconst camelize = cacheStringFunction(str => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n});\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cacheStringFunction(str => str.replace(hyphenateRE, \"-$1\").toLowerCase());\nconst capitalize = cacheStringFunction(str => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n});\nconst toHandlerKey = cacheStringFunction(str => {\n  const s = str ? `on${capitalize(str)}` : ``;\n  return s;\n});\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\nconst invokeArrayFns = (fns, arg) => {\n  for (let i = 0; i < fns.length; i++) {\n    fns[i](arg);\n  }\n};\nconst def = (obj, key, value) => {\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: false,\n    value\n  });\n};\nconst looseToNumber = val => {\n  const n = parseFloat(val);\n  return isNaN(n) ? val : n;\n};\nconst toNumber = val => {\n  const n = isString(val) ? Number(val) : NaN;\n  return isNaN(n) ? val : n;\n};\nlet _globalThis;\nconst getGlobalThis = () => {\n  return _globalThis || (_globalThis = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : {});\n};\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\nfunction genPropsAccessExp(name) {\n  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;\n}\nconst PatchFlags = {\n  \"TEXT\": 1,\n  \"1\": \"TEXT\",\n  \"CLASS\": 2,\n  \"2\": \"CLASS\",\n  \"STYLE\": 4,\n  \"4\": \"STYLE\",\n  \"PROPS\": 8,\n  \"8\": \"PROPS\",\n  \"FULL_PROPS\": 16,\n  \"16\": \"FULL_PROPS\",\n  \"NEED_HYDRATION\": 32,\n  \"32\": \"NEED_HYDRATION\",\n  \"STABLE_FRAGMENT\": 64,\n  \"64\": \"STABLE_FRAGMENT\",\n  \"KEYED_FRAGMENT\": 128,\n  \"128\": \"KEYED_FRAGMENT\",\n  \"UNKEYED_FRAGMENT\": 256,\n  \"256\": \"UNKEYED_FRAGMENT\",\n  \"NEED_PATCH\": 512,\n  \"512\": \"NEED_PATCH\",\n  \"DYNAMIC_SLOTS\": 1024,\n  \"1024\": \"DYNAMIC_SLOTS\",\n  \"DEV_ROOT_FRAGMENT\": 2048,\n  \"2048\": \"DEV_ROOT_FRAGMENT\",\n  \"HOISTED\": -1,\n  \"-1\": \"HOISTED\",\n  \"BAIL\": -2,\n  \"-2\": \"BAIL\"\n};\nconst PatchFlagNames = {\n  [1]: `TEXT`,\n  [2]: `CLASS`,\n  [4]: `STYLE`,\n  [8]: `PROPS`,\n  [16]: `FULL_PROPS`,\n  [32]: `NEED_HYDRATION`,\n  [64]: `STABLE_FRAGMENT`,\n  [128]: `KEYED_FRAGMENT`,\n  [256]: `UNKEYED_FRAGMENT`,\n  [512]: `NEED_PATCH`,\n  [1024]: `DYNAMIC_SLOTS`,\n  [2048]: `DEV_ROOT_FRAGMENT`,\n  [-1]: `HOISTED`,\n  [-2]: `BAIL`\n};\nconst ShapeFlags = {\n  \"ELEMENT\": 1,\n  \"1\": \"ELEMENT\",\n  \"FUNCTIONAL_COMPONENT\": 2,\n  \"2\": \"FUNCTIONAL_COMPONENT\",\n  \"STATEFUL_COMPONENT\": 4,\n  \"4\": \"STATEFUL_COMPONENT\",\n  \"TEXT_CHILDREN\": 8,\n  \"8\": \"TEXT_CHILDREN\",\n  \"ARRAY_CHILDREN\": 16,\n  \"16\": \"ARRAY_CHILDREN\",\n  \"SLOTS_CHILDREN\": 32,\n  \"32\": \"SLOTS_CHILDREN\",\n  \"TELEPORT\": 64,\n  \"64\": \"TELEPORT\",\n  \"SUSPENSE\": 128,\n  \"128\": \"SUSPENSE\",\n  \"COMPONENT_SHOULD_KEEP_ALIVE\": 256,\n  \"256\": \"COMPONENT_SHOULD_KEEP_ALIVE\",\n  \"COMPONENT_KEPT_ALIVE\": 512,\n  \"512\": \"COMPONENT_KEPT_ALIVE\",\n  \"COMPONENT\": 6,\n  \"6\": \"COMPONENT\"\n};\nconst SlotFlags = {\n  \"STABLE\": 1,\n  \"1\": \"STABLE\",\n  \"DYNAMIC\": 2,\n  \"2\": \"DYNAMIC\",\n  \"FORWARDED\": 3,\n  \"3\": \"FORWARDED\"\n};\nconst slotFlagsText = {\n  [1]: \"STABLE\",\n  [2]: \"DYNAMIC\",\n  [3]: \"FORWARDED\"\n};\nconst GLOBALS_ALLOWED = \"Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error\";\nconst isGloballyAllowed = /* @__PURE__ */makeMap(GLOBALS_ALLOWED);\nconst isGloballyWhitelisted = isGloballyAllowed;\nconst range = 2;\nfunction generateCodeFrame(source, start = 0, end = source.length) {\n  let lines = source.split(/(\\r?\\n)/);\n  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\n  lines = lines.filter((_, idx) => idx % 2 === 0);\n  let count = 0;\n  const res = [];\n  for (let i = 0; i < lines.length; i++) {\n    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);\n    if (count >= start) {\n      for (let j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length) continue;\n        const line = j + 1;\n        res.push(`${line}${\" \".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\n        const lineLength = lines[j].length;\n        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;\n        if (j === i) {\n          const pad = start - (count - (lineLength + newLineSeqLength));\n          const length = Math.max(1, end > count ? lineLength - pad : end - start);\n          res.push(`   |  ` + \" \".repeat(pad) + \"^\".repeat(length));\n        } else if (j > i) {\n          if (end > count) {\n            const length = Math.max(Math.min(end - count, lineLength), 1);\n            res.push(`   |  ` + \"^\".repeat(length));\n          }\n          count += lineLength + newLineSeqLength;\n        }\n      }\n      break;\n    }\n  }\n  return res.join(\"\\n\");\n}\nfunction normalizeStyle(value) {\n  if (isArray(value)) {\n    const res = {};\n    for (let i = 0; i < value.length; i++) {\n      const item = value[i];\n      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);\n      if (normalized) {\n        for (const key in normalized) {\n          res[key] = normalized[key];\n        }\n      }\n    }\n    return res;\n  } else if (isString(value) || isObject(value)) {\n    return value;\n  }\n}\nconst listDelimiterRE = /;(?![^(]*\\))/g;\nconst propertyDelimiterRE = /:([^]+)/;\nconst styleCommentRE = /\\/\\*[^]*?\\*\\//g;\nfunction parseStringStyle(cssText) {\n  const ret = {};\n  cssText.replace(styleCommentRE, \"\").split(listDelimiterRE).forEach(item => {\n    if (item) {\n      const tmp = item.split(propertyDelimiterRE);\n      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return ret;\n}\nfunction stringifyStyle(styles) {\n  let ret = \"\";\n  if (!styles || isString(styles)) {\n    return ret;\n  }\n  for (const key in styles) {\n    const value = styles[key];\n    const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\n    if (isString(value) || typeof value === \"number\") {\n      ret += `${normalizedKey}:${value};`;\n    }\n  }\n  return ret;\n}\nfunction normalizeClass(value) {\n  let res = \"\";\n  if (isString(value)) {\n    res = value;\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      const normalized = normalizeClass(value[i]);\n      if (normalized) {\n        res += normalized + \" \";\n      }\n    }\n  } else if (isObject(value)) {\n    for (const name in value) {\n      if (value[name]) {\n        res += name + \" \";\n      }\n    }\n  }\n  return res.trim();\n}\nfunction normalizeProps(props) {\n  if (!props) return null;\n  let {\n    class: klass,\n    style\n  } = props;\n  if (klass && !isString(klass)) {\n    props.class = normalizeClass(klass);\n  }\n  if (style) {\n    props.style = normalizeStyle(style);\n  }\n  return props;\n}\nconst HTML_TAGS = \"html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot\";\nconst SVG_TAGS = \"svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view\";\nconst MATH_TAGS = \"annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics\";\nconst VOID_TAGS = \"area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr\";\nconst isHTMLTag = /* @__PURE__ */makeMap(HTML_TAGS);\nconst isSVGTag = /* @__PURE__ */makeMap(SVG_TAGS);\nconst isMathMLTag = /* @__PURE__ */makeMap(MATH_TAGS);\nconst isVoidTag = /* @__PURE__ */makeMap(VOID_TAGS);\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\nconst isSpecialBooleanAttr = /* @__PURE__ */makeMap(specialBooleanAttrs);\nconst isBooleanAttr = /* @__PURE__ */makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);\nfunction includeBooleanAttr(value) {\n  return !!value || value === \"\";\n}\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\nconst attrValidationCache = {};\nfunction isSSRSafeAttrName(name) {\n  if (attrValidationCache.hasOwnProperty(name)) {\n    return attrValidationCache[name];\n  }\n  const isUnsafe = unsafeAttrCharRE.test(name);\n  if (isUnsafe) {\n    console.error(`unsafe attribute name: ${name}`);\n  }\n  return attrValidationCache[name] = !isUnsafe;\n}\nconst propsToAttrMap = {\n  acceptCharset: \"accept-charset\",\n  className: \"class\",\n  htmlFor: \"for\",\n  httpEquiv: \"http-equiv\"\n};\nconst isKnownHtmlAttr = /* @__PURE__ */makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);\nconst isKnownSvgAttr = /* @__PURE__ */makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);\nconst escapeRE = /[\"'&<>]/;\nfunction escapeHtml(string) {\n  const str = \"\" + string;\n  const match = escapeRE.exec(str);\n  if (!match) {\n    return str;\n  }\n  let html = \"\";\n  let escaped;\n  let index;\n  let lastIndex = 0;\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34:\n        escaped = \"&quot;\";\n        break;\n      case 38:\n        escaped = \"&amp;\";\n        break;\n      case 39:\n        escaped = \"&#39;\";\n        break;\n      case 60:\n        escaped = \"&lt;\";\n        break;\n      case 62:\n        escaped = \"&gt;\";\n        break;\n      default:\n        continue;\n    }\n    if (lastIndex !== index) {\n      html += str.slice(lastIndex, index);\n    }\n    lastIndex = index + 1;\n    html += escaped;\n  }\n  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n}\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\nfunction escapeHtmlComment(src) {\n  return src.replace(commentStripRE, \"\");\n}\nfunction looseCompareArrays(a, b) {\n  if (a.length !== b.length) return false;\n  let equal = true;\n  for (let i = 0; equal && i < a.length; i++) {\n    equal = looseEqual(a[i], b[i]);\n  }\n  return equal;\n}\nfunction looseEqual(a, b) {\n  if (a === b) return true;\n  let aValidType = isDate(a);\n  let bValidType = isDate(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n  }\n  aValidType = isSymbol(a);\n  bValidType = isSymbol(b);\n  if (aValidType || bValidType) {\n    return a === b;\n  }\n  aValidType = isArray(a);\n  bValidType = isArray(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? looseCompareArrays(a, b) : false;\n  }\n  aValidType = isObject(a);\n  bValidType = isObject(b);\n  if (aValidType || bValidType) {\n    if (!aValidType || !bValidType) {\n      return false;\n    }\n    const aKeysCount = Object.keys(a).length;\n    const bKeysCount = Object.keys(b).length;\n    if (aKeysCount !== bKeysCount) {\n      return false;\n    }\n    for (const key in a) {\n      const aHasKey = a.hasOwnProperty(key);\n      const bHasKey = b.hasOwnProperty(key);\n      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n  }\n  return String(a) === String(b);\n}\nfunction looseIndexOf(arr, val) {\n  return arr.findIndex(item => looseEqual(item, val));\n}\nconst toDisplayString = val => {\n  return isString(val) ? val : val == null ? \"\" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);\n};\nconst replacer = (_key, val) => {\n  if (val && val.__v_isRef) {\n    return replacer(_key, val.value);\n  } else if (isMap(val)) {\n    return {\n      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2], i) => {\n        entries[stringifySymbol(key, i) + \" =>\"] = val2;\n        return entries;\n      }, {})\n    };\n  } else if (isSet(val)) {\n    return {\n      [`Set(${val.size})`]: [...val.values()].map(v => stringifySymbol(v))\n    };\n  } else if (isSymbol(val)) {\n    return stringifySymbol(val);\n  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\n    return String(val);\n  }\n  return val;\n};\nconst stringifySymbol = (v, i = \"\") => {\n  var _a;\n  return isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v;\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/@vue/shared/dist/shared.esm-bundler.js?");

/***/ }),

/***/ "./node_modules/vue-loader/dist/exportHelper.js":
/*!******************************************************!*\
  !*** ./node_modules/vue-loader/dist/exportHelper.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n// runtime helper for setting properties on components\n// in a tree-shakable way\nexports[\"default\"] = (sfc, props) => {\n  const target = sfc.__vccOpts || sfc;\n  for (const [key, val] of props) {\n    target[key] = val;\n  }\n  return target;\n};\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/vue-loader/dist/exportHelper.js?");

/***/ }),

/***/ "./node_modules/vue-style-loader/lib/listToStyles.js":
/*!***********************************************************!*\
  !*** ./node_modules/vue-style-loader/lib/listToStyles.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ listToStyles; }\n/* harmony export */ });\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.push.js */ \"./node_modules/core-js/modules/es.array.push.js\");\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__);\n\n/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nfunction listToStyles(parentId, list) {\n  var styles = [];\n  var newStyles = {};\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = item[0];\n    var css = item[1];\n    var media = item[2];\n    var sourceMap = item[3];\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    };\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = {\n        id: id,\n        parts: [part]\n      });\n    } else {\n      newStyles[id].parts.push(part);\n    }\n  }\n  return styles;\n}\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/vue-style-loader/lib/listToStyles.js?");

/***/ }),

/***/ "./node_modules/vue/dist/vue.runtime.esm-bundler.js":
/*!**********************************************************!*\
  !*** ./node_modules/vue/dist/vue.runtime.esm-bundler.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseTransition: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.BaseTransition; },\n/* harmony export */   BaseTransitionPropsValidators: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.BaseTransitionPropsValidators; },\n/* harmony export */   Comment: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Comment; },\n/* harmony export */   DeprecationTypes: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.DeprecationTypes; },\n/* harmony export */   EffectScope: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.EffectScope; },\n/* harmony export */   ErrorCodes: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ErrorCodes; },\n/* harmony export */   ErrorTypeStrings: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ErrorTypeStrings; },\n/* harmony export */   Fragment: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Fragment; },\n/* harmony export */   KeepAlive: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.KeepAlive; },\n/* harmony export */   ReactiveEffect: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect; },\n/* harmony export */   Static: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Static; },\n/* harmony export */   Suspense: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Suspense; },\n/* harmony export */   Teleport: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Teleport; },\n/* harmony export */   Text: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Text; },\n/* harmony export */   TrackOpTypes: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.TrackOpTypes; },\n/* harmony export */   Transition: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Transition; },\n/* harmony export */   TransitionGroup: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.TransitionGroup; },\n/* harmony export */   TriggerOpTypes: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.TriggerOpTypes; },\n/* harmony export */   VueElement: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.VueElement; },\n/* harmony export */   assertNumber: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.assertNumber; },\n/* harmony export */   callWithAsyncErrorHandling: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling; },\n/* harmony export */   callWithErrorHandling: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling; },\n/* harmony export */   camelize: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.camelize; },\n/* harmony export */   capitalize: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.capitalize; },\n/* harmony export */   cloneVNode: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.cloneVNode; },\n/* harmony export */   compatUtils: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.compatUtils; },\n/* harmony export */   compile: function() { return /* binding */ compile; },\n/* harmony export */   computed: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.computed; },\n/* harmony export */   createApp: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createApp; },\n/* harmony export */   createBlock: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createBlock; },\n/* harmony export */   createCommentVNode: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode; },\n/* harmony export */   createElementBlock: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createElementBlock; },\n/* harmony export */   createElementVNode: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createElementVNode; },\n/* harmony export */   createHydrationRenderer: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer; },\n/* harmony export */   createPropsRestProxy: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy; },\n/* harmony export */   createRenderer: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createRenderer; },\n/* harmony export */   createSSRApp: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSSRApp; },\n/* harmony export */   createSlots: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSlots; },\n/* harmony export */   createStaticVNode: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode; },\n/* harmony export */   createTextVNode: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createTextVNode; },\n/* harmony export */   createVNode: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createVNode; },\n/* harmony export */   customRef: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.customRef; },\n/* harmony export */   defineAsyncComponent: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent; },\n/* harmony export */   defineComponent: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineComponent; },\n/* harmony export */   defineCustomElement: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineCustomElement; },\n/* harmony export */   defineEmits: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineEmits; },\n/* harmony export */   defineExpose: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineExpose; },\n/* harmony export */   defineModel: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineModel; },\n/* harmony export */   defineOptions: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineOptions; },\n/* harmony export */   defineProps: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineProps; },\n/* harmony export */   defineSSRCustomElement: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineSSRCustomElement; },\n/* harmony export */   defineSlots: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineSlots; },\n/* harmony export */   devtools: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.devtools; },\n/* harmony export */   effect: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.effect; },\n/* harmony export */   effectScope: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.effectScope; },\n/* harmony export */   getCurrentInstance: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance; },\n/* harmony export */   getCurrentScope: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope; },\n/* harmony export */   getTransitionRawChildren: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren; },\n/* harmony export */   guardReactiveProps: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps; },\n/* harmony export */   h: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.h; },\n/* harmony export */   handleError: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.handleError; },\n/* harmony export */   hasInjectionContext: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hasInjectionContext; },\n/* harmony export */   hydrate: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hydrate; },\n/* harmony export */   initCustomFormatter: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter; },\n/* harmony export */   initDirectivesForSSR: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initDirectivesForSSR; },\n/* harmony export */   inject: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.inject; },\n/* harmony export */   isMemoSame: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isMemoSame; },\n/* harmony export */   isProxy: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isProxy; },\n/* harmony export */   isReactive: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReactive; },\n/* harmony export */   isReadonly: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReadonly; },\n/* harmony export */   isRef: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRef; },\n/* harmony export */   isRuntimeOnly: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly; },\n/* harmony export */   isShallow: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isShallow; },\n/* harmony export */   isVNode: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isVNode; },\n/* harmony export */   markRaw: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.markRaw; },\n/* harmony export */   mergeDefaults: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults; },\n/* harmony export */   mergeModels: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeModels; },\n/* harmony export */   mergeProps: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeProps; },\n/* harmony export */   nextTick: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.nextTick; },\n/* harmony export */   normalizeClass: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeClass; },\n/* harmony export */   normalizeProps: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeProps; },\n/* harmony export */   normalizeStyle: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle; },\n/* harmony export */   onActivated: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onActivated; },\n/* harmony export */   onBeforeMount: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount; },\n/* harmony export */   onBeforeUnmount: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount; },\n/* harmony export */   onBeforeUpdate: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate; },\n/* harmony export */   onDeactivated: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onDeactivated; },\n/* harmony export */   onErrorCaptured: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured; },\n/* harmony export */   onMounted: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onMounted; },\n/* harmony export */   onRenderTracked: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked; },\n/* harmony export */   onRenderTriggered: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered; },\n/* harmony export */   onScopeDispose: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose; },\n/* harmony export */   onServerPrefetch: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch; },\n/* harmony export */   onUnmounted: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUnmounted; },\n/* harmony export */   onUpdated: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUpdated; },\n/* harmony export */   openBlock: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.openBlock; },\n/* harmony export */   popScopeId: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.popScopeId; },\n/* harmony export */   provide: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.provide; },\n/* harmony export */   proxyRefs: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.proxyRefs; },\n/* harmony export */   pushScopeId: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.pushScopeId; },\n/* harmony export */   queuePostFlushCb: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb; },\n/* harmony export */   reactive: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.reactive; },\n/* harmony export */   readonly: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.readonly; },\n/* harmony export */   ref: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ref; },\n/* harmony export */   registerRuntimeCompiler: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler; },\n/* harmony export */   render: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.render; },\n/* harmony export */   renderList: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderList; },\n/* harmony export */   renderSlot: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderSlot; },\n/* harmony export */   resolveComponent: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveComponent; },\n/* harmony export */   resolveDirective: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDirective; },\n/* harmony export */   resolveDynamicComponent: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent; },\n/* harmony export */   resolveFilter: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveFilter; },\n/* harmony export */   resolveTransitionHooks: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks; },\n/* harmony export */   setBlockTracking: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking; },\n/* harmony export */   setDevtoolsHook: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook; },\n/* harmony export */   setTransitionHooks: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks; },\n/* harmony export */   shallowReactive: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReactive; },\n/* harmony export */   shallowReadonly: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly; },\n/* harmony export */   shallowRef: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowRef; },\n/* harmony export */   ssrContextKey: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey; },\n/* harmony export */   ssrUtils: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrUtils; },\n/* harmony export */   stop: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.stop; },\n/* harmony export */   toDisplayString: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toDisplayString; },\n/* harmony export */   toHandlerKey: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey; },\n/* harmony export */   toHandlers: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlers; },\n/* harmony export */   toRaw: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRaw; },\n/* harmony export */   toRef: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRef; },\n/* harmony export */   toRefs: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRefs; },\n/* harmony export */   toValue: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toValue; },\n/* harmony export */   transformVNodeArgs: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs; },\n/* harmony export */   triggerRef: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.triggerRef; },\n/* harmony export */   unref: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.unref; },\n/* harmony export */   useAttrs: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useAttrs; },\n/* harmony export */   useCssModule: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssModule; },\n/* harmony export */   useCssVars: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssVars; },\n/* harmony export */   useModel: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useModel; },\n/* harmony export */   useSSRContext: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSSRContext; },\n/* harmony export */   useSlots: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSlots; },\n/* harmony export */   useTransitionState: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useTransitionState; },\n/* harmony export */   vModelCheckbox: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelCheckbox; },\n/* harmony export */   vModelDynamic: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelDynamic; },\n/* harmony export */   vModelRadio: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelRadio; },\n/* harmony export */   vModelSelect: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelSelect; },\n/* harmony export */   vModelText: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelText; },\n/* harmony export */   vShow: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vShow; },\n/* harmony export */   version: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.version; },\n/* harmony export */   warn: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.warn; },\n/* harmony export */   watch: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watch; },\n/* harmony export */   watchEffect: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchEffect; },\n/* harmony export */   watchPostEffect: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect; },\n/* harmony export */   watchSyncEffect: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect; },\n/* harmony export */   withAsyncContext: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext; },\n/* harmony export */   withCtx: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withCtx; },\n/* harmony export */   withDefaults: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDefaults; },\n/* harmony export */   withDirectives: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDirectives; },\n/* harmony export */   withKeys: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withKeys; },\n/* harmony export */   withMemo: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withMemo; },\n/* harmony export */   withModifiers: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withModifiers; },\n/* harmony export */   withScopeId: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withScopeId; }\n/* harmony export */ });\n/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/runtime-dom */ \"./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js\");\n/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-dom */ \"./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js\");\n\n\nfunction initDev() {\n  {\n    (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.initCustomFormatter)();\n  }\n}\nif (true) {\n  initDev();\n}\nconst compile = () => {\n  if (true) {\n    (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.warn)(`Runtime compilation is not supported in this build of Vue.` + ` Configure your bundler to alias \"vue\" to \"vue/dist/vue.esm-bundler.js\".`);\n  }\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/vue/dist/vue.runtime.esm-bundler.js?");

/***/ }),

/***/ "./node_modules/xterm/lib/xterm.js":
/*!*****************************************!*\
  !*** ./node_modules/xterm/lib/xterm.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("__webpack_require__(/*! core-js/modules/es.array.push.js */ \"./node_modules/core-js/modules/es.array.push.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.to-reversed.js */ \"./node_modules/core-js/modules/es.typed-array.to-reversed.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.to-sorted.js */ \"./node_modules/core-js/modules/es.typed-array.to-sorted.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.with.js */ \"./node_modules/core-js/modules/es.typed-array.with.js\");\n!function (e, t) {\n  if (true) module.exports = t();else { var s, i; }\n}(self, function () {\n  return (() => {\n    \"use strict\";\n\n    var e = {\n        4567: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.AccessibilityManager = void 0;\n          const s = i(9042),\n            r = i(6114),\n            n = i(9924),\n            o = i(3656),\n            a = i(844),\n            h = i(5596),\n            c = i(9631);\n          class l extends a.Disposable {\n            constructor(e, t) {\n              super(), this._terminal = e, this._renderService = t, this._liveRegionLineCount = 0, this._charsToConsume = [], this._charsToAnnounce = \"\", this._accessibilityTreeRoot = document.createElement(\"div\"), this._accessibilityTreeRoot.classList.add(\"xterm-accessibility\"), this._accessibilityTreeRoot.tabIndex = 0, this._rowContainer = document.createElement(\"div\"), this._rowContainer.setAttribute(\"role\", \"list\"), this._rowContainer.classList.add(\"xterm-accessibility-tree\"), this._rowElements = [];\n              for (let e = 0; e < this._terminal.rows; e++) this._rowElements[e] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[e]);\n              if (this._topBoundaryFocusListener = e => this._onBoundaryFocus(e, 0), this._bottomBoundaryFocusListener = e => this._onBoundaryFocus(e, 1), this._rowElements[0].addEventListener(\"focus\", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener(\"focus\", this._bottomBoundaryFocusListener), this._refreshRowsDimensions(), this._accessibilityTreeRoot.appendChild(this._rowContainer), this._renderRowsDebouncer = new n.TimeBasedDebouncer(this._renderRows.bind(this)), this._refreshRows(), this._liveRegion = document.createElement(\"div\"), this._liveRegion.classList.add(\"live-region\"), this._liveRegion.setAttribute(\"aria-live\", \"assertive\"), this._accessibilityTreeRoot.appendChild(this._liveRegion), !this._terminal.element) throw new Error(\"Cannot enable accessibility before Terminal.open\");\n              this._terminal.element.insertAdjacentElement(\"afterbegin\", this._accessibilityTreeRoot), this.register(this._renderRowsDebouncer), this.register(this._terminal.onResize(e => this._onResize(e.rows))), this.register(this._terminal.onRender(e => this._refreshRows(e.start, e.end))), this.register(this._terminal.onScroll(() => this._refreshRows())), this.register(this._terminal.onA11yChar(e => this._onChar(e))), this.register(this._terminal.onLineFeed(() => this._onChar(\"\\n\"))), this.register(this._terminal.onA11yTab(e => this._onTab(e))), this.register(this._terminal.onKey(e => this._onKey(e.key))), this.register(this._terminal.onBlur(() => this._clearLiveRegion())), this.register(this._renderService.onDimensionsChange(() => this._refreshRowsDimensions())), this._screenDprMonitor = new h.ScreenDprMonitor(window), this.register(this._screenDprMonitor), this._screenDprMonitor.setListener(() => this._refreshRowsDimensions()), this.register((0, o.addDisposableDomListener)(window, \"resize\", () => this._refreshRowsDimensions()));\n            }\n            dispose() {\n              super.dispose(), (0, c.removeElementFromParent)(this._accessibilityTreeRoot), this._rowElements.length = 0;\n            }\n            _onBoundaryFocus(e, t) {\n              const i = e.target,\n                s = this._rowElements[0 === t ? 1 : this._rowElements.length - 2];\n              if (i.getAttribute(\"aria-posinset\") === (0 === t ? \"1\" : `${this._terminal.buffer.lines.length}`)) return;\n              if (e.relatedTarget !== s) return;\n              let r, n;\n              if (0 === t ? (r = i, n = this._rowElements.pop(), this._rowContainer.removeChild(n)) : (r = this._rowElements.shift(), n = i, this._rowContainer.removeChild(r)), r.removeEventListener(\"focus\", this._topBoundaryFocusListener), n.removeEventListener(\"focus\", this._bottomBoundaryFocusListener), 0 === t) {\n                const e = this._createAccessibilityTreeNode();\n                this._rowElements.unshift(e), this._rowContainer.insertAdjacentElement(\"afterbegin\", e);\n              } else {\n                const e = this._createAccessibilityTreeNode();\n                this._rowElements.push(e), this._rowContainer.appendChild(e);\n              }\n              this._rowElements[0].addEventListener(\"focus\", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener(\"focus\", this._bottomBoundaryFocusListener), this._terminal.scrollLines(0 === t ? -1 : 1), this._rowElements[0 === t ? 1 : this._rowElements.length - 2].focus(), e.preventDefault(), e.stopImmediatePropagation();\n            }\n            _onResize(e) {\n              this._rowElements[this._rowElements.length - 1].removeEventListener(\"focus\", this._bottomBoundaryFocusListener);\n              for (let e = this._rowContainer.children.length; e < this._terminal.rows; e++) this._rowElements[e] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[e]);\n              for (; this._rowElements.length > e;) this._rowContainer.removeChild(this._rowElements.pop());\n              this._rowElements[this._rowElements.length - 1].addEventListener(\"focus\", this._bottomBoundaryFocusListener), this._refreshRowsDimensions();\n            }\n            _createAccessibilityTreeNode() {\n              const e = document.createElement(\"div\");\n              return e.setAttribute(\"role\", \"listitem\"), e.tabIndex = -1, this._refreshRowDimensions(e), e;\n            }\n            _onTab(e) {\n              for (let t = 0; t < e; t++) this._onChar(\" \");\n            }\n            _onChar(e) {\n              this._liveRegionLineCount < 21 && (this._charsToConsume.length > 0 ? this._charsToConsume.shift() !== e && (this._charsToAnnounce += e) : this._charsToAnnounce += e, \"\\n\" === e && (this._liveRegionLineCount++, 21 === this._liveRegionLineCount && (this._liveRegion.textContent += s.tooMuchOutput)), r.isMac && this._liveRegion.textContent && this._liveRegion.textContent.length > 0 && !this._liveRegion.parentNode && setTimeout(() => {\n                this._accessibilityTreeRoot.appendChild(this._liveRegion);\n              }, 0));\n            }\n            _clearLiveRegion() {\n              this._liveRegion.textContent = \"\", this._liveRegionLineCount = 0, r.isMac && (0, c.removeElementFromParent)(this._liveRegion);\n            }\n            _onKey(e) {\n              this._clearLiveRegion(), this._charsToConsume.push(e);\n            }\n            _refreshRows(e, t) {\n              this._renderRowsDebouncer.refresh(e, t, this._terminal.rows);\n            }\n            _renderRows(e, t) {\n              const i = this._terminal.buffer,\n                s = i.lines.length.toString();\n              for (let r = e; r <= t; r++) {\n                const e = i.translateBufferLineToString(i.ydisp + r, !0),\n                  t = (i.ydisp + r + 1).toString(),\n                  n = this._rowElements[r];\n                n && (0 === e.length ? n.innerText = \" \" : n.textContent = e, n.setAttribute(\"aria-posinset\", t), n.setAttribute(\"aria-setsize\", s));\n              }\n              this._announceCharacters();\n            }\n            _refreshRowsDimensions() {\n              if (this._renderService.dimensions.actualCellHeight) {\n                this._rowElements.length !== this._terminal.rows && this._onResize(this._terminal.rows);\n                for (let e = 0; e < this._terminal.rows; e++) this._refreshRowDimensions(this._rowElements[e]);\n              }\n            }\n            _refreshRowDimensions(e) {\n              e.style.height = `${this._renderService.dimensions.actualCellHeight}px`;\n            }\n            _announceCharacters() {\n              0 !== this._charsToAnnounce.length && (this._liveRegion.textContent += this._charsToAnnounce, this._charsToAnnounce = \"\");\n            }\n          }\n          t.AccessibilityManager = l;\n        },\n        3614: (e, t) => {\n          function i(e) {\n            return e.replace(/\\r?\\n/g, \"\\r\");\n          }\n          function s(e, t) {\n            return t ? \"\u001b[200~\" + e + \"\u001b[201~\" : e;\n          }\n          function r(e, t, r) {\n            e = s(e = i(e), r.decPrivateModes.bracketedPasteMode), r.triggerDataEvent(e, !0), t.value = \"\";\n          }\n          function n(e, t, i) {\n            const s = i.getBoundingClientRect(),\n              r = e.clientX - s.left - 10,\n              n = e.clientY - s.top - 10;\n            t.style.width = \"20px\", t.style.height = \"20px\", t.style.left = `${r}px`, t.style.top = `${n}px`, t.style.zIndex = \"1000\", t.focus();\n          }\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.rightClickHandler = t.moveTextAreaUnderMouseCursor = t.paste = t.handlePasteEvent = t.copyHandler = t.bracketTextForPaste = t.prepareTextForTerminal = void 0, t.prepareTextForTerminal = i, t.bracketTextForPaste = s, t.copyHandler = function (e, t) {\n            e.clipboardData && e.clipboardData.setData(\"text/plain\", t.selectionText), e.preventDefault();\n          }, t.handlePasteEvent = function (e, t, i) {\n            e.stopPropagation(), e.clipboardData && r(e.clipboardData.getData(\"text/plain\"), t, i);\n          }, t.paste = r, t.moveTextAreaUnderMouseCursor = n, t.rightClickHandler = function (e, t, i, s, r) {\n            n(e, t, i), r && s.rightClickSelect(e), t.value = s.selectionText, t.select();\n          };\n        },\n        7239: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.ColorContrastCache = void 0;\n          const s = i(1505);\n          t.ColorContrastCache = class {\n            constructor() {\n              this._color = new s.TwoKeyMap(), this._css = new s.TwoKeyMap();\n            }\n            setCss(e, t, i) {\n              this._css.set(e, t, i);\n            }\n            getCss(e, t) {\n              return this._css.get(e, t);\n            }\n            setColor(e, t, i) {\n              this._color.set(e, t, i);\n            }\n            getColor(e, t) {\n              return this._color.get(e, t);\n            }\n            clear() {\n              this._color.clear(), this._css.clear();\n            }\n          };\n        },\n        5680: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.ColorManager = t.DEFAULT_ANSI_COLORS = void 0;\n          const s = i(8055),\n            r = i(7239),\n            n = s.css.toColor(\"#ffffff\"),\n            o = s.css.toColor(\"#000000\"),\n            a = s.css.toColor(\"#ffffff\"),\n            h = s.css.toColor(\"#000000\"),\n            c = {\n              css: \"rgba(255, 255, 255, 0.3)\",\n              rgba: 4294967117\n            };\n          t.DEFAULT_ANSI_COLORS = Object.freeze((() => {\n            const e = [s.css.toColor(\"#2e3436\"), s.css.toColor(\"#cc0000\"), s.css.toColor(\"#4e9a06\"), s.css.toColor(\"#c4a000\"), s.css.toColor(\"#3465a4\"), s.css.toColor(\"#75507b\"), s.css.toColor(\"#06989a\"), s.css.toColor(\"#d3d7cf\"), s.css.toColor(\"#555753\"), s.css.toColor(\"#ef2929\"), s.css.toColor(\"#8ae234\"), s.css.toColor(\"#fce94f\"), s.css.toColor(\"#729fcf\"), s.css.toColor(\"#ad7fa8\"), s.css.toColor(\"#34e2e2\"), s.css.toColor(\"#eeeeec\")],\n              t = [0, 95, 135, 175, 215, 255];\n            for (let i = 0; i < 216; i++) {\n              const r = t[i / 36 % 6 | 0],\n                n = t[i / 6 % 6 | 0],\n                o = t[i % 6];\n              e.push({\n                css: s.channels.toCss(r, n, o),\n                rgba: s.channels.toRgba(r, n, o)\n              });\n            }\n            for (let t = 0; t < 24; t++) {\n              const i = 8 + 10 * t;\n              e.push({\n                css: s.channels.toCss(i, i, i),\n                rgba: s.channels.toRgba(i, i, i)\n              });\n            }\n            return e;\n          })()), t.ColorManager = class {\n            constructor(e, i) {\n              this.allowTransparency = i;\n              const l = e.createElement(\"canvas\");\n              l.width = 1, l.height = 1;\n              const d = l.getContext(\"2d\");\n              if (!d) throw new Error(\"Could not get rendering context\");\n              this._ctx = d, this._ctx.globalCompositeOperation = \"copy\", this._litmusColor = this._ctx.createLinearGradient(0, 0, 1, 1), this._contrastCache = new r.ColorContrastCache(), this.colors = {\n                foreground: n,\n                background: o,\n                cursor: a,\n                cursorAccent: h,\n                selectionForeground: void 0,\n                selectionBackgroundTransparent: c,\n                selectionBackgroundOpaque: s.color.blend(o, c),\n                selectionInactiveBackgroundTransparent: c,\n                selectionInactiveBackgroundOpaque: s.color.blend(o, c),\n                ansi: t.DEFAULT_ANSI_COLORS.slice(),\n                contrastCache: this._contrastCache\n              }, this._updateRestoreColors();\n            }\n            onOptionsChange(e, t) {\n              switch (e) {\n                case \"minimumContrastRatio\":\n                  this._contrastCache.clear();\n                  break;\n                case \"allowTransparency\":\n                  this.allowTransparency = t;\n              }\n            }\n            setTheme(e = {}) {\n              this.colors.foreground = this._parseColor(e.foreground, n), this.colors.background = this._parseColor(e.background, o), this.colors.cursor = this._parseColor(e.cursor, a, !0), this.colors.cursorAccent = this._parseColor(e.cursorAccent, h, !0), this.colors.selectionBackgroundTransparent = this._parseColor(e.selectionBackground, c, !0), this.colors.selectionBackgroundOpaque = s.color.blend(this.colors.background, this.colors.selectionBackgroundTransparent), this.colors.selectionInactiveBackgroundTransparent = this._parseColor(e.selectionInactiveBackground, this.colors.selectionBackgroundTransparent, !0), this.colors.selectionInactiveBackgroundOpaque = s.color.blend(this.colors.background, this.colors.selectionInactiveBackgroundTransparent);\n              const i = {\n                css: \"\",\n                rgba: 0\n              };\n              if (this.colors.selectionForeground = e.selectionForeground ? this._parseColor(e.selectionForeground, i) : void 0, this.colors.selectionForeground === i && (this.colors.selectionForeground = void 0), s.color.isOpaque(this.colors.selectionBackgroundTransparent)) {\n                const e = .3;\n                this.colors.selectionBackgroundTransparent = s.color.opacity(this.colors.selectionBackgroundTransparent, e);\n              }\n              if (s.color.isOpaque(this.colors.selectionInactiveBackgroundTransparent)) {\n                const e = .3;\n                this.colors.selectionInactiveBackgroundTransparent = s.color.opacity(this.colors.selectionInactiveBackgroundTransparent, e);\n              }\n              if (this.colors.ansi = t.DEFAULT_ANSI_COLORS.slice(), this.colors.ansi[0] = this._parseColor(e.black, t.DEFAULT_ANSI_COLORS[0]), this.colors.ansi[1] = this._parseColor(e.red, t.DEFAULT_ANSI_COLORS[1]), this.colors.ansi[2] = this._parseColor(e.green, t.DEFAULT_ANSI_COLORS[2]), this.colors.ansi[3] = this._parseColor(e.yellow, t.DEFAULT_ANSI_COLORS[3]), this.colors.ansi[4] = this._parseColor(e.blue, t.DEFAULT_ANSI_COLORS[4]), this.colors.ansi[5] = this._parseColor(e.magenta, t.DEFAULT_ANSI_COLORS[5]), this.colors.ansi[6] = this._parseColor(e.cyan, t.DEFAULT_ANSI_COLORS[6]), this.colors.ansi[7] = this._parseColor(e.white, t.DEFAULT_ANSI_COLORS[7]), this.colors.ansi[8] = this._parseColor(e.brightBlack, t.DEFAULT_ANSI_COLORS[8]), this.colors.ansi[9] = this._parseColor(e.brightRed, t.DEFAULT_ANSI_COLORS[9]), this.colors.ansi[10] = this._parseColor(e.brightGreen, t.DEFAULT_ANSI_COLORS[10]), this.colors.ansi[11] = this._parseColor(e.brightYellow, t.DEFAULT_ANSI_COLORS[11]), this.colors.ansi[12] = this._parseColor(e.brightBlue, t.DEFAULT_ANSI_COLORS[12]), this.colors.ansi[13] = this._parseColor(e.brightMagenta, t.DEFAULT_ANSI_COLORS[13]), this.colors.ansi[14] = this._parseColor(e.brightCyan, t.DEFAULT_ANSI_COLORS[14]), this.colors.ansi[15] = this._parseColor(e.brightWhite, t.DEFAULT_ANSI_COLORS[15]), e.extendedAnsi) {\n                const i = Math.min(this.colors.ansi.length - 16, e.extendedAnsi.length);\n                for (let s = 0; s < i; s++) this.colors.ansi[s + 16] = this._parseColor(e.extendedAnsi[s], t.DEFAULT_ANSI_COLORS[s + 16]);\n              }\n              this._contrastCache.clear(), this._updateRestoreColors();\n            }\n            restoreColor(e) {\n              if (void 0 !== e) switch (e) {\n                case 256:\n                  this.colors.foreground = this._restoreColors.foreground;\n                  break;\n                case 257:\n                  this.colors.background = this._restoreColors.background;\n                  break;\n                case 258:\n                  this.colors.cursor = this._restoreColors.cursor;\n                  break;\n                default:\n                  this.colors.ansi[e] = this._restoreColors.ansi[e];\n              } else for (let e = 0; e < this._restoreColors.ansi.length; ++e) this.colors.ansi[e] = this._restoreColors.ansi[e];\n            }\n            _updateRestoreColors() {\n              this._restoreColors = {\n                foreground: this.colors.foreground,\n                background: this.colors.background,\n                cursor: this.colors.cursor,\n                ansi: this.colors.ansi.slice()\n              };\n            }\n            _parseColor(e, t, i = this.allowTransparency) {\n              if (void 0 === e) return t;\n              if (this._ctx.fillStyle = this._litmusColor, this._ctx.fillStyle = e, \"string\" != typeof this._ctx.fillStyle) return console.warn(`Color: ${e} is invalid using fallback ${t.css}`), t;\n              this._ctx.fillRect(0, 0, 1, 1);\n              const r = this._ctx.getImageData(0, 0, 1, 1).data;\n              if (255 !== r[3]) {\n                if (!i) return console.warn(`Color: ${e} is using transparency, but allowTransparency is false. Using fallback ${t.css}.`), t;\n                const [r, n, o, a] = this._ctx.fillStyle.substring(5, this._ctx.fillStyle.length - 1).split(\",\").map(e => Number(e)),\n                  h = Math.round(255 * a);\n                return {\n                  rgba: s.channels.toRgba(r, n, o, h),\n                  css: e\n                };\n              }\n              return {\n                css: this._ctx.fillStyle,\n                rgba: s.channels.toRgba(r[0], r[1], r[2], r[3])\n              };\n            }\n          };\n        },\n        9631: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.removeElementFromParent = void 0, t.removeElementFromParent = function (...e) {\n            var t;\n            for (const i of e) null === (t = null == i ? void 0 : i.parentElement) || void 0 === t || t.removeChild(i);\n          };\n        },\n        3656: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.addDisposableDomListener = void 0, t.addDisposableDomListener = function (e, t, i, s) {\n            e.addEventListener(t, i, s);\n            let r = !1;\n            return {\n              dispose: () => {\n                r || (r = !0, e.removeEventListener(t, i, s));\n              }\n            };\n          };\n        },\n        6465: function (e, t, i) {\n          var s = this && this.__decorate || function (e, t, i, s) {\n              var r,\n                n = arguments.length,\n                o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;\n              if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);else for (var a = e.length - 1; a >= 0; a--) (r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);\n              return n > 3 && o && Object.defineProperty(t, i, o), o;\n            },\n            r = this && this.__param || function (e, t) {\n              return function (i, s) {\n                t(i, s, e);\n              };\n            };\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.Linkifier2 = void 0;\n          const n = i(2585),\n            o = i(8460),\n            a = i(844),\n            h = i(3656);\n          let c = class extends a.Disposable {\n            constructor(e) {\n              super(), this._bufferService = e, this._linkProviders = [], this._linkCacheDisposables = [], this._isMouseOut = !0, this._activeLine = -1, this._onShowLinkUnderline = this.register(new o.EventEmitter()), this._onHideLinkUnderline = this.register(new o.EventEmitter()), this.register((0, a.getDisposeArrayDisposable)(this._linkCacheDisposables));\n            }\n            get currentLink() {\n              return this._currentLink;\n            }\n            get onShowLinkUnderline() {\n              return this._onShowLinkUnderline.event;\n            }\n            get onHideLinkUnderline() {\n              return this._onHideLinkUnderline.event;\n            }\n            dispose() {\n              super.dispose(), this._lastMouseEvent = void 0;\n            }\n            registerLinkProvider(e) {\n              return this._linkProviders.push(e), {\n                dispose: () => {\n                  const t = this._linkProviders.indexOf(e);\n                  -1 !== t && this._linkProviders.splice(t, 1);\n                }\n              };\n            }\n            attachToDom(e, t, i) {\n              this._element = e, this._mouseService = t, this._renderService = i, this.register((0, h.addDisposableDomListener)(this._element, \"mouseleave\", () => {\n                this._isMouseOut = !0, this._clearCurrentLink();\n              })), this.register((0, h.addDisposableDomListener)(this._element, \"mousemove\", this._onMouseMove.bind(this))), this.register((0, h.addDisposableDomListener)(this._element, \"mousedown\", this._handleMouseDown.bind(this))), this.register((0, h.addDisposableDomListener)(this._element, \"mouseup\", this._handleMouseUp.bind(this)));\n            }\n            _onMouseMove(e) {\n              if (this._lastMouseEvent = e, !this._element || !this._mouseService) return;\n              const t = this._positionFromMouseEvent(e, this._element, this._mouseService);\n              if (!t) return;\n              this._isMouseOut = !1;\n              const i = e.composedPath();\n              for (let e = 0; e < i.length; e++) {\n                const t = i[e];\n                if (t.classList.contains(\"xterm\")) break;\n                if (t.classList.contains(\"xterm-hover\")) return;\n              }\n              this._lastBufferCell && t.x === this._lastBufferCell.x && t.y === this._lastBufferCell.y || (this._onHover(t), this._lastBufferCell = t);\n            }\n            _onHover(e) {\n              if (this._activeLine !== e.y) return this._clearCurrentLink(), void this._askForLink(e, !1);\n              this._currentLink && this._linkAtPosition(this._currentLink.link, e) || (this._clearCurrentLink(), this._askForLink(e, !0));\n            }\n            _askForLink(e, t) {\n              var i, s;\n              this._activeProviderReplies && t || (null === (i = this._activeProviderReplies) || void 0 === i || i.forEach(e => {\n                null == e || e.forEach(e => {\n                  e.link.dispose && e.link.dispose();\n                });\n              }), this._activeProviderReplies = new Map(), this._activeLine = e.y);\n              let r = !1;\n              for (const [i, n] of this._linkProviders.entries()) t ? (null === (s = this._activeProviderReplies) || void 0 === s ? void 0 : s.get(i)) && (r = this._checkLinkProviderResult(i, e, r)) : n.provideLinks(e.y, t => {\n                var s, n;\n                if (this._isMouseOut) return;\n                const o = null == t ? void 0 : t.map(e => ({\n                  link: e\n                }));\n                null === (s = this._activeProviderReplies) || void 0 === s || s.set(i, o), r = this._checkLinkProviderResult(i, e, r), (null === (n = this._activeProviderReplies) || void 0 === n ? void 0 : n.size) === this._linkProviders.length && this._removeIntersectingLinks(e.y, this._activeProviderReplies);\n              });\n            }\n            _removeIntersectingLinks(e, t) {\n              const i = new Set();\n              for (let s = 0; s < t.size; s++) {\n                const r = t.get(s);\n                if (r) for (let t = 0; t < r.length; t++) {\n                  const s = r[t],\n                    n = s.link.range.start.y < e ? 0 : s.link.range.start.x,\n                    o = s.link.range.end.y > e ? this._bufferService.cols : s.link.range.end.x;\n                  for (let e = n; e <= o; e++) {\n                    if (i.has(e)) {\n                      r.splice(t--, 1);\n                      break;\n                    }\n                    i.add(e);\n                  }\n                }\n              }\n            }\n            _checkLinkProviderResult(e, t, i) {\n              var s;\n              if (!this._activeProviderReplies) return i;\n              const r = this._activeProviderReplies.get(e);\n              let n = !1;\n              for (let t = 0; t < e; t++) this._activeProviderReplies.has(t) && !this._activeProviderReplies.get(t) || (n = !0);\n              if (!n && r) {\n                const e = r.find(e => this._linkAtPosition(e.link, t));\n                e && (i = !0, this._handleNewLink(e));\n              }\n              if (this._activeProviderReplies.size === this._linkProviders.length && !i) for (let e = 0; e < this._activeProviderReplies.size; e++) {\n                const r = null === (s = this._activeProviderReplies.get(e)) || void 0 === s ? void 0 : s.find(e => this._linkAtPosition(e.link, t));\n                if (r) {\n                  i = !0, this._handleNewLink(r);\n                  break;\n                }\n              }\n              return i;\n            }\n            _handleMouseDown() {\n              this._mouseDownLink = this._currentLink;\n            }\n            _handleMouseUp(e) {\n              if (!this._element || !this._mouseService || !this._currentLink) return;\n              const t = this._positionFromMouseEvent(e, this._element, this._mouseService);\n              t && this._mouseDownLink === this._currentLink && this._linkAtPosition(this._currentLink.link, t) && this._currentLink.link.activate(e, this._currentLink.link.text);\n            }\n            _clearCurrentLink(e, t) {\n              this._element && this._currentLink && this._lastMouseEvent && (!e || !t || this._currentLink.link.range.start.y >= e && this._currentLink.link.range.end.y <= t) && (this._linkLeave(this._element, this._currentLink.link, this._lastMouseEvent), this._currentLink = void 0, (0, a.disposeArray)(this._linkCacheDisposables));\n            }\n            _handleNewLink(e) {\n              if (!this._element || !this._lastMouseEvent || !this._mouseService) return;\n              const t = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);\n              t && this._linkAtPosition(e.link, t) && (this._currentLink = e, this._currentLink.state = {\n                decorations: {\n                  underline: void 0 === e.link.decorations || e.link.decorations.underline,\n                  pointerCursor: void 0 === e.link.decorations || e.link.decorations.pointerCursor\n                },\n                isHovered: !0\n              }, this._linkHover(this._element, e.link, this._lastMouseEvent), e.link.decorations = {}, Object.defineProperties(e.link.decorations, {\n                pointerCursor: {\n                  get: () => {\n                    var e, t;\n                    return null === (t = null === (e = this._currentLink) || void 0 === e ? void 0 : e.state) || void 0 === t ? void 0 : t.decorations.pointerCursor;\n                  },\n                  set: e => {\n                    var t, i;\n                    (null === (t = this._currentLink) || void 0 === t ? void 0 : t.state) && this._currentLink.state.decorations.pointerCursor !== e && (this._currentLink.state.decorations.pointerCursor = e, this._currentLink.state.isHovered && (null === (i = this._element) || void 0 === i || i.classList.toggle(\"xterm-cursor-pointer\", e)));\n                  }\n                },\n                underline: {\n                  get: () => {\n                    var e, t;\n                    return null === (t = null === (e = this._currentLink) || void 0 === e ? void 0 : e.state) || void 0 === t ? void 0 : t.decorations.underline;\n                  },\n                  set: t => {\n                    var i, s, r;\n                    (null === (i = this._currentLink) || void 0 === i ? void 0 : i.state) && (null === (r = null === (s = this._currentLink) || void 0 === s ? void 0 : s.state) || void 0 === r ? void 0 : r.decorations.underline) !== t && (this._currentLink.state.decorations.underline = t, this._currentLink.state.isHovered && this._fireUnderlineEvent(e.link, t));\n                  }\n                }\n              }), this._renderService && this._linkCacheDisposables.push(this._renderService.onRenderedViewportChange(e => {\n                const t = 0 === e.start ? 0 : e.start + 1 + this._bufferService.buffer.ydisp;\n                this._clearCurrentLink(t, e.end + 1 + this._bufferService.buffer.ydisp);\n              })));\n            }\n            _linkHover(e, t, i) {\n              var s;\n              (null === (s = this._currentLink) || void 0 === s ? void 0 : s.state) && (this._currentLink.state.isHovered = !0, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(t, !0), this._currentLink.state.decorations.pointerCursor && e.classList.add(\"xterm-cursor-pointer\")), t.hover && t.hover(i, t.text);\n            }\n            _fireUnderlineEvent(e, t) {\n              const i = e.range,\n                s = this._bufferService.buffer.ydisp,\n                r = this._createLinkUnderlineEvent(i.start.x - 1, i.start.y - s - 1, i.end.x, i.end.y - s - 1, void 0);\n              (t ? this._onShowLinkUnderline : this._onHideLinkUnderline).fire(r);\n            }\n            _linkLeave(e, t, i) {\n              var s;\n              (null === (s = this._currentLink) || void 0 === s ? void 0 : s.state) && (this._currentLink.state.isHovered = !1, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(t, !1), this._currentLink.state.decorations.pointerCursor && e.classList.remove(\"xterm-cursor-pointer\")), t.leave && t.leave(i, t.text);\n            }\n            _linkAtPosition(e, t) {\n              const i = e.range.start.y === e.range.end.y,\n                s = e.range.start.y < t.y,\n                r = e.range.end.y > t.y;\n              return (i && e.range.start.x <= t.x && e.range.end.x >= t.x || s && e.range.end.x >= t.x || r && e.range.start.x <= t.x || s && r) && e.range.start.y <= t.y && e.range.end.y >= t.y;\n            }\n            _positionFromMouseEvent(e, t, i) {\n              const s = i.getCoords(e, t, this._bufferService.cols, this._bufferService.rows);\n              if (s) return {\n                x: s[0],\n                y: s[1] + this._bufferService.buffer.ydisp\n              };\n            }\n            _createLinkUnderlineEvent(e, t, i, s, r) {\n              return {\n                x1: e,\n                y1: t,\n                x2: i,\n                y2: s,\n                cols: this._bufferService.cols,\n                fg: r\n              };\n            }\n          };\n          c = s([r(0, n.IBufferService)], c), t.Linkifier2 = c;\n        },\n        9042: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.tooMuchOutput = t.promptLabel = void 0, t.promptLabel = \"Terminal input\", t.tooMuchOutput = \"Too much output to announce, navigate to rows manually to read\";\n        },\n        2962: function (e, t, i) {\n          var s = this && this.__decorate || function (e, t, i, s) {\n              var r,\n                n = arguments.length,\n                o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;\n              if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);else for (var a = e.length - 1; a >= 0; a--) (r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);\n              return n > 3 && o && Object.defineProperty(t, i, o), o;\n            },\n            r = this && this.__param || function (e, t) {\n              return function (i, s) {\n                t(i, s, e);\n              };\n            };\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.OscLinkProvider = void 0;\n          const n = i(511),\n            o = i(2585);\n          let a = class {\n            constructor(e, t, i) {\n              this._bufferService = e, this._optionsService = t, this._oscLinkService = i;\n            }\n            provideLinks(e, t) {\n              var i;\n              const s = this._bufferService.buffer.lines.get(e - 1);\n              if (!s) return void t(void 0);\n              const r = [],\n                o = this._optionsService.rawOptions.linkHandler,\n                a = new n.CellData(),\n                c = s.getTrimmedLength();\n              let l = -1,\n                d = -1,\n                _ = !1;\n              for (let t = 0; t < c; t++) if (-1 !== d || s.hasContent(t)) {\n                if (s.loadCell(t, a), a.hasExtendedAttrs() && a.extended.urlId) {\n                  if (-1 === d) {\n                    d = t, l = a.extended.urlId;\n                    continue;\n                  }\n                  _ = a.extended.urlId !== l;\n                } else -1 !== d && (_ = !0);\n                if (_ || -1 !== d && t === c - 1) {\n                  const s = null === (i = this._oscLinkService.getLinkData(l)) || void 0 === i ? void 0 : i.uri;\n                  if (s) {\n                    const i = {\n                      start: {\n                        x: d + 1,\n                        y: e\n                      },\n                      end: {\n                        x: t + (_ || t !== c - 1 ? 0 : 1),\n                        y: e\n                      }\n                    };\n                    r.push({\n                      text: s,\n                      range: i,\n                      activate: (e, t) => o ? o.activate(e, t, i) : h(0, t),\n                      hover: (e, t) => {\n                        var s;\n                        return null === (s = null == o ? void 0 : o.hover) || void 0 === s ? void 0 : s.call(o, e, t, i);\n                      },\n                      leave: (e, t) => {\n                        var s;\n                        return null === (s = null == o ? void 0 : o.leave) || void 0 === s ? void 0 : s.call(o, e, t, i);\n                      }\n                    });\n                  }\n                  _ = !1, a.hasExtendedAttrs() && a.extended.urlId ? (d = t, l = a.extended.urlId) : (d = -1, l = -1);\n                }\n              }\n              t(r);\n            }\n          };\n          function h(e, t) {\n            if (confirm(`Do you want to navigate to ${t}?`)) {\n              const e = window.open();\n              if (e) {\n                try {\n                  e.opener = null;\n                } catch (e) {}\n                e.location.href = t;\n              } else console.warn(\"Opening link blocked as opener could not be cleared\");\n            }\n          }\n          a = s([r(0, o.IBufferService), r(1, o.IOptionsService), r(2, o.IOscLinkService)], a), t.OscLinkProvider = a;\n        },\n        6193: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.RenderDebouncer = void 0, t.RenderDebouncer = class {\n            constructor(e, t) {\n              this._parentWindow = e, this._renderCallback = t, this._refreshCallbacks = [];\n            }\n            dispose() {\n              this._animationFrame && (this._parentWindow.cancelAnimationFrame(this._animationFrame), this._animationFrame = void 0);\n            }\n            addRefreshCallback(e) {\n              return this._refreshCallbacks.push(e), this._animationFrame || (this._animationFrame = this._parentWindow.requestAnimationFrame(() => this._innerRefresh())), this._animationFrame;\n            }\n            refresh(e, t, i) {\n              this._rowCount = i, e = void 0 !== e ? e : 0, t = void 0 !== t ? t : this._rowCount - 1, this._rowStart = void 0 !== this._rowStart ? Math.min(this._rowStart, e) : e, this._rowEnd = void 0 !== this._rowEnd ? Math.max(this._rowEnd, t) : t, this._animationFrame || (this._animationFrame = this._parentWindow.requestAnimationFrame(() => this._innerRefresh()));\n            }\n            _innerRefresh() {\n              if (this._animationFrame = void 0, void 0 === this._rowStart || void 0 === this._rowEnd || void 0 === this._rowCount) return void this._runRefreshCallbacks();\n              const e = Math.max(this._rowStart, 0),\n                t = Math.min(this._rowEnd, this._rowCount - 1);\n              this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(e, t), this._runRefreshCallbacks();\n            }\n            _runRefreshCallbacks() {\n              for (const e of this._refreshCallbacks) e(0);\n              this._refreshCallbacks = [];\n            }\n          };\n        },\n        5596: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.ScreenDprMonitor = void 0;\n          const s = i(844);\n          class r extends s.Disposable {\n            constructor(e) {\n              super(), this._parentWindow = e, this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio;\n            }\n            setListener(e) {\n              this._listener && this.clearListener(), this._listener = e, this._outerListener = () => {\n                this._listener && (this._listener(this._parentWindow.devicePixelRatio, this._currentDevicePixelRatio), this._updateDpr());\n              }, this._updateDpr();\n            }\n            dispose() {\n              super.dispose(), this.clearListener();\n            }\n            _updateDpr() {\n              var e;\n              this._outerListener && (null === (e = this._resolutionMediaMatchList) || void 0 === e || e.removeListener(this._outerListener), this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this._resolutionMediaMatchList = this._parentWindow.matchMedia(`screen and (resolution: ${this._parentWindow.devicePixelRatio}dppx)`), this._resolutionMediaMatchList.addListener(this._outerListener));\n            }\n            clearListener() {\n              this._resolutionMediaMatchList && this._listener && this._outerListener && (this._resolutionMediaMatchList.removeListener(this._outerListener), this._resolutionMediaMatchList = void 0, this._listener = void 0, this._outerListener = void 0);\n            }\n          }\n          t.ScreenDprMonitor = r;\n        },\n        3236: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.Terminal = void 0;\n          const s = i(2950),\n            r = i(1680),\n            n = i(3614),\n            o = i(2584),\n            a = i(5435),\n            h = i(9312),\n            c = i(6114),\n            l = i(3656),\n            d = i(9042),\n            _ = i(4567),\n            u = i(1296),\n            f = i(7399),\n            v = i(8460),\n            g = i(8437),\n            p = i(5680),\n            S = i(3230),\n            m = i(4725),\n            C = i(428),\n            b = i(8934),\n            y = i(6465),\n            w = i(5114),\n            E = i(8969),\n            L = i(8055),\n            R = i(4269),\n            k = i(5941),\n            D = i(3107),\n            A = i(5744),\n            x = i(9074),\n            B = i(2585),\n            T = i(2962),\n            M = \"undefined\" != typeof window ? window.document : null;\n          class O extends E.CoreTerminal {\n            constructor(e = {}) {\n              super(e), this.browser = c, this._keyDownHandled = !1, this._keyDownSeen = !1, this._keyPressHandled = !1, this._unprocessedDeadKey = !1, this._onCursorMove = new v.EventEmitter(), this._onKey = new v.EventEmitter(), this._onRender = new v.EventEmitter(), this._onSelectionChange = new v.EventEmitter(), this._onTitleChange = new v.EventEmitter(), this._onBell = new v.EventEmitter(), this._onFocus = new v.EventEmitter(), this._onBlur = new v.EventEmitter(), this._onA11yCharEmitter = new v.EventEmitter(), this._onA11yTabEmitter = new v.EventEmitter(), this._setup(), this.linkifier2 = this.register(this._instantiationService.createInstance(y.Linkifier2)), this.linkifier2.registerLinkProvider(this._instantiationService.createInstance(T.OscLinkProvider)), this._decorationService = this._instantiationService.createInstance(x.DecorationService), this._instantiationService.setService(B.IDecorationService, this._decorationService), this.register(this._inputHandler.onRequestBell(() => this._onBell.fire())), this.register(this._inputHandler.onRequestRefreshRows((e, t) => this.refresh(e, t))), this.register(this._inputHandler.onRequestSendFocus(() => this._reportFocus())), this.register(this._inputHandler.onRequestReset(() => this.reset())), this.register(this._inputHandler.onRequestWindowsOptionsReport(e => this._reportWindowsOptions(e))), this.register(this._inputHandler.onColor(e => this._handleColorEvent(e))), this.register((0, v.forwardEvent)(this._inputHandler.onCursorMove, this._onCursorMove)), this.register((0, v.forwardEvent)(this._inputHandler.onTitleChange, this._onTitleChange)), this.register((0, v.forwardEvent)(this._inputHandler.onA11yChar, this._onA11yCharEmitter)), this.register((0, v.forwardEvent)(this._inputHandler.onA11yTab, this._onA11yTabEmitter)), this.register(this._bufferService.onResize(e => this._afterResize(e.cols, e.rows)));\n            }\n            get onCursorMove() {\n              return this._onCursorMove.event;\n            }\n            get onKey() {\n              return this._onKey.event;\n            }\n            get onRender() {\n              return this._onRender.event;\n            }\n            get onSelectionChange() {\n              return this._onSelectionChange.event;\n            }\n            get onTitleChange() {\n              return this._onTitleChange.event;\n            }\n            get onBell() {\n              return this._onBell.event;\n            }\n            get onFocus() {\n              return this._onFocus.event;\n            }\n            get onBlur() {\n              return this._onBlur.event;\n            }\n            get onA11yChar() {\n              return this._onA11yCharEmitter.event;\n            }\n            get onA11yTab() {\n              return this._onA11yTabEmitter.event;\n            }\n            _handleColorEvent(e) {\n              var t, i;\n              if (this._colorManager) {\n                for (const t of e) {\n                  let e,\n                    i = \"\";\n                  switch (t.index) {\n                    case 256:\n                      e = \"foreground\", i = \"10\";\n                      break;\n                    case 257:\n                      e = \"background\", i = \"11\";\n                      break;\n                    case 258:\n                      e = \"cursor\", i = \"12\";\n                      break;\n                    default:\n                      e = \"ansi\", i = \"4;\" + t.index;\n                  }\n                  switch (t.type) {\n                    case 0:\n                      const s = L.color.toColorRGB(\"ansi\" === e ? this._colorManager.colors.ansi[t.index] : this._colorManager.colors[e]);\n                      this.coreService.triggerDataEvent(`${o.C0.ESC}]${i};${(0, k.toRgbString)(s)}${o.C1_ESCAPED.ST}`);\n                      break;\n                    case 1:\n                      \"ansi\" === e ? this._colorManager.colors.ansi[t.index] = L.rgba.toColor(...t.color) : this._colorManager.colors[e] = L.rgba.toColor(...t.color);\n                      break;\n                    case 2:\n                      this._colorManager.restoreColor(t.index);\n                  }\n                }\n                null === (t = this._renderService) || void 0 === t || t.setColors(this._colorManager.colors), null === (i = this.viewport) || void 0 === i || i.onThemeChange(this._colorManager.colors);\n              }\n            }\n            dispose() {\n              var e, t, i;\n              this._isDisposed || (super.dispose(), null === (e = this._renderService) || void 0 === e || e.dispose(), this._customKeyEventHandler = void 0, this.write = () => {}, null === (i = null === (t = this.element) || void 0 === t ? void 0 : t.parentNode) || void 0 === i || i.removeChild(this.element));\n            }\n            _setup() {\n              super._setup(), this._customKeyEventHandler = void 0;\n            }\n            get buffer() {\n              return this.buffers.active;\n            }\n            focus() {\n              this.textarea && this.textarea.focus({\n                preventScroll: !0\n              });\n            }\n            _updateOptions(e) {\n              var t, i, s, r;\n              switch (super._updateOptions(e), e) {\n                case \"fontFamily\":\n                case \"fontSize\":\n                  null === (t = this._renderService) || void 0 === t || t.clear(), null === (i = this._charSizeService) || void 0 === i || i.measure();\n                  break;\n                case \"cursorBlink\":\n                case \"cursorStyle\":\n                  this.refresh(this.buffer.y, this.buffer.y);\n                  break;\n                case \"customGlyphs\":\n                case \"drawBoldTextInBrightColors\":\n                case \"letterSpacing\":\n                case \"lineHeight\":\n                case \"fontWeight\":\n                case \"fontWeightBold\":\n                case \"minimumContrastRatio\":\n                  this._renderService && (this._renderService.clear(), this._renderService.onResize(this.cols, this.rows), this.refresh(0, this.rows - 1));\n                  break;\n                case \"scrollback\":\n                  null === (s = this.viewport) || void 0 === s || s.syncScrollArea();\n                  break;\n                case \"screenReaderMode\":\n                  this.optionsService.rawOptions.screenReaderMode ? !this._accessibilityManager && this._renderService && (this._accessibilityManager = new _.AccessibilityManager(this, this._renderService)) : (null === (r = this._accessibilityManager) || void 0 === r || r.dispose(), this._accessibilityManager = void 0);\n                  break;\n                case \"tabStopWidth\":\n                  this.buffers.setupTabStops();\n                  break;\n                case \"theme\":\n                  this._setTheme(this.optionsService.rawOptions.theme);\n              }\n            }\n            _onTextAreaFocus(e) {\n              this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(o.C0.ESC + \"[I\"), this.updateCursorStyle(e), this.element.classList.add(\"focus\"), this._showCursor(), this._onFocus.fire();\n            }\n            blur() {\n              var e;\n              return null === (e = this.textarea) || void 0 === e ? void 0 : e.blur();\n            }\n            _onTextAreaBlur() {\n              this.textarea.value = \"\", this.refresh(this.buffer.y, this.buffer.y), this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(o.C0.ESC + \"[O\"), this.element.classList.remove(\"focus\"), this._onBlur.fire();\n            }\n            _syncTextArea() {\n              if (!this.textarea || !this.buffer.isCursorInViewport || this._compositionHelper.isComposing || !this._renderService) return;\n              const e = this.buffer.ybase + this.buffer.y,\n                t = this.buffer.lines.get(e);\n              if (!t) return;\n              const i = Math.min(this.buffer.x, this.cols - 1),\n                s = this._renderService.dimensions.actualCellHeight,\n                r = t.getWidth(i),\n                n = this._renderService.dimensions.actualCellWidth * r,\n                o = this.buffer.y * this._renderService.dimensions.actualCellHeight,\n                a = i * this._renderService.dimensions.actualCellWidth;\n              this.textarea.style.left = a + \"px\", this.textarea.style.top = o + \"px\", this.textarea.style.width = n + \"px\", this.textarea.style.height = s + \"px\", this.textarea.style.lineHeight = s + \"px\", this.textarea.style.zIndex = \"-5\";\n            }\n            _initGlobal() {\n              this._bindKeys(), this.register((0, l.addDisposableDomListener)(this.element, \"copy\", e => {\n                this.hasSelection() && (0, n.copyHandler)(e, this._selectionService);\n              }));\n              const e = e => (0, n.handlePasteEvent)(e, this.textarea, this.coreService);\n              this.register((0, l.addDisposableDomListener)(this.textarea, \"paste\", e)), this.register((0, l.addDisposableDomListener)(this.element, \"paste\", e)), c.isFirefox ? this.register((0, l.addDisposableDomListener)(this.element, \"mousedown\", e => {\n                2 === e.button && (0, n.rightClickHandler)(e, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);\n              })) : this.register((0, l.addDisposableDomListener)(this.element, \"contextmenu\", e => {\n                (0, n.rightClickHandler)(e, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);\n              })), c.isLinux && this.register((0, l.addDisposableDomListener)(this.element, \"auxclick\", e => {\n                1 === e.button && (0, n.moveTextAreaUnderMouseCursor)(e, this.textarea, this.screenElement);\n              }));\n            }\n            _bindKeys() {\n              this.register((0, l.addDisposableDomListener)(this.textarea, \"keyup\", e => this._keyUp(e), !0)), this.register((0, l.addDisposableDomListener)(this.textarea, \"keydown\", e => this._keyDown(e), !0)), this.register((0, l.addDisposableDomListener)(this.textarea, \"keypress\", e => this._keyPress(e), !0)), this.register((0, l.addDisposableDomListener)(this.textarea, \"compositionstart\", () => this._compositionHelper.compositionstart())), this.register((0, l.addDisposableDomListener)(this.textarea, \"compositionupdate\", e => this._compositionHelper.compositionupdate(e))), this.register((0, l.addDisposableDomListener)(this.textarea, \"compositionend\", () => this._compositionHelper.compositionend())), this.register((0, l.addDisposableDomListener)(this.textarea, \"input\", e => this._inputEvent(e), !0)), this.register(this.onRender(() => this._compositionHelper.updateCompositionElements()));\n            }\n            open(e) {\n              var t;\n              if (!e) throw new Error(\"Terminal requires a parent element.\");\n              e.isConnected || this._logService.debug(\"Terminal.open was called on an element that was not attached to the DOM\"), this._document = e.ownerDocument, this.element = this._document.createElement(\"div\"), this.element.dir = \"ltr\", this.element.classList.add(\"terminal\"), this.element.classList.add(\"xterm\"), this.element.setAttribute(\"tabindex\", \"0\"), e.appendChild(this.element);\n              const i = M.createDocumentFragment();\n              this._viewportElement = M.createElement(\"div\"), this._viewportElement.classList.add(\"xterm-viewport\"), i.appendChild(this._viewportElement), this._viewportScrollArea = M.createElement(\"div\"), this._viewportScrollArea.classList.add(\"xterm-scroll-area\"), this._viewportElement.appendChild(this._viewportScrollArea), this.screenElement = M.createElement(\"div\"), this.screenElement.classList.add(\"xterm-screen\"), this._helperContainer = M.createElement(\"div\"), this._helperContainer.classList.add(\"xterm-helpers\"), this.screenElement.appendChild(this._helperContainer), i.appendChild(this.screenElement), this.textarea = M.createElement(\"textarea\"), this.textarea.classList.add(\"xterm-helper-textarea\"), this.textarea.setAttribute(\"aria-label\", d.promptLabel), this.textarea.setAttribute(\"aria-multiline\", \"false\"), this.textarea.setAttribute(\"autocorrect\", \"off\"), this.textarea.setAttribute(\"autocapitalize\", \"off\"), this.textarea.setAttribute(\"spellcheck\", \"false\"), this.textarea.tabIndex = 0, this.register((0, l.addDisposableDomListener)(this.textarea, \"focus\", e => this._onTextAreaFocus(e))), this.register((0, l.addDisposableDomListener)(this.textarea, \"blur\", () => this._onTextAreaBlur())), this._helperContainer.appendChild(this.textarea), this._coreBrowserService = this._instantiationService.createInstance(w.CoreBrowserService, this.textarea, null !== (t = this._document.defaultView) && void 0 !== t ? t : window), this._instantiationService.setService(m.ICoreBrowserService, this._coreBrowserService), this._charSizeService = this._instantiationService.createInstance(C.CharSizeService, this._document, this._helperContainer), this._instantiationService.setService(m.ICharSizeService, this._charSizeService), this._theme = this.options.theme || this._theme, this._colorManager = new p.ColorManager(M, this.options.allowTransparency), this.register(this.optionsService.onOptionChange(e => this._colorManager.onOptionsChange(e, this.optionsService.rawOptions[e]))), this._colorManager.setTheme(this._theme), this._characterJoinerService = this._instantiationService.createInstance(R.CharacterJoinerService), this._instantiationService.setService(m.ICharacterJoinerService, this._characterJoinerService);\n              const n = this._createRenderer();\n              this._renderService = this.register(this._instantiationService.createInstance(S.RenderService, n, this.rows, this.screenElement)), this._instantiationService.setService(m.IRenderService, this._renderService), this.register(this._renderService.onRenderedViewportChange(e => this._onRender.fire(e))), this.onResize(e => this._renderService.resize(e.cols, e.rows)), this._compositionView = M.createElement(\"div\"), this._compositionView.classList.add(\"composition-view\"), this._compositionHelper = this._instantiationService.createInstance(s.CompositionHelper, this.textarea, this._compositionView), this._helperContainer.appendChild(this._compositionView), this.element.appendChild(i), this._mouseService = this._instantiationService.createInstance(b.MouseService), this._instantiationService.setService(m.IMouseService, this._mouseService), this.viewport = this._instantiationService.createInstance(r.Viewport, e => this.scrollLines(e, !0, 1), this._viewportElement, this._viewportScrollArea, this.element), this.viewport.onThemeChange(this._colorManager.colors), this.register(this._inputHandler.onRequestSyncScrollBar(() => this.viewport.syncScrollArea())), this.register(this.viewport), this.register(this.onCursorMove(() => {\n                this._renderService.onCursorMove(), this._syncTextArea();\n              })), this.register(this.onResize(() => this._renderService.onResize(this.cols, this.rows))), this.register(this.onBlur(() => this._renderService.onBlur())), this.register(this.onFocus(() => this._renderService.onFocus())), this.register(this._renderService.onDimensionsChange(() => this.viewport.syncScrollArea())), this._selectionService = this.register(this._instantiationService.createInstance(h.SelectionService, this.element, this.screenElement, this.linkifier2)), this._instantiationService.setService(m.ISelectionService, this._selectionService), this.register(this._selectionService.onRequestScrollLines(e => this.scrollLines(e.amount, e.suppressScrollEvent))), this.register(this._selectionService.onSelectionChange(() => this._onSelectionChange.fire())), this.register(this._selectionService.onRequestRedraw(e => this._renderService.onSelectionChanged(e.start, e.end, e.columnSelectMode))), this.register(this._selectionService.onLinuxMouseSelection(e => {\n                this.textarea.value = e, this.textarea.focus(), this.textarea.select();\n              })), this.register(this._onScroll.event(e => {\n                this.viewport.syncScrollArea(), this._selectionService.refresh();\n              })), this.register((0, l.addDisposableDomListener)(this._viewportElement, \"scroll\", () => this._selectionService.refresh())), this.linkifier2.attachToDom(this.screenElement, this._mouseService, this._renderService), this.register(this._instantiationService.createInstance(D.BufferDecorationRenderer, this.screenElement)), this.register((0, l.addDisposableDomListener)(this.element, \"mousedown\", e => this._selectionService.onMouseDown(e))), this.coreMouseService.areMouseEventsActive ? (this._selectionService.disable(), this.element.classList.add(\"enable-mouse-events\")) : this._selectionService.enable(), this.options.screenReaderMode && (this._accessibilityManager = new _.AccessibilityManager(this, this._renderService)), this.options.overviewRulerWidth && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(A.OverviewRulerRenderer, this._viewportElement, this.screenElement))), this.optionsService.onOptionChange(() => {\n                !this._overviewRulerRenderer && this.options.overviewRulerWidth && this._viewportElement && this.screenElement && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(A.OverviewRulerRenderer, this._viewportElement, this.screenElement)));\n              }), this._charSizeService.measure(), this.refresh(0, this.rows - 1), this._initGlobal(), this.bindMouse();\n            }\n            _createRenderer() {\n              return this._instantiationService.createInstance(u.DomRenderer, this._colorManager.colors, this.element, this.screenElement, this._viewportElement, this.linkifier2);\n            }\n            _setTheme(e) {\n              var t, i, s;\n              this._theme = e, null === (t = this._colorManager) || void 0 === t || t.setTheme(e), null === (i = this._renderService) || void 0 === i || i.setColors(this._colorManager.colors), null === (s = this.viewport) || void 0 === s || s.onThemeChange(this._colorManager.colors);\n            }\n            bindMouse() {\n              const e = this,\n                t = this.element;\n              function i(t) {\n                const i = e._mouseService.getMouseReportCoords(t, e.screenElement);\n                if (!i) return !1;\n                let s, r;\n                switch (t.overrideType || t.type) {\n                  case \"mousemove\":\n                    r = 32, void 0 === t.buttons ? (s = 3, void 0 !== t.button && (s = t.button < 3 ? t.button : 3)) : s = 1 & t.buttons ? 0 : 4 & t.buttons ? 1 : 2 & t.buttons ? 2 : 3;\n                    break;\n                  case \"mouseup\":\n                    r = 0, s = t.button < 3 ? t.button : 3;\n                    break;\n                  case \"mousedown\":\n                    r = 1, s = t.button < 3 ? t.button : 3;\n                    break;\n                  case \"wheel\":\n                    if (0 === e.viewport.getLinesScrolled(t)) return !1;\n                    r = t.deltaY < 0 ? 0 : 1, s = 4;\n                    break;\n                  default:\n                    return !1;\n                }\n                return !(void 0 === r || void 0 === s || s > 4) && e.coreMouseService.triggerMouseEvent({\n                  col: i.col,\n                  row: i.row,\n                  x: i.x,\n                  y: i.y,\n                  button: s,\n                  action: r,\n                  ctrl: t.ctrlKey,\n                  alt: t.altKey,\n                  shift: t.shiftKey\n                });\n              }\n              const s = {\n                  mouseup: null,\n                  wheel: null,\n                  mousedrag: null,\n                  mousemove: null\n                },\n                r = {\n                  mouseup: e => (i(e), e.buttons || (this._document.removeEventListener(\"mouseup\", s.mouseup), s.mousedrag && this._document.removeEventListener(\"mousemove\", s.mousedrag)), this.cancel(e)),\n                  wheel: e => (i(e), this.cancel(e, !0)),\n                  mousedrag: e => {\n                    e.buttons && i(e);\n                  },\n                  mousemove: e => {\n                    e.buttons || i(e);\n                  }\n                };\n              this.register(this.coreMouseService.onProtocolChange(e => {\n                e ? (\"debug\" === this.optionsService.rawOptions.logLevel && this._logService.debug(\"Binding to mouse events:\", this.coreMouseService.explainEvents(e)), this.element.classList.add(\"enable-mouse-events\"), this._selectionService.disable()) : (this._logService.debug(\"Unbinding from mouse events.\"), this.element.classList.remove(\"enable-mouse-events\"), this._selectionService.enable()), 8 & e ? s.mousemove || (t.addEventListener(\"mousemove\", r.mousemove), s.mousemove = r.mousemove) : (t.removeEventListener(\"mousemove\", s.mousemove), s.mousemove = null), 16 & e ? s.wheel || (t.addEventListener(\"wheel\", r.wheel, {\n                  passive: !1\n                }), s.wheel = r.wheel) : (t.removeEventListener(\"wheel\", s.wheel), s.wheel = null), 2 & e ? s.mouseup || (s.mouseup = r.mouseup) : (this._document.removeEventListener(\"mouseup\", s.mouseup), s.mouseup = null), 4 & e ? s.mousedrag || (s.mousedrag = r.mousedrag) : (this._document.removeEventListener(\"mousemove\", s.mousedrag), s.mousedrag = null);\n              })), this.coreMouseService.activeProtocol = this.coreMouseService.activeProtocol, this.register((0, l.addDisposableDomListener)(t, \"mousedown\", e => {\n                if (e.preventDefault(), this.focus(), this.coreMouseService.areMouseEventsActive && !this._selectionService.shouldForceSelection(e)) return i(e), s.mouseup && this._document.addEventListener(\"mouseup\", s.mouseup), s.mousedrag && this._document.addEventListener(\"mousemove\", s.mousedrag), this.cancel(e);\n              })), this.register((0, l.addDisposableDomListener)(t, \"wheel\", e => {\n                if (!s.wheel) {\n                  if (!this.buffer.hasScrollback) {\n                    const t = this.viewport.getLinesScrolled(e);\n                    if (0 === t) return;\n                    const i = o.C0.ESC + (this.coreService.decPrivateModes.applicationCursorKeys ? \"O\" : \"[\") + (e.deltaY < 0 ? \"A\" : \"B\");\n                    let s = \"\";\n                    for (let e = 0; e < Math.abs(t); e++) s += i;\n                    return this.coreService.triggerDataEvent(s, !0), this.cancel(e, !0);\n                  }\n                  return this.viewport.onWheel(e) ? this.cancel(e) : void 0;\n                }\n              }, {\n                passive: !1\n              })), this.register((0, l.addDisposableDomListener)(t, \"touchstart\", e => {\n                if (!this.coreMouseService.areMouseEventsActive) return this.viewport.onTouchStart(e), this.cancel(e);\n              }, {\n                passive: !0\n              })), this.register((0, l.addDisposableDomListener)(t, \"touchmove\", e => {\n                if (!this.coreMouseService.areMouseEventsActive) return this.viewport.onTouchMove(e) ? void 0 : this.cancel(e);\n              }, {\n                passive: !1\n              }));\n            }\n            refresh(e, t) {\n              var i;\n              null === (i = this._renderService) || void 0 === i || i.refreshRows(e, t);\n            }\n            updateCursorStyle(e) {\n              var t;\n              (null === (t = this._selectionService) || void 0 === t ? void 0 : t.shouldColumnSelect(e)) ? this.element.classList.add(\"column-select\") : this.element.classList.remove(\"column-select\");\n            }\n            _showCursor() {\n              this.coreService.isCursorInitialized || (this.coreService.isCursorInitialized = !0, this.refresh(this.buffer.y, this.buffer.y));\n            }\n            scrollLines(e, t, i = 0) {\n              super.scrollLines(e, t, i), this.refresh(0, this.rows - 1);\n            }\n            paste(e) {\n              (0, n.paste)(e, this.textarea, this.coreService);\n            }\n            attachCustomKeyEventHandler(e) {\n              this._customKeyEventHandler = e;\n            }\n            registerLinkProvider(e) {\n              return this.linkifier2.registerLinkProvider(e);\n            }\n            registerCharacterJoiner(e) {\n              if (!this._characterJoinerService) throw new Error(\"Terminal must be opened first\");\n              const t = this._characterJoinerService.register(e);\n              return this.refresh(0, this.rows - 1), t;\n            }\n            deregisterCharacterJoiner(e) {\n              if (!this._characterJoinerService) throw new Error(\"Terminal must be opened first\");\n              this._characterJoinerService.deregister(e) && this.refresh(0, this.rows - 1);\n            }\n            get markers() {\n              return this.buffer.markers;\n            }\n            addMarker(e) {\n              return this.buffer.addMarker(this.buffer.ybase + this.buffer.y + e);\n            }\n            registerDecoration(e) {\n              return this._decorationService.registerDecoration(e);\n            }\n            hasSelection() {\n              return !!this._selectionService && this._selectionService.hasSelection;\n            }\n            select(e, t, i) {\n              this._selectionService.setSelection(e, t, i);\n            }\n            getSelection() {\n              return this._selectionService ? this._selectionService.selectionText : \"\";\n            }\n            getSelectionPosition() {\n              if (this._selectionService && this._selectionService.hasSelection) return {\n                start: {\n                  x: this._selectionService.selectionStart[0],\n                  y: this._selectionService.selectionStart[1]\n                },\n                end: {\n                  x: this._selectionService.selectionEnd[0],\n                  y: this._selectionService.selectionEnd[1]\n                }\n              };\n            }\n            clearSelection() {\n              var e;\n              null === (e = this._selectionService) || void 0 === e || e.clearSelection();\n            }\n            selectAll() {\n              var e;\n              null === (e = this._selectionService) || void 0 === e || e.selectAll();\n            }\n            selectLines(e, t) {\n              var i;\n              null === (i = this._selectionService) || void 0 === i || i.selectLines(e, t);\n            }\n            _keyDown(e) {\n              if (this._keyDownHandled = !1, this._keyDownSeen = !0, this._customKeyEventHandler && !1 === this._customKeyEventHandler(e)) return !1;\n              const t = this.browser.isMac && this.options.macOptionIsMeta && e.altKey;\n              if (!t && !this._compositionHelper.keydown(e)) return this.buffer.ybase !== this.buffer.ydisp && this._bufferService.scrollToBottom(), !1;\n              t || \"Dead\" !== e.key && \"AltGraph\" !== e.key || (this._unprocessedDeadKey = !0);\n              const i = (0, f.evaluateKeyboardEvent)(e, this.coreService.decPrivateModes.applicationCursorKeys, this.browser.isMac, this.options.macOptionIsMeta);\n              if (this.updateCursorStyle(e), 3 === i.type || 2 === i.type) {\n                const t = this.rows - 1;\n                return this.scrollLines(2 === i.type ? -t : t), this.cancel(e, !0);\n              }\n              return 1 === i.type && this.selectAll(), !!this._isThirdLevelShift(this.browser, e) || (i.cancel && this.cancel(e, !0), !i.key || !!(e.key && !e.ctrlKey && !e.altKey && !e.metaKey && 1 === e.key.length && e.key.charCodeAt(0) >= 65 && e.key.charCodeAt(0) <= 90) || (this._unprocessedDeadKey ? (this._unprocessedDeadKey = !1, !0) : (i.key !== o.C0.ETX && i.key !== o.C0.CR || (this.textarea.value = \"\"), this._onKey.fire({\n                key: i.key,\n                domEvent: e\n              }), this._showCursor(), this.coreService.triggerDataEvent(i.key, !0), this.optionsService.rawOptions.screenReaderMode ? void (this._keyDownHandled = !0) : this.cancel(e, !0))));\n            }\n            _isThirdLevelShift(e, t) {\n              const i = e.isMac && !this.options.macOptionIsMeta && t.altKey && !t.ctrlKey && !t.metaKey || e.isWindows && t.altKey && t.ctrlKey && !t.metaKey || e.isWindows && t.getModifierState(\"AltGraph\");\n              return \"keypress\" === t.type ? i : i && (!t.keyCode || t.keyCode > 47);\n            }\n            _keyUp(e) {\n              this._keyDownSeen = !1, this._customKeyEventHandler && !1 === this._customKeyEventHandler(e) || (function (e) {\n                return 16 === e.keyCode || 17 === e.keyCode || 18 === e.keyCode;\n              }(e) || this.focus(), this.updateCursorStyle(e), this._keyPressHandled = !1);\n            }\n            _keyPress(e) {\n              let t;\n              if (this._keyPressHandled = !1, this._keyDownHandled) return !1;\n              if (this._customKeyEventHandler && !1 === this._customKeyEventHandler(e)) return !1;\n              if (this.cancel(e), e.charCode) t = e.charCode;else if (null === e.which || void 0 === e.which) t = e.keyCode;else {\n                if (0 === e.which || 0 === e.charCode) return !1;\n                t = e.which;\n              }\n              return !(!t || (e.altKey || e.ctrlKey || e.metaKey) && !this._isThirdLevelShift(this.browser, e) || (t = String.fromCharCode(t), this._onKey.fire({\n                key: t,\n                domEvent: e\n              }), this._showCursor(), this.coreService.triggerDataEvent(t, !0), this._keyPressHandled = !0, this._unprocessedDeadKey = !1, 0));\n            }\n            _inputEvent(e) {\n              if (e.data && \"insertText\" === e.inputType && (!e.composed || !this._keyDownSeen) && !this.optionsService.rawOptions.screenReaderMode) {\n                if (this._keyPressHandled) return !1;\n                this._unprocessedDeadKey = !1;\n                const t = e.data;\n                return this.coreService.triggerDataEvent(t, !0), this.cancel(e), !0;\n              }\n              return !1;\n            }\n            resize(e, t) {\n              e !== this.cols || t !== this.rows ? super.resize(e, t) : this._charSizeService && !this._charSizeService.hasValidSize && this._charSizeService.measure();\n            }\n            _afterResize(e, t) {\n              var i, s;\n              null === (i = this._charSizeService) || void 0 === i || i.measure(), null === (s = this.viewport) || void 0 === s || s.syncScrollArea(!0);\n            }\n            clear() {\n              if (0 !== this.buffer.ybase || 0 !== this.buffer.y) {\n                this.buffer.clearAllMarkers(), this.buffer.lines.set(0, this.buffer.lines.get(this.buffer.ybase + this.buffer.y)), this.buffer.lines.length = 1, this.buffer.ydisp = 0, this.buffer.ybase = 0, this.buffer.y = 0;\n                for (let e = 1; e < this.rows; e++) this.buffer.lines.push(this.buffer.getBlankLine(g.DEFAULT_ATTR_DATA));\n                this.refresh(0, this.rows - 1), this._onScroll.fire({\n                  position: this.buffer.ydisp,\n                  source: 0\n                });\n              }\n            }\n            reset() {\n              var e, t;\n              this.options.rows = this.rows, this.options.cols = this.cols;\n              const i = this._customKeyEventHandler;\n              this._setup(), super.reset(), null === (e = this._selectionService) || void 0 === e || e.reset(), this._decorationService.reset(), this._customKeyEventHandler = i, this.refresh(0, this.rows - 1), null === (t = this.viewport) || void 0 === t || t.syncScrollArea();\n            }\n            clearTextureAtlas() {\n              var e;\n              null === (e = this._renderService) || void 0 === e || e.clearTextureAtlas();\n            }\n            _reportFocus() {\n              var e;\n              (null === (e = this.element) || void 0 === e ? void 0 : e.classList.contains(\"focus\")) ? this.coreService.triggerDataEvent(o.C0.ESC + \"[I\") : this.coreService.triggerDataEvent(o.C0.ESC + \"[O\");\n            }\n            _reportWindowsOptions(e) {\n              if (this._renderService) switch (e) {\n                case a.WindowsOptionsReportType.GET_WIN_SIZE_PIXELS:\n                  const e = this._renderService.dimensions.canvasWidth.toFixed(0),\n                    t = this._renderService.dimensions.canvasHeight.toFixed(0);\n                  this.coreService.triggerDataEvent(`${o.C0.ESC}[4;${t};${e}t`);\n                  break;\n                case a.WindowsOptionsReportType.GET_CELL_SIZE_PIXELS:\n                  const i = this._renderService.dimensions.actualCellWidth.toFixed(0),\n                    s = this._renderService.dimensions.actualCellHeight.toFixed(0);\n                  this.coreService.triggerDataEvent(`${o.C0.ESC}[6;${s};${i}t`);\n              }\n            }\n            cancel(e, t) {\n              if (this.options.cancelEvents || t) return e.preventDefault(), e.stopPropagation(), !1;\n            }\n          }\n          t.Terminal = O;\n        },\n        9924: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.TimeBasedDebouncer = void 0, t.TimeBasedDebouncer = class {\n            constructor(e, t = 1e3) {\n              this._renderCallback = e, this._debounceThresholdMS = t, this._lastRefreshMs = 0, this._additionalRefreshRequested = !1;\n            }\n            dispose() {\n              this._refreshTimeoutID && clearTimeout(this._refreshTimeoutID);\n            }\n            refresh(e, t, i) {\n              this._rowCount = i, e = void 0 !== e ? e : 0, t = void 0 !== t ? t : this._rowCount - 1, this._rowStart = void 0 !== this._rowStart ? Math.min(this._rowStart, e) : e, this._rowEnd = void 0 !== this._rowEnd ? Math.max(this._rowEnd, t) : t;\n              const s = Date.now();\n              if (s - this._lastRefreshMs >= this._debounceThresholdMS) this._lastRefreshMs = s, this._innerRefresh();else if (!this._additionalRefreshRequested) {\n                const e = s - this._lastRefreshMs,\n                  t = this._debounceThresholdMS - e;\n                this._additionalRefreshRequested = !0, this._refreshTimeoutID = window.setTimeout(() => {\n                  this._lastRefreshMs = Date.now(), this._innerRefresh(), this._additionalRefreshRequested = !1, this._refreshTimeoutID = void 0;\n                }, t);\n              }\n            }\n            _innerRefresh() {\n              if (void 0 === this._rowStart || void 0 === this._rowEnd || void 0 === this._rowCount) return;\n              const e = Math.max(this._rowStart, 0),\n                t = Math.min(this._rowEnd, this._rowCount - 1);\n              this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(e, t);\n            }\n          };\n        },\n        1680: function (e, t, i) {\n          var s = this && this.__decorate || function (e, t, i, s) {\n              var r,\n                n = arguments.length,\n                o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;\n              if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);else for (var a = e.length - 1; a >= 0; a--) (r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);\n              return n > 3 && o && Object.defineProperty(t, i, o), o;\n            },\n            r = this && this.__param || function (e, t) {\n              return function (i, s) {\n                t(i, s, e);\n              };\n            };\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.Viewport = void 0;\n          const n = i(844),\n            o = i(3656),\n            a = i(4725),\n            h = i(2585);\n          let c = class extends n.Disposable {\n            constructor(e, t, i, s, r, n, a, h, c) {\n              super(), this._scrollLines = e, this._viewportElement = t, this._scrollArea = i, this._element = s, this._bufferService = r, this._optionsService = n, this._charSizeService = a, this._renderService = h, this._coreBrowserService = c, this.scrollBarWidth = 0, this._currentRowHeight = 0, this._currentScaledCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._wheelPartialScroll = 0, this._refreshAnimationFrame = null, this._ignoreNextScrollEvent = !1, this._smoothScrollState = {\n                startTime: 0,\n                origin: -1,\n                target: -1\n              }, this.scrollBarWidth = this._viewportElement.offsetWidth - this._scrollArea.offsetWidth || 15, this.register((0, o.addDisposableDomListener)(this._viewportElement, \"scroll\", this._onScroll.bind(this))), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate(e => this._activeBuffer = e.activeBuffer)), this._renderDimensions = this._renderService.dimensions, this.register(this._renderService.onDimensionsChange(e => this._renderDimensions = e)), setTimeout(() => this.syncScrollArea(), 0);\n            }\n            onThemeChange(e) {\n              this._viewportElement.style.backgroundColor = e.background.css;\n            }\n            _refresh(e) {\n              if (e) return this._innerRefresh(), void (null !== this._refreshAnimationFrame && this._coreBrowserService.window.cancelAnimationFrame(this._refreshAnimationFrame));\n              null === this._refreshAnimationFrame && (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._innerRefresh()));\n            }\n            _innerRefresh() {\n              if (this._charSizeService.height > 0) {\n                this._currentRowHeight = this._renderService.dimensions.scaledCellHeight / this._coreBrowserService.dpr, this._currentScaledCellHeight = this._renderService.dimensions.scaledCellHeight, this._lastRecordedViewportHeight = this._viewportElement.offsetHeight;\n                const e = Math.round(this._currentRowHeight * this._lastRecordedBufferLength) + (this._lastRecordedViewportHeight - this._renderService.dimensions.canvasHeight);\n                this._lastRecordedBufferHeight !== e && (this._lastRecordedBufferHeight = e, this._scrollArea.style.height = this._lastRecordedBufferHeight + \"px\");\n              }\n              const e = this._bufferService.buffer.ydisp * this._currentRowHeight;\n              this._viewportElement.scrollTop !== e && (this._ignoreNextScrollEvent = !0, this._viewportElement.scrollTop = e), this._refreshAnimationFrame = null;\n            }\n            syncScrollArea(e = !1) {\n              if (this._lastRecordedBufferLength !== this._bufferService.buffer.lines.length) return this._lastRecordedBufferLength = this._bufferService.buffer.lines.length, void this._refresh(e);\n              this._lastRecordedViewportHeight === this._renderService.dimensions.canvasHeight && this._lastScrollTop === this._activeBuffer.ydisp * this._currentRowHeight && this._renderDimensions.scaledCellHeight === this._currentScaledCellHeight || this._refresh(e);\n            }\n            _onScroll(e) {\n              if (this._lastScrollTop = this._viewportElement.scrollTop, !this._viewportElement.offsetParent) return;\n              if (this._ignoreNextScrollEvent) return this._ignoreNextScrollEvent = !1, void this._scrollLines(0);\n              const t = Math.round(this._lastScrollTop / this._currentRowHeight) - this._bufferService.buffer.ydisp;\n              this._scrollLines(t);\n            }\n            _smoothScroll() {\n              if (this._isDisposed || -1 === this._smoothScrollState.origin || -1 === this._smoothScrollState.target) return;\n              const e = this._smoothScrollPercent();\n              this._viewportElement.scrollTop = this._smoothScrollState.origin + Math.round(e * (this._smoothScrollState.target - this._smoothScrollState.origin)), e < 1 ? this._coreBrowserService.window.requestAnimationFrame(() => this._smoothScroll()) : this._clearSmoothScrollState();\n            }\n            _smoothScrollPercent() {\n              return this._optionsService.rawOptions.smoothScrollDuration && this._smoothScrollState.startTime ? Math.max(Math.min((Date.now() - this._smoothScrollState.startTime) / this._optionsService.rawOptions.smoothScrollDuration, 1), 0) : 1;\n            }\n            _clearSmoothScrollState() {\n              this._smoothScrollState.startTime = 0, this._smoothScrollState.origin = -1, this._smoothScrollState.target = -1;\n            }\n            _bubbleScroll(e, t) {\n              const i = this._viewportElement.scrollTop + this._lastRecordedViewportHeight;\n              return !(t < 0 && 0 !== this._viewportElement.scrollTop || t > 0 && i < this._lastRecordedBufferHeight) || (e.cancelable && e.preventDefault(), !1);\n            }\n            onWheel(e) {\n              const t = this._getPixelsScrolled(e);\n              return 0 !== t && (this._optionsService.rawOptions.smoothScrollDuration ? (this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, -1 === this._smoothScrollState.target ? this._smoothScrollState.target = this._viewportElement.scrollTop + t : this._smoothScrollState.target += t, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState()) : this._viewportElement.scrollTop += t, this._bubbleScroll(e, t));\n            }\n            _getPixelsScrolled(e) {\n              if (0 === e.deltaY || e.shiftKey) return 0;\n              let t = this._applyScrollModifier(e.deltaY, e);\n              return e.deltaMode === WheelEvent.DOM_DELTA_LINE ? t *= this._currentRowHeight : e.deltaMode === WheelEvent.DOM_DELTA_PAGE && (t *= this._currentRowHeight * this._bufferService.rows), t;\n            }\n            getLinesScrolled(e) {\n              if (0 === e.deltaY || e.shiftKey) return 0;\n              let t = this._applyScrollModifier(e.deltaY, e);\n              return e.deltaMode === WheelEvent.DOM_DELTA_PIXEL ? (t /= this._currentRowHeight + 0, this._wheelPartialScroll += t, t = Math.floor(Math.abs(this._wheelPartialScroll)) * (this._wheelPartialScroll > 0 ? 1 : -1), this._wheelPartialScroll %= 1) : e.deltaMode === WheelEvent.DOM_DELTA_PAGE && (t *= this._bufferService.rows), t;\n            }\n            _applyScrollModifier(e, t) {\n              const i = this._optionsService.rawOptions.fastScrollModifier;\n              return \"alt\" === i && t.altKey || \"ctrl\" === i && t.ctrlKey || \"shift\" === i && t.shiftKey ? e * this._optionsService.rawOptions.fastScrollSensitivity * this._optionsService.rawOptions.scrollSensitivity : e * this._optionsService.rawOptions.scrollSensitivity;\n            }\n            onTouchStart(e) {\n              this._lastTouchY = e.touches[0].pageY;\n            }\n            onTouchMove(e) {\n              const t = this._lastTouchY - e.touches[0].pageY;\n              return this._lastTouchY = e.touches[0].pageY, 0 !== t && (this._viewportElement.scrollTop += t, this._bubbleScroll(e, t));\n            }\n          };\n          c = s([r(4, h.IBufferService), r(5, h.IOptionsService), r(6, a.ICharSizeService), r(7, a.IRenderService), r(8, a.ICoreBrowserService)], c), t.Viewport = c;\n        },\n        3107: function (e, t, i) {\n          var s = this && this.__decorate || function (e, t, i, s) {\n              var r,\n                n = arguments.length,\n                o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;\n              if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);else for (var a = e.length - 1; a >= 0; a--) (r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);\n              return n > 3 && o && Object.defineProperty(t, i, o), o;\n            },\n            r = this && this.__param || function (e, t) {\n              return function (i, s) {\n                t(i, s, e);\n              };\n            };\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.BufferDecorationRenderer = void 0;\n          const n = i(3656),\n            o = i(4725),\n            a = i(844),\n            h = i(2585);\n          let c = class extends a.Disposable {\n            constructor(e, t, i, s) {\n              super(), this._screenElement = e, this._bufferService = t, this._decorationService = i, this._renderService = s, this._decorationElements = new Map(), this._altBufferIsActive = !1, this._dimensionsChanged = !1, this._container = document.createElement(\"div\"), this._container.classList.add(\"xterm-decoration-container\"), this._screenElement.appendChild(this._container), this.register(this._renderService.onRenderedViewportChange(() => this._queueRefresh())), this.register(this._renderService.onDimensionsChange(() => {\n                this._dimensionsChanged = !0, this._queueRefresh();\n              })), this.register((0, n.addDisposableDomListener)(window, \"resize\", () => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => {\n                this._altBufferIsActive = this._bufferService.buffer === this._bufferService.buffers.alt;\n              })), this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh())), this.register(this._decorationService.onDecorationRemoved(e => this._removeDecoration(e)));\n            }\n            dispose() {\n              this._container.remove(), this._decorationElements.clear(), super.dispose();\n            }\n            _queueRefresh() {\n              void 0 === this._animationFrame && (this._animationFrame = this._renderService.addRefreshCallback(() => {\n                this.refreshDecorations(), this._animationFrame = void 0;\n              }));\n            }\n            refreshDecorations() {\n              for (const e of this._decorationService.decorations) this._renderDecoration(e);\n              this._dimensionsChanged = !1;\n            }\n            _renderDecoration(e) {\n              this._refreshStyle(e), this._dimensionsChanged && this._refreshXPosition(e);\n            }\n            _createElement(e) {\n              var t;\n              const i = document.createElement(\"div\");\n              i.classList.add(\"xterm-decoration\"), i.style.width = `${Math.round((e.options.width || 1) * this._renderService.dimensions.actualCellWidth)}px`, i.style.height = (e.options.height || 1) * this._renderService.dimensions.actualCellHeight + \"px\", i.style.top = (e.marker.line - this._bufferService.buffers.active.ydisp) * this._renderService.dimensions.actualCellHeight + \"px\", i.style.lineHeight = `${this._renderService.dimensions.actualCellHeight}px`;\n              const s = null !== (t = e.options.x) && void 0 !== t ? t : 0;\n              return s && s > this._bufferService.cols && (i.style.display = \"none\"), this._refreshXPosition(e, i), i;\n            }\n            _refreshStyle(e) {\n              const t = e.marker.line - this._bufferService.buffers.active.ydisp;\n              if (t < 0 || t >= this._bufferService.rows) e.element && (e.element.style.display = \"none\", e.onRenderEmitter.fire(e.element));else {\n                let i = this._decorationElements.get(e);\n                i || (e.onDispose(() => this._removeDecoration(e)), i = this._createElement(e), e.element = i, this._decorationElements.set(e, i), this._container.appendChild(i)), i.style.top = t * this._renderService.dimensions.actualCellHeight + \"px\", i.style.display = this._altBufferIsActive ? \"none\" : \"block\", e.onRenderEmitter.fire(i);\n              }\n            }\n            _refreshXPosition(e, t = e.element) {\n              var i;\n              if (!t) return;\n              const s = null !== (i = e.options.x) && void 0 !== i ? i : 0;\n              \"right\" === (e.options.anchor || \"left\") ? t.style.right = s ? s * this._renderService.dimensions.actualCellWidth + \"px\" : \"\" : t.style.left = s ? s * this._renderService.dimensions.actualCellWidth + \"px\" : \"\";\n            }\n            _removeDecoration(e) {\n              var t;\n              null === (t = this._decorationElements.get(e)) || void 0 === t || t.remove(), this._decorationElements.delete(e);\n            }\n          };\n          c = s([r(1, h.IBufferService), r(2, h.IDecorationService), r(3, o.IRenderService)], c), t.BufferDecorationRenderer = c;\n        },\n        5871: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.ColorZoneStore = void 0, t.ColorZoneStore = class {\n            constructor() {\n              this._zones = [], this._zonePool = [], this._zonePoolIndex = 0, this._linePadding = {\n                full: 0,\n                left: 0,\n                center: 0,\n                right: 0\n              };\n            }\n            get zones() {\n              return this._zonePool.length = Math.min(this._zonePool.length, this._zones.length), this._zones;\n            }\n            clear() {\n              this._zones.length = 0, this._zonePoolIndex = 0;\n            }\n            addDecoration(e) {\n              if (e.options.overviewRulerOptions) {\n                for (const t of this._zones) if (t.color === e.options.overviewRulerOptions.color && t.position === e.options.overviewRulerOptions.position) {\n                  if (this._lineIntersectsZone(t, e.marker.line)) return;\n                  if (this._lineAdjacentToZone(t, e.marker.line, e.options.overviewRulerOptions.position)) return void this._addLineToZone(t, e.marker.line);\n                }\n                if (this._zonePoolIndex < this._zonePool.length) return this._zonePool[this._zonePoolIndex].color = e.options.overviewRulerOptions.color, this._zonePool[this._zonePoolIndex].position = e.options.overviewRulerOptions.position, this._zonePool[this._zonePoolIndex].startBufferLine = e.marker.line, this._zonePool[this._zonePoolIndex].endBufferLine = e.marker.line, void this._zones.push(this._zonePool[this._zonePoolIndex++]);\n                this._zones.push({\n                  color: e.options.overviewRulerOptions.color,\n                  position: e.options.overviewRulerOptions.position,\n                  startBufferLine: e.marker.line,\n                  endBufferLine: e.marker.line\n                }), this._zonePool.push(this._zones[this._zones.length - 1]), this._zonePoolIndex++;\n              }\n            }\n            setPadding(e) {\n              this._linePadding = e;\n            }\n            _lineIntersectsZone(e, t) {\n              return t >= e.startBufferLine && t <= e.endBufferLine;\n            }\n            _lineAdjacentToZone(e, t, i) {\n              return t >= e.startBufferLine - this._linePadding[i || \"full\"] && t <= e.endBufferLine + this._linePadding[i || \"full\"];\n            }\n            _addLineToZone(e, t) {\n              e.startBufferLine = Math.min(e.startBufferLine, t), e.endBufferLine = Math.max(e.endBufferLine, t);\n            }\n          };\n        },\n        5744: function (e, t, i) {\n          var s = this && this.__decorate || function (e, t, i, s) {\n              var r,\n                n = arguments.length,\n                o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;\n              if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);else for (var a = e.length - 1; a >= 0; a--) (r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);\n              return n > 3 && o && Object.defineProperty(t, i, o), o;\n            },\n            r = this && this.__param || function (e, t) {\n              return function (i, s) {\n                t(i, s, e);\n              };\n            };\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.OverviewRulerRenderer = void 0;\n          const n = i(5871),\n            o = i(3656),\n            a = i(4725),\n            h = i(844),\n            c = i(2585),\n            l = {\n              full: 0,\n              left: 0,\n              center: 0,\n              right: 0\n            },\n            d = {\n              full: 0,\n              left: 0,\n              center: 0,\n              right: 0\n            },\n            _ = {\n              full: 0,\n              left: 0,\n              center: 0,\n              right: 0\n            };\n          let u = class extends h.Disposable {\n            constructor(e, t, i, s, r, o, a) {\n              var h;\n              super(), this._viewportElement = e, this._screenElement = t, this._bufferService = i, this._decorationService = s, this._renderService = r, this._optionsService = o, this._coreBrowseService = a, this._colorZoneStore = new n.ColorZoneStore(), this._shouldUpdateDimensions = !0, this._shouldUpdateAnchor = !0, this._lastKnownBufferLength = 0, this._canvas = document.createElement(\"canvas\"), this._canvas.classList.add(\"xterm-decoration-overview-ruler\"), this._refreshCanvasDimensions(), null === (h = this._viewportElement.parentElement) || void 0 === h || h.insertBefore(this._canvas, this._viewportElement);\n              const c = this._canvas.getContext(\"2d\");\n              if (!c) throw new Error(\"Ctx cannot be null\");\n              this._ctx = c, this._registerDecorationListeners(), this._registerBufferChangeListeners(), this._registerDimensionChangeListeners();\n            }\n            get _width() {\n              return this._optionsService.options.overviewRulerWidth || 0;\n            }\n            _registerDecorationListeners() {\n              this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh(void 0, !0))), this.register(this._decorationService.onDecorationRemoved(() => this._queueRefresh(void 0, !0)));\n            }\n            _registerBufferChangeListeners() {\n              this.register(this._renderService.onRenderedViewportChange(() => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => {\n                this._canvas.style.display = this._bufferService.buffer === this._bufferService.buffers.alt ? \"none\" : \"block\";\n              })), this.register(this._bufferService.onScroll(() => {\n                this._lastKnownBufferLength !== this._bufferService.buffers.normal.lines.length && (this._refreshDrawHeightConstants(), this._refreshColorZonePadding());\n              }));\n            }\n            _registerDimensionChangeListeners() {\n              this.register(this._renderService.onRender(() => {\n                this._containerHeight && this._containerHeight === this._screenElement.clientHeight || (this._queueRefresh(!0), this._containerHeight = this._screenElement.clientHeight);\n              })), this.register(this._optionsService.onOptionChange(e => {\n                \"overviewRulerWidth\" === e && this._queueRefresh(!0);\n              })), this.register((0, o.addDisposableDomListener)(this._coreBrowseService.window, \"resize\", () => {\n                this._queueRefresh(!0);\n              })), this._queueRefresh(!0);\n            }\n            dispose() {\n              var e;\n              null === (e = this._canvas) || void 0 === e || e.remove(), super.dispose();\n            }\n            _refreshDrawConstants() {\n              const e = Math.floor(this._canvas.width / 3),\n                t = Math.ceil(this._canvas.width / 3);\n              d.full = this._canvas.width, d.left = e, d.center = t, d.right = e, this._refreshDrawHeightConstants(), _.full = 0, _.left = 0, _.center = d.left, _.right = d.left + d.center;\n            }\n            _refreshDrawHeightConstants() {\n              l.full = Math.round(2 * this._coreBrowseService.dpr);\n              const e = this._canvas.height / this._bufferService.buffer.lines.length,\n                t = Math.round(Math.max(Math.min(e, 12), 6) * this._coreBrowseService.dpr);\n              l.left = t, l.center = t, l.right = t;\n            }\n            _refreshColorZonePadding() {\n              this._colorZoneStore.setPadding({\n                full: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * l.full),\n                left: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * l.left),\n                center: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * l.center),\n                right: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * l.right)\n              }), this._lastKnownBufferLength = this._bufferService.buffers.normal.lines.length;\n            }\n            _refreshCanvasDimensions() {\n              this._canvas.style.width = `${this._width}px`, this._canvas.width = Math.round(this._width * this._coreBrowseService.dpr), this._canvas.style.height = `${this._screenElement.clientHeight}px`, this._canvas.height = Math.round(this._screenElement.clientHeight * this._coreBrowseService.dpr), this._refreshDrawConstants(), this._refreshColorZonePadding();\n            }\n            _refreshDecorations() {\n              this._shouldUpdateDimensions && this._refreshCanvasDimensions(), this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height), this._colorZoneStore.clear();\n              for (const e of this._decorationService.decorations) this._colorZoneStore.addDecoration(e);\n              this._ctx.lineWidth = 1;\n              const e = this._colorZoneStore.zones;\n              for (const t of e) \"full\" !== t.position && this._renderColorZone(t);\n              for (const t of e) \"full\" === t.position && this._renderColorZone(t);\n              this._shouldUpdateDimensions = !1, this._shouldUpdateAnchor = !1;\n            }\n            _renderColorZone(e) {\n              this._ctx.fillStyle = e.color, this._ctx.fillRect(_[e.position || \"full\"], Math.round((this._canvas.height - 1) * (e.startBufferLine / this._bufferService.buffers.active.lines.length) - l[e.position || \"full\"] / 2), d[e.position || \"full\"], Math.round((this._canvas.height - 1) * ((e.endBufferLine - e.startBufferLine) / this._bufferService.buffers.active.lines.length) + l[e.position || \"full\"]));\n            }\n            _queueRefresh(e, t) {\n              this._shouldUpdateDimensions = e || this._shouldUpdateDimensions, this._shouldUpdateAnchor = t || this._shouldUpdateAnchor, void 0 === this._animationFrame && (this._animationFrame = this._coreBrowseService.window.requestAnimationFrame(() => {\n                this._refreshDecorations(), this._animationFrame = void 0;\n              }));\n            }\n          };\n          u = s([r(2, c.IBufferService), r(3, c.IDecorationService), r(4, a.IRenderService), r(5, c.IOptionsService), r(6, a.ICoreBrowserService)], u), t.OverviewRulerRenderer = u;\n        },\n        2950: function (e, t, i) {\n          var s = this && this.__decorate || function (e, t, i, s) {\n              var r,\n                n = arguments.length,\n                o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;\n              if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);else for (var a = e.length - 1; a >= 0; a--) (r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);\n              return n > 3 && o && Object.defineProperty(t, i, o), o;\n            },\n            r = this && this.__param || function (e, t) {\n              return function (i, s) {\n                t(i, s, e);\n              };\n            };\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.CompositionHelper = void 0;\n          const n = i(4725),\n            o = i(2585),\n            a = i(2584);\n          let h = class {\n            constructor(e, t, i, s, r, n) {\n              this._textarea = e, this._compositionView = t, this._bufferService = i, this._optionsService = s, this._coreService = r, this._renderService = n, this._isComposing = !1, this._isSendingComposition = !1, this._compositionPosition = {\n                start: 0,\n                end: 0\n              }, this._dataAlreadySent = \"\";\n            }\n            get isComposing() {\n              return this._isComposing;\n            }\n            compositionstart() {\n              this._isComposing = !0, this._compositionPosition.start = this._textarea.value.length, this._compositionView.textContent = \"\", this._dataAlreadySent = \"\", this._compositionView.classList.add(\"active\");\n            }\n            compositionupdate(e) {\n              this._compositionView.textContent = e.data, this.updateCompositionElements(), setTimeout(() => {\n                this._compositionPosition.end = this._textarea.value.length;\n              }, 0);\n            }\n            compositionend() {\n              this._finalizeComposition(!0);\n            }\n            keydown(e) {\n              if (this._isComposing || this._isSendingComposition) {\n                if (229 === e.keyCode) return !1;\n                if (16 === e.keyCode || 17 === e.keyCode || 18 === e.keyCode) return !1;\n                this._finalizeComposition(!1);\n              }\n              return 229 !== e.keyCode || (this._handleAnyTextareaChanges(), !1);\n            }\n            _finalizeComposition(e) {\n              if (this._compositionView.classList.remove(\"active\"), this._isComposing = !1, e) {\n                const e = {\n                  start: this._compositionPosition.start,\n                  end: this._compositionPosition.end\n                };\n                this._isSendingComposition = !0, setTimeout(() => {\n                  if (this._isSendingComposition) {\n                    let t;\n                    this._isSendingComposition = !1, e.start += this._dataAlreadySent.length, t = this._isComposing ? this._textarea.value.substring(e.start, e.end) : this._textarea.value.substring(e.start), t.length > 0 && this._coreService.triggerDataEvent(t, !0);\n                  }\n                }, 0);\n              } else {\n                this._isSendingComposition = !1;\n                const e = this._textarea.value.substring(this._compositionPosition.start, this._compositionPosition.end);\n                this._coreService.triggerDataEvent(e, !0);\n              }\n            }\n            _handleAnyTextareaChanges() {\n              const e = this._textarea.value;\n              setTimeout(() => {\n                if (!this._isComposing) {\n                  const t = this._textarea.value,\n                    i = t.replace(e, \"\");\n                  this._dataAlreadySent = i, t.length > e.length ? this._coreService.triggerDataEvent(i, !0) : t.length < e.length ? this._coreService.triggerDataEvent(`${a.C0.DEL}`, !0) : t.length === e.length && t !== e && this._coreService.triggerDataEvent(t, !0);\n                }\n              }, 0);\n            }\n            updateCompositionElements(e) {\n              if (this._isComposing) {\n                if (this._bufferService.buffer.isCursorInViewport) {\n                  const e = Math.min(this._bufferService.buffer.x, this._bufferService.cols - 1),\n                    t = this._renderService.dimensions.actualCellHeight,\n                    i = this._bufferService.buffer.y * this._renderService.dimensions.actualCellHeight,\n                    s = e * this._renderService.dimensions.actualCellWidth;\n                  this._compositionView.style.left = s + \"px\", this._compositionView.style.top = i + \"px\", this._compositionView.style.height = t + \"px\", this._compositionView.style.lineHeight = t + \"px\", this._compositionView.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._compositionView.style.fontSize = this._optionsService.rawOptions.fontSize + \"px\";\n                  const r = this._compositionView.getBoundingClientRect();\n                  this._textarea.style.left = s + \"px\", this._textarea.style.top = i + \"px\", this._textarea.style.width = Math.max(r.width, 1) + \"px\", this._textarea.style.height = Math.max(r.height, 1) + \"px\", this._textarea.style.lineHeight = r.height + \"px\";\n                }\n                e || setTimeout(() => this.updateCompositionElements(!0), 0);\n              }\n            }\n          };\n          h = s([r(2, o.IBufferService), r(3, o.IOptionsService), r(4, o.ICoreService), r(5, n.IRenderService)], h), t.CompositionHelper = h;\n        },\n        9806: (e, t) => {\n          function i(e, t, i) {\n            const s = i.getBoundingClientRect(),\n              r = e.getComputedStyle(i),\n              n = parseInt(r.getPropertyValue(\"padding-left\")),\n              o = parseInt(r.getPropertyValue(\"padding-top\"));\n            return [t.clientX - s.left - n, t.clientY - s.top - o];\n          }\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.getCoords = t.getCoordsRelativeToElement = void 0, t.getCoordsRelativeToElement = i, t.getCoords = function (e, t, s, r, n, o, a, h, c) {\n            if (!o) return;\n            const l = i(e, t, s);\n            return l ? (l[0] = Math.ceil((l[0] + (c ? a / 2 : 0)) / a), l[1] = Math.ceil(l[1] / h), l[0] = Math.min(Math.max(l[0], 1), r + (c ? 1 : 0)), l[1] = Math.min(Math.max(l[1], 1), n), l) : void 0;\n          };\n        },\n        9504: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.moveToCellSequence = void 0;\n          const s = i(2584);\n          function r(e, t, i, s) {\n            const r = e - n(i, e),\n              a = t - n(i, t),\n              l = Math.abs(r - a) - function (e, t, i) {\n                let s = 0;\n                const r = e - n(i, e),\n                  a = t - n(i, t);\n                for (let n = 0; n < Math.abs(r - a); n++) {\n                  const a = \"A\" === o(e, t) ? -1 : 1,\n                    h = i.buffer.lines.get(r + a * n);\n                  (null == h ? void 0 : h.isWrapped) && s++;\n                }\n                return s;\n              }(e, t, i);\n            return c(l, h(o(e, t), s));\n          }\n          function n(e, t) {\n            let i = 0,\n              s = e.buffer.lines.get(t),\n              r = null == s ? void 0 : s.isWrapped;\n            for (; r && t >= 0 && t < e.rows;) i++, s = e.buffer.lines.get(--t), r = null == s ? void 0 : s.isWrapped;\n            return i;\n          }\n          function o(e, t) {\n            return e > t ? \"A\" : \"B\";\n          }\n          function a(e, t, i, s, r, n) {\n            let o = e,\n              a = t,\n              h = \"\";\n            for (; o !== i || a !== s;) o += r ? 1 : -1, r && o > n.cols - 1 ? (h += n.buffer.translateBufferLineToString(a, !1, e, o), o = 0, e = 0, a++) : !r && o < 0 && (h += n.buffer.translateBufferLineToString(a, !1, 0, e + 1), o = n.cols - 1, e = o, a--);\n            return h + n.buffer.translateBufferLineToString(a, !1, e, o);\n          }\n          function h(e, t) {\n            const i = t ? \"O\" : \"[\";\n            return s.C0.ESC + i + e;\n          }\n          function c(e, t) {\n            e = Math.floor(e);\n            let i = \"\";\n            for (let s = 0; s < e; s++) i += t;\n            return i;\n          }\n          t.moveToCellSequence = function (e, t, i, s) {\n            const o = i.buffer.x,\n              l = i.buffer.y;\n            if (!i.buffer.hasScrollback) return function (e, t, i, s, o, l) {\n              return 0 === r(t, s, o, l).length ? \"\" : c(a(e, t, e, t - n(o, t), !1, o).length, h(\"D\", l));\n            }(o, l, 0, t, i, s) + r(l, t, i, s) + function (e, t, i, s, o, l) {\n              let d;\n              d = r(t, s, o, l).length > 0 ? s - n(o, s) : t;\n              const _ = s,\n                u = function (e, t, i, s, o, a) {\n                  let h;\n                  return h = r(i, s, o, a).length > 0 ? s - n(o, s) : t, e < i && h <= s || e >= i && h < s ? \"C\" : \"D\";\n                }(e, t, i, s, o, l);\n              return c(a(e, d, i, _, \"C\" === u, o).length, h(u, l));\n            }(o, l, e, t, i, s);\n            let d;\n            if (l === t) return d = o > e ? \"D\" : \"C\", c(Math.abs(o - e), h(d, s));\n            d = l > t ? \"D\" : \"C\";\n            const _ = Math.abs(l - t);\n            return c(function (e, t) {\n              return t.cols - e;\n            }(l > t ? e : o, i) + (_ - 1) * i.cols + 1 + ((l > t ? o : e) - 1), h(d, s));\n          };\n        },\n        8036: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.TEXT_BASELINE = t.DIM_OPACITY = t.INVERTED_DEFAULT_COLOR = void 0;\n          const s = i(6114);\n          t.INVERTED_DEFAULT_COLOR = 257, t.DIM_OPACITY = .5, t.TEXT_BASELINE = s.isFirefox || s.isLegacyEdge ? \"bottom\" : \"ideographic\";\n        },\n        1752: (e, t) => {\n          function i(e) {\n            return 57508 <= e && e <= 57558;\n          }\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.excludeFromContrastRatioDemands = t.isRestrictedPowerlineGlyph = t.isPowerlineGlyph = t.throwIfFalsy = void 0, t.throwIfFalsy = function (e) {\n            if (!e) throw new Error(\"value must not be falsy\");\n            return e;\n          }, t.isPowerlineGlyph = i, t.isRestrictedPowerlineGlyph = function (e) {\n            return 57520 <= e && e <= 57527;\n          }, t.excludeFromContrastRatioDemands = function (e) {\n            return i(e) || function (e) {\n              return 9472 <= e && e <= 9631;\n            }(e);\n          };\n        },\n        1296: function (e, t, i) {\n          var s = this && this.__decorate || function (e, t, i, s) {\n              var r,\n                n = arguments.length,\n                o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;\n              if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);else for (var a = e.length - 1; a >= 0; a--) (r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);\n              return n > 3 && o && Object.defineProperty(t, i, o), o;\n            },\n            r = this && this.__param || function (e, t) {\n              return function (i, s) {\n                t(i, s, e);\n              };\n            };\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.DomRenderer = void 0;\n          const n = i(3787),\n            o = i(8036),\n            a = i(844),\n            h = i(4725),\n            c = i(2585),\n            l = i(8460),\n            d = i(8055),\n            _ = i(9631),\n            u = \"xterm-dom-renderer-owner-\",\n            f = \"xterm-focus\";\n          let v = 1,\n            g = class extends a.Disposable {\n              constructor(e, t, i, s, r, o, a, h, c, l) {\n                super(), this._colors = e, this._element = t, this._screenElement = i, this._viewportElement = s, this._linkifier2 = r, this._charSizeService = a, this._optionsService = h, this._bufferService = c, this._coreBrowserService = l, this._terminalClass = v++, this._rowElements = [], this._rowContainer = document.createElement(\"div\"), this._rowContainer.classList.add(\"xterm-rows\"), this._rowContainer.style.lineHeight = \"normal\", this._rowContainer.setAttribute(\"aria-hidden\", \"true\"), this._refreshRowElements(this._bufferService.cols, this._bufferService.rows), this._selectionContainer = document.createElement(\"div\"), this._selectionContainer.classList.add(\"xterm-selection\"), this._selectionContainer.setAttribute(\"aria-hidden\", \"true\"), this.dimensions = {\n                  scaledCharWidth: 0,\n                  scaledCharHeight: 0,\n                  scaledCellWidth: 0,\n                  scaledCellHeight: 0,\n                  scaledCharLeft: 0,\n                  scaledCharTop: 0,\n                  scaledCanvasWidth: 0,\n                  scaledCanvasHeight: 0,\n                  canvasWidth: 0,\n                  canvasHeight: 0,\n                  actualCellWidth: 0,\n                  actualCellHeight: 0\n                }, this._updateDimensions(), this._injectCss(), this._rowFactory = o.createInstance(n.DomRendererRowFactory, document, this._colors), this._element.classList.add(u + this._terminalClass), this._screenElement.appendChild(this._rowContainer), this._screenElement.appendChild(this._selectionContainer), this.register(this._linkifier2.onShowLinkUnderline(e => this._onLinkHover(e))), this.register(this._linkifier2.onHideLinkUnderline(e => this._onLinkLeave(e)));\n              }\n              get onRequestRedraw() {\n                return new l.EventEmitter().event;\n              }\n              dispose() {\n                this._element.classList.remove(u + this._terminalClass), (0, _.removeElementFromParent)(this._rowContainer, this._selectionContainer, this._themeStyleElement, this._dimensionsStyleElement), super.dispose();\n              }\n              _updateDimensions() {\n                const e = this._coreBrowserService.dpr;\n                this.dimensions.scaledCharWidth = this._charSizeService.width * e, this.dimensions.scaledCharHeight = Math.ceil(this._charSizeService.height * e), this.dimensions.scaledCellWidth = this.dimensions.scaledCharWidth + Math.round(this._optionsService.rawOptions.letterSpacing), this.dimensions.scaledCellHeight = Math.floor(this.dimensions.scaledCharHeight * this._optionsService.rawOptions.lineHeight), this.dimensions.scaledCharLeft = 0, this.dimensions.scaledCharTop = 0, this.dimensions.scaledCanvasWidth = this.dimensions.scaledCellWidth * this._bufferService.cols, this.dimensions.scaledCanvasHeight = this.dimensions.scaledCellHeight * this._bufferService.rows, this.dimensions.canvasWidth = Math.round(this.dimensions.scaledCanvasWidth / e), this.dimensions.canvasHeight = Math.round(this.dimensions.scaledCanvasHeight / e), this.dimensions.actualCellWidth = this.dimensions.canvasWidth / this._bufferService.cols, this.dimensions.actualCellHeight = this.dimensions.canvasHeight / this._bufferService.rows;\n                for (const e of this._rowElements) e.style.width = `${this.dimensions.canvasWidth}px`, e.style.height = `${this.dimensions.actualCellHeight}px`, e.style.lineHeight = `${this.dimensions.actualCellHeight}px`, e.style.overflow = \"hidden\";\n                this._dimensionsStyleElement || (this._dimensionsStyleElement = document.createElement(\"style\"), this._screenElement.appendChild(this._dimensionsStyleElement));\n                const t = `${this._terminalSelector} .xterm-rows span { display: inline-block; height: 100%; vertical-align: top; width: ${this.dimensions.actualCellWidth}px}`;\n                this._dimensionsStyleElement.textContent = t, this._selectionContainer.style.height = this._viewportElement.style.height, this._screenElement.style.width = `${this.dimensions.canvasWidth}px`, this._screenElement.style.height = `${this.dimensions.canvasHeight}px`;\n              }\n              setColors(e) {\n                this._colors = e, this._injectCss();\n              }\n              _injectCss() {\n                this._themeStyleElement || (this._themeStyleElement = document.createElement(\"style\"), this._screenElement.appendChild(this._themeStyleElement));\n                let e = `${this._terminalSelector} .xterm-rows { color: ${this._colors.foreground.css}; font-family: ${this._optionsService.rawOptions.fontFamily}; font-size: ${this._optionsService.rawOptions.fontSize}px;}`;\n                e += `${this._terminalSelector} span:not(.${n.BOLD_CLASS}) { font-weight: ${this._optionsService.rawOptions.fontWeight};}${this._terminalSelector} span.${n.BOLD_CLASS} { font-weight: ${this._optionsService.rawOptions.fontWeightBold};}${this._terminalSelector} span.${n.ITALIC_CLASS} { font-style: italic;}`, e += \"@keyframes blink_box_shadow_\" + this._terminalClass + \" { 50% {  box-shadow: none; }}\", e += \"@keyframes blink_block_\" + this._terminalClass + \" { 0% {\" + `  background-color: ${this._colors.cursor.css};` + `  color: ${this._colors.cursorAccent.css}; } 50% {` + `  background-color: ${this._colors.cursorAccent.css};` + `  color: ${this._colors.cursor.css}; }}`, e += `${this._terminalSelector} .xterm-rows:not(.xterm-focus) .${n.CURSOR_CLASS}.${n.CURSOR_STYLE_BLOCK_CLASS} { outline: 1px solid ${this._colors.cursor.css}; outline-offset: -1px;}${this._terminalSelector} .xterm-rows.xterm-focus .${n.CURSOR_CLASS}.${n.CURSOR_BLINK_CLASS}:not(.${n.CURSOR_STYLE_BLOCK_CLASS}) { animation: blink_box_shadow_` + this._terminalClass + \" 1s step-end infinite;}\" + `${this._terminalSelector} .xterm-rows.xterm-focus .${n.CURSOR_CLASS}.${n.CURSOR_BLINK_CLASS}.${n.CURSOR_STYLE_BLOCK_CLASS} { animation: blink_block_` + this._terminalClass + \" 1s step-end infinite;}\" + `${this._terminalSelector} .xterm-rows.xterm-focus .${n.CURSOR_CLASS}.${n.CURSOR_STYLE_BLOCK_CLASS} {` + ` background-color: ${this._colors.cursor.css};` + ` color: ${this._colors.cursorAccent.css};}` + `${this._terminalSelector} .xterm-rows .${n.CURSOR_CLASS}.${n.CURSOR_STYLE_BAR_CLASS} {` + ` box-shadow: ${this._optionsService.rawOptions.cursorWidth}px 0 0 ${this._colors.cursor.css} inset;}` + `${this._terminalSelector} .xterm-rows .${n.CURSOR_CLASS}.${n.CURSOR_STYLE_UNDERLINE_CLASS} {` + ` box-shadow: 0 -1px 0 ${this._colors.cursor.css} inset;}`, e += `${this._terminalSelector} .xterm-selection { position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none;}${this._terminalSelector}.focus .xterm-selection div { position: absolute; background-color: ${this._colors.selectionBackgroundOpaque.css};}${this._terminalSelector} .xterm-selection div { position: absolute; background-color: ${this._colors.selectionInactiveBackgroundOpaque.css};}`, this._colors.ansi.forEach((t, i) => {\n                  e += `${this._terminalSelector} .xterm-fg-${i} { color: ${t.css}; }${this._terminalSelector} .xterm-bg-${i} { background-color: ${t.css}; }`;\n                }), e += `${this._terminalSelector} .xterm-fg-${o.INVERTED_DEFAULT_COLOR} { color: ${d.color.opaque(this._colors.background).css}; }${this._terminalSelector} .xterm-bg-${o.INVERTED_DEFAULT_COLOR} { background-color: ${this._colors.foreground.css}; }`, this._themeStyleElement.textContent = e;\n              }\n              onDevicePixelRatioChange() {\n                this._updateDimensions();\n              }\n              _refreshRowElements(e, t) {\n                for (let e = this._rowElements.length; e <= t; e++) {\n                  const e = document.createElement(\"div\");\n                  this._rowContainer.appendChild(e), this._rowElements.push(e);\n                }\n                for (; this._rowElements.length > t;) this._rowContainer.removeChild(this._rowElements.pop());\n              }\n              onResize(e, t) {\n                this._refreshRowElements(e, t), this._updateDimensions();\n              }\n              onCharSizeChanged() {\n                this._updateDimensions();\n              }\n              onBlur() {\n                this._rowContainer.classList.remove(f);\n              }\n              onFocus() {\n                this._rowContainer.classList.add(f);\n              }\n              onSelectionChanged(e, t, i) {\n                for (; this._selectionContainer.children.length;) this._selectionContainer.removeChild(this._selectionContainer.children[0]);\n                if (this._rowFactory.onSelectionChanged(e, t, i), this.renderRows(0, this._bufferService.rows - 1), !e || !t) return;\n                const s = e[1] - this._bufferService.buffer.ydisp,\n                  r = t[1] - this._bufferService.buffer.ydisp,\n                  n = Math.max(s, 0),\n                  o = Math.min(r, this._bufferService.rows - 1);\n                if (n >= this._bufferService.rows || o < 0) return;\n                const a = document.createDocumentFragment();\n                if (i) {\n                  const i = e[0] > t[0];\n                  a.appendChild(this._createSelectionElement(n, i ? t[0] : e[0], i ? e[0] : t[0], o - n + 1));\n                } else {\n                  const i = s === n ? e[0] : 0,\n                    h = n === r ? t[0] : this._bufferService.cols;\n                  a.appendChild(this._createSelectionElement(n, i, h));\n                  const c = o - n - 1;\n                  if (a.appendChild(this._createSelectionElement(n + 1, 0, this._bufferService.cols, c)), n !== o) {\n                    const e = r === o ? t[0] : this._bufferService.cols;\n                    a.appendChild(this._createSelectionElement(o, 0, e));\n                  }\n                }\n                this._selectionContainer.appendChild(a);\n              }\n              _createSelectionElement(e, t, i, s = 1) {\n                const r = document.createElement(\"div\");\n                return r.style.height = s * this.dimensions.actualCellHeight + \"px\", r.style.top = e * this.dimensions.actualCellHeight + \"px\", r.style.left = t * this.dimensions.actualCellWidth + \"px\", r.style.width = this.dimensions.actualCellWidth * (i - t) + \"px\", r;\n              }\n              onCursorMove() {}\n              onOptionsChanged() {\n                this._updateDimensions(), this._injectCss();\n              }\n              clear() {\n                for (const e of this._rowElements) e.innerText = \"\";\n              }\n              renderRows(e, t) {\n                const i = this._bufferService.buffer.ybase + this._bufferService.buffer.y,\n                  s = Math.min(this._bufferService.buffer.x, this._bufferService.cols - 1),\n                  r = this._optionsService.rawOptions.cursorBlink;\n                for (let n = e; n <= t; n++) {\n                  const e = this._rowElements[n];\n                  e.innerText = \"\";\n                  const t = n + this._bufferService.buffer.ydisp,\n                    o = this._bufferService.buffer.lines.get(t),\n                    a = this._optionsService.rawOptions.cursorStyle;\n                  e.appendChild(this._rowFactory.createRow(o, t, t === i, a, s, r, this.dimensions.actualCellWidth, this._bufferService.cols));\n                }\n              }\n              get _terminalSelector() {\n                return `.${u}${this._terminalClass}`;\n              }\n              _onLinkHover(e) {\n                this._setCellUnderline(e.x1, e.x2, e.y1, e.y2, e.cols, !0);\n              }\n              _onLinkLeave(e) {\n                this._setCellUnderline(e.x1, e.x2, e.y1, e.y2, e.cols, !1);\n              }\n              _setCellUnderline(e, t, i, s, r, n) {\n                for (; e !== t || i !== s;) {\n                  const t = this._rowElements[i];\n                  if (!t) return;\n                  const s = t.children[e];\n                  s && (s.style.textDecoration = n ? \"underline\" : \"none\"), ++e >= r && (e = 0, i++);\n                }\n              }\n            };\n          g = s([r(5, c.IInstantiationService), r(6, h.ICharSizeService), r(7, c.IOptionsService), r(8, c.IBufferService), r(9, h.ICoreBrowserService)], g), t.DomRenderer = g;\n        },\n        3787: function (e, t, i) {\n          var s = this && this.__decorate || function (e, t, i, s) {\n              var r,\n                n = arguments.length,\n                o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;\n              if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);else for (var a = e.length - 1; a >= 0; a--) (r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);\n              return n > 3 && o && Object.defineProperty(t, i, o), o;\n            },\n            r = this && this.__param || function (e, t) {\n              return function (i, s) {\n                t(i, s, e);\n              };\n            };\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.DomRendererRowFactory = t.CURSOR_STYLE_UNDERLINE_CLASS = t.CURSOR_STYLE_BAR_CLASS = t.CURSOR_STYLE_BLOCK_CLASS = t.CURSOR_BLINK_CLASS = t.CURSOR_CLASS = t.STRIKETHROUGH_CLASS = t.UNDERLINE_CLASS = t.ITALIC_CLASS = t.DIM_CLASS = t.BOLD_CLASS = void 0;\n          const n = i(8036),\n            o = i(643),\n            a = i(511),\n            h = i(2585),\n            c = i(8055),\n            l = i(4725),\n            d = i(4269),\n            _ = i(1752),\n            u = i(3734);\n          t.BOLD_CLASS = \"xterm-bold\", t.DIM_CLASS = \"xterm-dim\", t.ITALIC_CLASS = \"xterm-italic\", t.UNDERLINE_CLASS = \"xterm-underline\", t.STRIKETHROUGH_CLASS = \"xterm-strikethrough\", t.CURSOR_CLASS = \"xterm-cursor\", t.CURSOR_BLINK_CLASS = \"xterm-cursor-blink\", t.CURSOR_STYLE_BLOCK_CLASS = \"xterm-cursor-block\", t.CURSOR_STYLE_BAR_CLASS = \"xterm-cursor-bar\", t.CURSOR_STYLE_UNDERLINE_CLASS = \"xterm-cursor-underline\";\n          let f = class {\n            constructor(e, t, i, s, r, n, o) {\n              this._document = e, this._colors = t, this._characterJoinerService = i, this._optionsService = s, this._coreBrowserService = r, this._coreService = n, this._decorationService = o, this._workCell = new a.CellData(), this._columnSelectMode = !1;\n            }\n            setColors(e) {\n              this._colors = e;\n            }\n            onSelectionChanged(e, t, i) {\n              this._selectionStart = e, this._selectionEnd = t, this._columnSelectMode = i;\n            }\n            createRow(e, i, s, r, a, h, l, _) {\n              const f = this._document.createDocumentFragment(),\n                g = this._characterJoinerService.getJoinedCharacters(i);\n              let p = 0;\n              for (let t = Math.min(e.length, _) - 1; t >= 0; t--) if (e.loadCell(t, this._workCell).getCode() !== o.NULL_CELL_CODE || s && t === a) {\n                p = t + 1;\n                break;\n              }\n              for (let _ = 0; _ < p; _++) {\n                e.loadCell(_, this._workCell);\n                let p = this._workCell.getWidth();\n                if (0 === p) continue;\n                let S = !1,\n                  m = _,\n                  C = this._workCell;\n                if (g.length > 0 && _ === g[0][0]) {\n                  S = !0;\n                  const t = g.shift();\n                  C = new d.JoinedCellData(this._workCell, e.translateToString(!0, t[0], t[1]), t[1] - t[0]), m = t[1] - 1, p = C.getWidth();\n                }\n                const b = this._document.createElement(\"span\");\n                if (p > 1 && (b.style.width = l * p + \"px\"), S && (b.style.display = \"inline\", a >= _ && a <= m && (a = _)), !this._coreService.isCursorHidden && s && _ === a) switch (b.classList.add(t.CURSOR_CLASS), h && b.classList.add(t.CURSOR_BLINK_CLASS), r) {\n                  case \"bar\":\n                    b.classList.add(t.CURSOR_STYLE_BAR_CLASS);\n                    break;\n                  case \"underline\":\n                    b.classList.add(t.CURSOR_STYLE_UNDERLINE_CLASS);\n                    break;\n                  default:\n                    b.classList.add(t.CURSOR_STYLE_BLOCK_CLASS);\n                }\n                if (C.isBold() && b.classList.add(t.BOLD_CLASS), C.isItalic() && b.classList.add(t.ITALIC_CLASS), C.isDim() && b.classList.add(t.DIM_CLASS), C.isInvisible() ? b.textContent = o.WHITESPACE_CELL_CHAR : b.textContent = C.getChars() || o.WHITESPACE_CELL_CHAR, C.isUnderline() && (b.classList.add(`${t.UNDERLINE_CLASS}-${C.extended.underlineStyle}`), \" \" === b.textContent && (b.innerHTML = \"&nbsp;\"), !C.isUnderlineColorDefault())) if (C.isUnderlineColorRGB()) b.style.textDecorationColor = `rgb(${u.AttributeData.toColorRGB(C.getUnderlineColor()).join(\",\")})`;else {\n                  let e = C.getUnderlineColor();\n                  this._optionsService.rawOptions.drawBoldTextInBrightColors && C.isBold() && e < 8 && (e += 8), b.style.textDecorationColor = this._colors.ansi[e].css;\n                }\n                C.isStrikethrough() && b.classList.add(t.STRIKETHROUGH_CLASS);\n                let y = C.getFgColor(),\n                  w = C.getFgColorMode(),\n                  E = C.getBgColor(),\n                  L = C.getBgColorMode();\n                const R = !!C.isInverse();\n                if (R) {\n                  const e = y;\n                  y = E, E = e;\n                  const t = w;\n                  w = L, L = t;\n                }\n                let k,\n                  D,\n                  A = !1;\n                this._decorationService.forEachDecorationAtCell(_, i, void 0, e => {\n                  \"top\" !== e.options.layer && A || (e.backgroundColorRGB && (L = 50331648, E = e.backgroundColorRGB.rgba >> 8 & 16777215, k = e.backgroundColorRGB), e.foregroundColorRGB && (w = 50331648, y = e.foregroundColorRGB.rgba >> 8 & 16777215, D = e.foregroundColorRGB), A = \"top\" === e.options.layer);\n                });\n                const x = this._isCellInSelection(_, i);\n                let B;\n                switch (A || this._colors.selectionForeground && x && (w = 50331648, y = this._colors.selectionForeground.rgba >> 8 & 16777215, D = this._colors.selectionForeground), x && (k = this._coreBrowserService.isFocused ? this._colors.selectionBackgroundOpaque : this._colors.selectionInactiveBackgroundOpaque, A = !0), A && b.classList.add(\"xterm-decoration-top\"), L) {\n                  case 16777216:\n                  case 33554432:\n                    B = this._colors.ansi[E], b.classList.add(`xterm-bg-${E}`);\n                    break;\n                  case 50331648:\n                    B = c.rgba.toColor(E >> 16, E >> 8 & 255, 255 & E), this._addStyle(b, `background-color:#${v((E >>> 0).toString(16), \"0\", 6)}`);\n                    break;\n                  default:\n                    R ? (B = this._colors.foreground, b.classList.add(`xterm-bg-${n.INVERTED_DEFAULT_COLOR}`)) : B = this._colors.background;\n                }\n                switch (k || C.isDim() && (k = c.color.multiplyOpacity(B, .5)), w) {\n                  case 16777216:\n                  case 33554432:\n                    C.isBold() && y < 8 && this._optionsService.rawOptions.drawBoldTextInBrightColors && (y += 8), this._applyMinimumContrast(b, B, this._colors.ansi[y], C, k, void 0) || b.classList.add(`xterm-fg-${y}`);\n                    break;\n                  case 50331648:\n                    const e = c.rgba.toColor(y >> 16 & 255, y >> 8 & 255, 255 & y);\n                    this._applyMinimumContrast(b, B, e, C, k, D) || this._addStyle(b, `color:#${v(y.toString(16), \"0\", 6)}`);\n                    break;\n                  default:\n                    this._applyMinimumContrast(b, B, this._colors.foreground, C, k, void 0) || R && b.classList.add(`xterm-fg-${n.INVERTED_DEFAULT_COLOR}`);\n                }\n                f.appendChild(b), _ = m;\n              }\n              return f;\n            }\n            _applyMinimumContrast(e, t, i, s, r, n) {\n              if (1 === this._optionsService.rawOptions.minimumContrastRatio || (0, _.excludeFromContrastRatioDemands)(s.getCode())) return !1;\n              let o;\n              return r || n || (o = this._colors.contrastCache.getColor(t.rgba, i.rgba)), void 0 === o && (o = c.color.ensureContrastRatio(r || t, n || i, this._optionsService.rawOptions.minimumContrastRatio), this._colors.contrastCache.setColor((r || t).rgba, (n || i).rgba, null != o ? o : null)), !!o && (this._addStyle(e, `color:${o.css}`), !0);\n            }\n            _addStyle(e, t) {\n              e.setAttribute(\"style\", `${e.getAttribute(\"style\") || \"\"}${t};`);\n            }\n            _isCellInSelection(e, t) {\n              const i = this._selectionStart,\n                s = this._selectionEnd;\n              return !(!i || !s) && (this._columnSelectMode ? i[0] <= s[0] ? e >= i[0] && t >= i[1] && e < s[0] && t <= s[1] : e < i[0] && t >= i[1] && e >= s[0] && t <= s[1] : t > i[1] && t < s[1] || i[1] === s[1] && t === i[1] && e >= i[0] && e < s[0] || i[1] < s[1] && t === s[1] && e < s[0] || i[1] < s[1] && t === i[1] && e >= i[0]);\n            }\n          };\n          function v(e, t, i) {\n            for (; e.length < i;) e = t + e;\n            return e;\n          }\n          f = s([r(2, l.ICharacterJoinerService), r(3, h.IOptionsService), r(4, l.ICoreBrowserService), r(5, h.ICoreService), r(6, h.IDecorationService)], f), t.DomRendererRowFactory = f;\n        },\n        456: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.SelectionModel = void 0, t.SelectionModel = class {\n            constructor(e) {\n              this._bufferService = e, this.isSelectAllActive = !1, this.selectionStartLength = 0;\n            }\n            clearSelection() {\n              this.selectionStart = void 0, this.selectionEnd = void 0, this.isSelectAllActive = !1, this.selectionStartLength = 0;\n            }\n            get finalSelectionStart() {\n              return this.isSelectAllActive ? [0, 0] : this.selectionEnd && this.selectionStart && this.areSelectionValuesReversed() ? this.selectionEnd : this.selectionStart;\n            }\n            get finalSelectionEnd() {\n              if (this.isSelectAllActive) return [this._bufferService.cols, this._bufferService.buffer.ybase + this._bufferService.rows - 1];\n              if (this.selectionStart) {\n                if (!this.selectionEnd || this.areSelectionValuesReversed()) {\n                  const e = this.selectionStart[0] + this.selectionStartLength;\n                  return e > this._bufferService.cols ? e % this._bufferService.cols == 0 ? [this._bufferService.cols, this.selectionStart[1] + Math.floor(e / this._bufferService.cols) - 1] : [e % this._bufferService.cols, this.selectionStart[1] + Math.floor(e / this._bufferService.cols)] : [e, this.selectionStart[1]];\n                }\n                if (this.selectionStartLength && this.selectionEnd[1] === this.selectionStart[1]) {\n                  const e = this.selectionStart[0] + this.selectionStartLength;\n                  return e > this._bufferService.cols ? [e % this._bufferService.cols, this.selectionStart[1] + Math.floor(e / this._bufferService.cols)] : [Math.max(e, this.selectionEnd[0]), this.selectionEnd[1]];\n                }\n                return this.selectionEnd;\n              }\n            }\n            areSelectionValuesReversed() {\n              const e = this.selectionStart,\n                t = this.selectionEnd;\n              return !(!e || !t) && (e[1] > t[1] || e[1] === t[1] && e[0] > t[0]);\n            }\n            onTrim(e) {\n              return this.selectionStart && (this.selectionStart[1] -= e), this.selectionEnd && (this.selectionEnd[1] -= e), this.selectionEnd && this.selectionEnd[1] < 0 ? (this.clearSelection(), !0) : (this.selectionStart && this.selectionStart[1] < 0 && (this.selectionStart[1] = 0), !1);\n            }\n          };\n        },\n        428: function (e, t, i) {\n          var s = this && this.__decorate || function (e, t, i, s) {\n              var r,\n                n = arguments.length,\n                o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;\n              if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);else for (var a = e.length - 1; a >= 0; a--) (r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);\n              return n > 3 && o && Object.defineProperty(t, i, o), o;\n            },\n            r = this && this.__param || function (e, t) {\n              return function (i, s) {\n                t(i, s, e);\n              };\n            };\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.CharSizeService = void 0;\n          const n = i(2585),\n            o = i(8460);\n          let a = class {\n            constructor(e, t, i) {\n              this._optionsService = i, this.width = 0, this.height = 0, this._onCharSizeChange = new o.EventEmitter(), this._measureStrategy = new h(e, t, this._optionsService);\n            }\n            get hasValidSize() {\n              return this.width > 0 && this.height > 0;\n            }\n            get onCharSizeChange() {\n              return this._onCharSizeChange.event;\n            }\n            measure() {\n              const e = this._measureStrategy.measure();\n              e.width === this.width && e.height === this.height || (this.width = e.width, this.height = e.height, this._onCharSizeChange.fire());\n            }\n          };\n          a = s([r(2, n.IOptionsService)], a), t.CharSizeService = a;\n          class h {\n            constructor(e, t, i) {\n              this._document = e, this._parentElement = t, this._optionsService = i, this._result = {\n                width: 0,\n                height: 0\n              }, this._measureElement = this._document.createElement(\"span\"), this._measureElement.classList.add(\"xterm-char-measure-element\"), this._measureElement.textContent = \"W\", this._measureElement.setAttribute(\"aria-hidden\", \"true\"), this._parentElement.appendChild(this._measureElement);\n            }\n            measure() {\n              this._measureElement.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._measureElement.style.fontSize = `${this._optionsService.rawOptions.fontSize}px`;\n              const e = this._measureElement.getBoundingClientRect();\n              return 0 !== e.width && 0 !== e.height && (this._result.width = e.width, this._result.height = Math.ceil(e.height)), this._result;\n            }\n          }\n        },\n        4269: function (e, t, i) {\n          var s = this && this.__decorate || function (e, t, i, s) {\n              var r,\n                n = arguments.length,\n                o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;\n              if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);else for (var a = e.length - 1; a >= 0; a--) (r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);\n              return n > 3 && o && Object.defineProperty(t, i, o), o;\n            },\n            r = this && this.__param || function (e, t) {\n              return function (i, s) {\n                t(i, s, e);\n              };\n            };\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.CharacterJoinerService = t.JoinedCellData = void 0;\n          const n = i(3734),\n            o = i(643),\n            a = i(511),\n            h = i(2585);\n          class c extends n.AttributeData {\n            constructor(e, t, i) {\n              super(), this.content = 0, this.combinedData = \"\", this.fg = e.fg, this.bg = e.bg, this.combinedData = t, this._width = i;\n            }\n            isCombined() {\n              return 2097152;\n            }\n            getWidth() {\n              return this._width;\n            }\n            getChars() {\n              return this.combinedData;\n            }\n            getCode() {\n              return 2097151;\n            }\n            setFromCharData(e) {\n              throw new Error(\"not implemented\");\n            }\n            getAsCharData() {\n              return [this.fg, this.getChars(), this.getWidth(), this.getCode()];\n            }\n          }\n          t.JoinedCellData = c;\n          let l = class e {\n            constructor(e) {\n              this._bufferService = e, this._characterJoiners = [], this._nextCharacterJoinerId = 0, this._workCell = new a.CellData();\n            }\n            register(e) {\n              const t = {\n                id: this._nextCharacterJoinerId++,\n                handler: e\n              };\n              return this._characterJoiners.push(t), t.id;\n            }\n            deregister(e) {\n              for (let t = 0; t < this._characterJoiners.length; t++) if (this._characterJoiners[t].id === e) return this._characterJoiners.splice(t, 1), !0;\n              return !1;\n            }\n            getJoinedCharacters(e) {\n              if (0 === this._characterJoiners.length) return [];\n              const t = this._bufferService.buffer.lines.get(e);\n              if (!t || 0 === t.length) return [];\n              const i = [],\n                s = t.translateToString(!0);\n              let r = 0,\n                n = 0,\n                a = 0,\n                h = t.getFg(0),\n                c = t.getBg(0);\n              for (let e = 0; e < t.getTrimmedLength(); e++) if (t.loadCell(e, this._workCell), 0 !== this._workCell.getWidth()) {\n                if (this._workCell.fg !== h || this._workCell.bg !== c) {\n                  if (e - r > 1) {\n                    const e = this._getJoinedRanges(s, a, n, t, r);\n                    for (let t = 0; t < e.length; t++) i.push(e[t]);\n                  }\n                  r = e, a = n, h = this._workCell.fg, c = this._workCell.bg;\n                }\n                n += this._workCell.getChars().length || o.WHITESPACE_CELL_CHAR.length;\n              }\n              if (this._bufferService.cols - r > 1) {\n                const e = this._getJoinedRanges(s, a, n, t, r);\n                for (let t = 0; t < e.length; t++) i.push(e[t]);\n              }\n              return i;\n            }\n            _getJoinedRanges(t, i, s, r, n) {\n              const o = t.substring(i, s);\n              let a = [];\n              try {\n                a = this._characterJoiners[0].handler(o);\n              } catch (e) {\n                console.error(e);\n              }\n              for (let t = 1; t < this._characterJoiners.length; t++) try {\n                const i = this._characterJoiners[t].handler(o);\n                for (let t = 0; t < i.length; t++) e._mergeRanges(a, i[t]);\n              } catch (e) {\n                console.error(e);\n              }\n              return this._stringRangesToCellRanges(a, r, n), a;\n            }\n            _stringRangesToCellRanges(e, t, i) {\n              let s = 0,\n                r = !1,\n                n = 0,\n                a = e[s];\n              if (a) {\n                for (let h = i; h < this._bufferService.cols; h++) {\n                  const i = t.getWidth(h),\n                    c = t.getString(h).length || o.WHITESPACE_CELL_CHAR.length;\n                  if (0 !== i) {\n                    if (!r && a[0] <= n && (a[0] = h, r = !0), a[1] <= n) {\n                      if (a[1] = h, a = e[++s], !a) break;\n                      a[0] <= n ? (a[0] = h, r = !0) : r = !1;\n                    }\n                    n += c;\n                  }\n                }\n                a && (a[1] = this._bufferService.cols);\n              }\n            }\n            static _mergeRanges(e, t) {\n              let i = !1;\n              for (let s = 0; s < e.length; s++) {\n                const r = e[s];\n                if (i) {\n                  if (t[1] <= r[0]) return e[s - 1][1] = t[1], e;\n                  if (t[1] <= r[1]) return e[s - 1][1] = Math.max(t[1], r[1]), e.splice(s, 1), e;\n                  e.splice(s, 1), s--;\n                } else {\n                  if (t[1] <= r[0]) return e.splice(s, 0, t), e;\n                  if (t[1] <= r[1]) return r[0] = Math.min(t[0], r[0]), e;\n                  t[0] < r[1] && (r[0] = Math.min(t[0], r[0]), i = !0);\n                }\n              }\n              return i ? e[e.length - 1][1] = t[1] : e.push(t), e;\n            }\n          };\n          l = s([r(0, h.IBufferService)], l), t.CharacterJoinerService = l;\n        },\n        5114: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.CoreBrowserService = void 0, t.CoreBrowserService = class {\n            constructor(e, t) {\n              this._textarea = e, this.window = t;\n            }\n            get dpr() {\n              return this.window.devicePixelRatio;\n            }\n            get isFocused() {\n              return (this._textarea.getRootNode ? this._textarea.getRootNode() : this._textarea.ownerDocument).activeElement === this._textarea && this._textarea.ownerDocument.hasFocus();\n            }\n          };\n        },\n        8934: function (e, t, i) {\n          var s = this && this.__decorate || function (e, t, i, s) {\n              var r,\n                n = arguments.length,\n                o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;\n              if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);else for (var a = e.length - 1; a >= 0; a--) (r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);\n              return n > 3 && o && Object.defineProperty(t, i, o), o;\n            },\n            r = this && this.__param || function (e, t) {\n              return function (i, s) {\n                t(i, s, e);\n              };\n            };\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.MouseService = void 0;\n          const n = i(4725),\n            o = i(9806);\n          let a = class {\n            constructor(e, t) {\n              this._renderService = e, this._charSizeService = t;\n            }\n            getCoords(e, t, i, s, r) {\n              return (0, o.getCoords)(window, e, t, i, s, this._charSizeService.hasValidSize, this._renderService.dimensions.actualCellWidth, this._renderService.dimensions.actualCellHeight, r);\n            }\n            getMouseReportCoords(e, t) {\n              const i = (0, o.getCoordsRelativeToElement)(window, e, t);\n              if (!(!this._charSizeService.hasValidSize || i[0] < 0 || i[1] < 0 || i[0] >= this._renderService.dimensions.canvasWidth || i[1] >= this._renderService.dimensions.canvasHeight)) return {\n                col: Math.floor(i[0] / this._renderService.dimensions.actualCellWidth),\n                row: Math.floor(i[1] / this._renderService.dimensions.actualCellHeight),\n                x: Math.floor(i[0]),\n                y: Math.floor(i[1])\n              };\n            }\n          };\n          a = s([r(0, n.IRenderService), r(1, n.ICharSizeService)], a), t.MouseService = a;\n        },\n        3230: function (e, t, i) {\n          var s = this && this.__decorate || function (e, t, i, s) {\n              var r,\n                n = arguments.length,\n                o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;\n              if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);else for (var a = e.length - 1; a >= 0; a--) (r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);\n              return n > 3 && o && Object.defineProperty(t, i, o), o;\n            },\n            r = this && this.__param || function (e, t) {\n              return function (i, s) {\n                t(i, s, e);\n              };\n            };\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.RenderService = void 0;\n          const n = i(6193),\n            o = i(8460),\n            a = i(844),\n            h = i(5596),\n            c = i(3656),\n            l = i(2585),\n            d = i(4725);\n          let _ = class extends a.Disposable {\n            constructor(e, t, i, s, r, a, l, d) {\n              if (super(), this._renderer = e, this._rowCount = t, this._charSizeService = r, this._isPaused = !1, this._needsFullRefresh = !1, this._isNextRenderRedrawOnly = !0, this._needsSelectionRefresh = !1, this._canvasWidth = 0, this._canvasHeight = 0, this._selectionState = {\n                start: void 0,\n                end: void 0,\n                columnSelectMode: !1\n              }, this._onDimensionsChange = new o.EventEmitter(), this._onRenderedViewportChange = new o.EventEmitter(), this._onRender = new o.EventEmitter(), this._onRefreshRequest = new o.EventEmitter(), this.register({\n                dispose: () => this._renderer.dispose()\n              }), this._renderDebouncer = new n.RenderDebouncer(d.window, (e, t) => this._renderRows(e, t)), this.register(this._renderDebouncer), this._screenDprMonitor = new h.ScreenDprMonitor(d.window), this._screenDprMonitor.setListener(() => this.onDevicePixelRatioChange()), this.register(this._screenDprMonitor), this.register(l.onResize(() => this._fullRefresh())), this.register(l.buffers.onBufferActivate(() => {\n                var e;\n                return null === (e = this._renderer) || void 0 === e ? void 0 : e.clear();\n              })), this.register(s.onOptionChange(() => this._handleOptionsChanged())), this.register(this._charSizeService.onCharSizeChange(() => this.onCharSizeChanged())), this.register(a.onDecorationRegistered(() => this._fullRefresh())), this.register(a.onDecorationRemoved(() => this._fullRefresh())), this._renderer.onRequestRedraw(e => this.refreshRows(e.start, e.end, !0)), this.register((0, c.addDisposableDomListener)(d.window, \"resize\", () => this.onDevicePixelRatioChange())), \"IntersectionObserver\" in d.window) {\n                const e = new d.window.IntersectionObserver(e => this._onIntersectionChange(e[e.length - 1]), {\n                  threshold: 0\n                });\n                e.observe(i), this.register({\n                  dispose: () => e.disconnect()\n                });\n              }\n            }\n            get onDimensionsChange() {\n              return this._onDimensionsChange.event;\n            }\n            get onRenderedViewportChange() {\n              return this._onRenderedViewportChange.event;\n            }\n            get onRender() {\n              return this._onRender.event;\n            }\n            get onRefreshRequest() {\n              return this._onRefreshRequest.event;\n            }\n            get dimensions() {\n              return this._renderer.dimensions;\n            }\n            _onIntersectionChange(e) {\n              this._isPaused = void 0 === e.isIntersecting ? 0 === e.intersectionRatio : !e.isIntersecting, this._isPaused || this._charSizeService.hasValidSize || this._charSizeService.measure(), !this._isPaused && this._needsFullRefresh && (this.refreshRows(0, this._rowCount - 1), this._needsFullRefresh = !1);\n            }\n            refreshRows(e, t, i = !1) {\n              this._isPaused ? this._needsFullRefresh = !0 : (i || (this._isNextRenderRedrawOnly = !1), this._renderDebouncer.refresh(e, t, this._rowCount));\n            }\n            _renderRows(e, t) {\n              this._renderer.renderRows(e, t), this._needsSelectionRefresh && (this._renderer.onSelectionChanged(this._selectionState.start, this._selectionState.end, this._selectionState.columnSelectMode), this._needsSelectionRefresh = !1), this._isNextRenderRedrawOnly || this._onRenderedViewportChange.fire({\n                start: e,\n                end: t\n              }), this._onRender.fire({\n                start: e,\n                end: t\n              }), this._isNextRenderRedrawOnly = !0;\n            }\n            resize(e, t) {\n              this._rowCount = t, this._fireOnCanvasResize();\n            }\n            _handleOptionsChanged() {\n              this._renderer.onOptionsChanged(), this.refreshRows(0, this._rowCount - 1), this._fireOnCanvasResize();\n            }\n            _fireOnCanvasResize() {\n              this._renderer.dimensions.canvasWidth === this._canvasWidth && this._renderer.dimensions.canvasHeight === this._canvasHeight || this._onDimensionsChange.fire(this._renderer.dimensions);\n            }\n            dispose() {\n              super.dispose();\n            }\n            setRenderer(e) {\n              this._renderer.dispose(), this._renderer = e, this._renderer.onRequestRedraw(e => this.refreshRows(e.start, e.end, !0)), this._needsSelectionRefresh = !0, this._fullRefresh();\n            }\n            addRefreshCallback(e) {\n              return this._renderDebouncer.addRefreshCallback(e);\n            }\n            _fullRefresh() {\n              this._isPaused ? this._needsFullRefresh = !0 : this.refreshRows(0, this._rowCount - 1);\n            }\n            clearTextureAtlas() {\n              var e, t;\n              null === (t = null === (e = this._renderer) || void 0 === e ? void 0 : e.clearTextureAtlas) || void 0 === t || t.call(e), this._fullRefresh();\n            }\n            setColors(e) {\n              this._renderer.setColors(e), this._fullRefresh();\n            }\n            onDevicePixelRatioChange() {\n              this._charSizeService.measure(), this._renderer.onDevicePixelRatioChange(), this.refreshRows(0, this._rowCount - 1);\n            }\n            onResize(e, t) {\n              this._renderer.onResize(e, t), this._fullRefresh();\n            }\n            onCharSizeChanged() {\n              this._renderer.onCharSizeChanged();\n            }\n            onBlur() {\n              this._renderer.onBlur();\n            }\n            onFocus() {\n              this._renderer.onFocus();\n            }\n            onSelectionChanged(e, t, i) {\n              this._selectionState.start = e, this._selectionState.end = t, this._selectionState.columnSelectMode = i, this._renderer.onSelectionChanged(e, t, i);\n            }\n            onCursorMove() {\n              this._renderer.onCursorMove();\n            }\n            clear() {\n              this._renderer.clear();\n            }\n          };\n          _ = s([r(3, l.IOptionsService), r(4, d.ICharSizeService), r(5, l.IDecorationService), r(6, l.IBufferService), r(7, d.ICoreBrowserService)], _), t.RenderService = _;\n        },\n        9312: function (e, t, i) {\n          var s = this && this.__decorate || function (e, t, i, s) {\n              var r,\n                n = arguments.length,\n                o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;\n              if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);else for (var a = e.length - 1; a >= 0; a--) (r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);\n              return n > 3 && o && Object.defineProperty(t, i, o), o;\n            },\n            r = this && this.__param || function (e, t) {\n              return function (i, s) {\n                t(i, s, e);\n              };\n            };\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.SelectionService = void 0;\n          const n = i(6114),\n            o = i(456),\n            a = i(511),\n            h = i(8460),\n            c = i(4725),\n            l = i(2585),\n            d = i(9806),\n            _ = i(9504),\n            u = i(844),\n            f = i(4841),\n            v = String.fromCharCode(160),\n            g = new RegExp(v, \"g\");\n          let p = class extends u.Disposable {\n            constructor(e, t, i, s, r, n, c, l, d) {\n              super(), this._element = e, this._screenElement = t, this._linkifier = i, this._bufferService = s, this._coreService = r, this._mouseService = n, this._optionsService = c, this._renderService = l, this._coreBrowserService = d, this._dragScrollAmount = 0, this._enabled = !0, this._workCell = new a.CellData(), this._mouseDownTimeStamp = 0, this._oldHasSelection = !1, this._oldSelectionStart = void 0, this._oldSelectionEnd = void 0, this._onLinuxMouseSelection = this.register(new h.EventEmitter()), this._onRedrawRequest = this.register(new h.EventEmitter()), this._onSelectionChange = this.register(new h.EventEmitter()), this._onRequestScrollLines = this.register(new h.EventEmitter()), this._mouseMoveListener = e => this._onMouseMove(e), this._mouseUpListener = e => this._onMouseUp(e), this._coreService.onUserInput(() => {\n                this.hasSelection && this.clearSelection();\n              }), this._trimListener = this._bufferService.buffer.lines.onTrim(e => this._onTrim(e)), this.register(this._bufferService.buffers.onBufferActivate(e => this._onBufferActivate(e))), this.enable(), this._model = new o.SelectionModel(this._bufferService), this._activeSelectionMode = 0;\n            }\n            get onLinuxMouseSelection() {\n              return this._onLinuxMouseSelection.event;\n            }\n            get onRequestRedraw() {\n              return this._onRedrawRequest.event;\n            }\n            get onSelectionChange() {\n              return this._onSelectionChange.event;\n            }\n            get onRequestScrollLines() {\n              return this._onRequestScrollLines.event;\n            }\n            dispose() {\n              this._removeMouseDownListeners();\n            }\n            reset() {\n              this.clearSelection();\n            }\n            disable() {\n              this.clearSelection(), this._enabled = !1;\n            }\n            enable() {\n              this._enabled = !0;\n            }\n            get selectionStart() {\n              return this._model.finalSelectionStart;\n            }\n            get selectionEnd() {\n              return this._model.finalSelectionEnd;\n            }\n            get hasSelection() {\n              const e = this._model.finalSelectionStart,\n                t = this._model.finalSelectionEnd;\n              return !(!e || !t || e[0] === t[0] && e[1] === t[1]);\n            }\n            get selectionText() {\n              const e = this._model.finalSelectionStart,\n                t = this._model.finalSelectionEnd;\n              if (!e || !t) return \"\";\n              const i = this._bufferService.buffer,\n                s = [];\n              if (3 === this._activeSelectionMode) {\n                if (e[0] === t[0]) return \"\";\n                const r = e[0] < t[0] ? e[0] : t[0],\n                  n = e[0] < t[0] ? t[0] : e[0];\n                for (let o = e[1]; o <= t[1]; o++) {\n                  const e = i.translateBufferLineToString(o, !0, r, n);\n                  s.push(e);\n                }\n              } else {\n                const r = e[1] === t[1] ? t[0] : void 0;\n                s.push(i.translateBufferLineToString(e[1], !0, e[0], r));\n                for (let r = e[1] + 1; r <= t[1] - 1; r++) {\n                  const e = i.lines.get(r),\n                    t = i.translateBufferLineToString(r, !0);\n                  (null == e ? void 0 : e.isWrapped) ? s[s.length - 1] += t : s.push(t);\n                }\n                if (e[1] !== t[1]) {\n                  const e = i.lines.get(t[1]),\n                    r = i.translateBufferLineToString(t[1], !0, 0, t[0]);\n                  e && e.isWrapped ? s[s.length - 1] += r : s.push(r);\n                }\n              }\n              return s.map(e => e.replace(g, \" \")).join(n.isWindows ? \"\\r\\n\" : \"\\n\");\n            }\n            clearSelection() {\n              this._model.clearSelection(), this._removeMouseDownListeners(), this.refresh(), this._onSelectionChange.fire();\n            }\n            refresh(e) {\n              this._refreshAnimationFrame || (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._refresh())), n.isLinux && e && this.selectionText.length && this._onLinuxMouseSelection.fire(this.selectionText);\n            }\n            _refresh() {\n              this._refreshAnimationFrame = void 0, this._onRedrawRequest.fire({\n                start: this._model.finalSelectionStart,\n                end: this._model.finalSelectionEnd,\n                columnSelectMode: 3 === this._activeSelectionMode\n              });\n            }\n            _isClickInSelection(e) {\n              const t = this._getMouseBufferCoords(e),\n                i = this._model.finalSelectionStart,\n                s = this._model.finalSelectionEnd;\n              return !!(i && s && t) && this._areCoordsInSelection(t, i, s);\n            }\n            isCellInSelection(e, t) {\n              const i = this._model.finalSelectionStart,\n                s = this._model.finalSelectionEnd;\n              return !(!i || !s) && this._areCoordsInSelection([e, t], i, s);\n            }\n            _areCoordsInSelection(e, t, i) {\n              return e[1] > t[1] && e[1] < i[1] || t[1] === i[1] && e[1] === t[1] && e[0] >= t[0] && e[0] < i[0] || t[1] < i[1] && e[1] === i[1] && e[0] < i[0] || t[1] < i[1] && e[1] === t[1] && e[0] >= t[0];\n            }\n            _selectWordAtCursor(e, t) {\n              var i, s;\n              const r = null === (s = null === (i = this._linkifier.currentLink) || void 0 === i ? void 0 : i.link) || void 0 === s ? void 0 : s.range;\n              if (r) return this._model.selectionStart = [r.start.x - 1, r.start.y - 1], this._model.selectionStartLength = (0, f.getRangeLength)(r, this._bufferService.cols), this._model.selectionEnd = void 0, !0;\n              const n = this._getMouseBufferCoords(e);\n              return !!n && (this._selectWordAt(n, t), this._model.selectionEnd = void 0, !0);\n            }\n            selectAll() {\n              this._model.isSelectAllActive = !0, this.refresh(), this._onSelectionChange.fire();\n            }\n            selectLines(e, t) {\n              this._model.clearSelection(), e = Math.max(e, 0), t = Math.min(t, this._bufferService.buffer.lines.length - 1), this._model.selectionStart = [0, e], this._model.selectionEnd = [this._bufferService.cols, t], this.refresh(), this._onSelectionChange.fire();\n            }\n            _onTrim(e) {\n              this._model.onTrim(e) && this.refresh();\n            }\n            _getMouseBufferCoords(e) {\n              const t = this._mouseService.getCoords(e, this._screenElement, this._bufferService.cols, this._bufferService.rows, !0);\n              if (t) return t[0]--, t[1]--, t[1] += this._bufferService.buffer.ydisp, t;\n            }\n            _getMouseEventScrollAmount(e) {\n              let t = (0, d.getCoordsRelativeToElement)(this._coreBrowserService.window, e, this._screenElement)[1];\n              const i = this._renderService.dimensions.canvasHeight;\n              return t >= 0 && t <= i ? 0 : (t > i && (t -= i), t = Math.min(Math.max(t, -50), 50), t /= 50, t / Math.abs(t) + Math.round(14 * t));\n            }\n            shouldForceSelection(e) {\n              return n.isMac ? e.altKey && this._optionsService.rawOptions.macOptionClickForcesSelection : e.shiftKey;\n            }\n            onMouseDown(e) {\n              if (this._mouseDownTimeStamp = e.timeStamp, (2 !== e.button || !this.hasSelection) && 0 === e.button) {\n                if (!this._enabled) {\n                  if (!this.shouldForceSelection(e)) return;\n                  e.stopPropagation();\n                }\n                e.preventDefault(), this._dragScrollAmount = 0, this._enabled && e.shiftKey ? this._onIncrementalClick(e) : 1 === e.detail ? this._onSingleClick(e) : 2 === e.detail ? this._onDoubleClick(e) : 3 === e.detail && this._onTripleClick(e), this._addMouseDownListeners(), this.refresh(!0);\n              }\n            }\n            _addMouseDownListeners() {\n              this._screenElement.ownerDocument && (this._screenElement.ownerDocument.addEventListener(\"mousemove\", this._mouseMoveListener), this._screenElement.ownerDocument.addEventListener(\"mouseup\", this._mouseUpListener)), this._dragScrollIntervalTimer = this._coreBrowserService.window.setInterval(() => this._dragScroll(), 50);\n            }\n            _removeMouseDownListeners() {\n              this._screenElement.ownerDocument && (this._screenElement.ownerDocument.removeEventListener(\"mousemove\", this._mouseMoveListener), this._screenElement.ownerDocument.removeEventListener(\"mouseup\", this._mouseUpListener)), this._coreBrowserService.window.clearInterval(this._dragScrollIntervalTimer), this._dragScrollIntervalTimer = void 0;\n            }\n            _onIncrementalClick(e) {\n              this._model.selectionStart && (this._model.selectionEnd = this._getMouseBufferCoords(e));\n            }\n            _onSingleClick(e) {\n              if (this._model.selectionStartLength = 0, this._model.isSelectAllActive = !1, this._activeSelectionMode = this.shouldColumnSelect(e) ? 3 : 0, this._model.selectionStart = this._getMouseBufferCoords(e), !this._model.selectionStart) return;\n              this._model.selectionEnd = void 0;\n              const t = this._bufferService.buffer.lines.get(this._model.selectionStart[1]);\n              t && t.length !== this._model.selectionStart[0] && 0 === t.hasWidth(this._model.selectionStart[0]) && this._model.selectionStart[0]++;\n            }\n            _onDoubleClick(e) {\n              this._selectWordAtCursor(e, !0) && (this._activeSelectionMode = 1);\n            }\n            _onTripleClick(e) {\n              const t = this._getMouseBufferCoords(e);\n              t && (this._activeSelectionMode = 2, this._selectLineAt(t[1]));\n            }\n            shouldColumnSelect(e) {\n              return e.altKey && !(n.isMac && this._optionsService.rawOptions.macOptionClickForcesSelection);\n            }\n            _onMouseMove(e) {\n              if (e.stopImmediatePropagation(), !this._model.selectionStart) return;\n              const t = this._model.selectionEnd ? [this._model.selectionEnd[0], this._model.selectionEnd[1]] : null;\n              if (this._model.selectionEnd = this._getMouseBufferCoords(e), !this._model.selectionEnd) return void this.refresh(!0);\n              2 === this._activeSelectionMode ? this._model.selectionEnd[1] < this._model.selectionStart[1] ? this._model.selectionEnd[0] = 0 : this._model.selectionEnd[0] = this._bufferService.cols : 1 === this._activeSelectionMode && this._selectToWordAt(this._model.selectionEnd), this._dragScrollAmount = this._getMouseEventScrollAmount(e), 3 !== this._activeSelectionMode && (this._dragScrollAmount > 0 ? this._model.selectionEnd[0] = this._bufferService.cols : this._dragScrollAmount < 0 && (this._model.selectionEnd[0] = 0));\n              const i = this._bufferService.buffer;\n              if (this._model.selectionEnd[1] < i.lines.length) {\n                const e = i.lines.get(this._model.selectionEnd[1]);\n                e && 0 === e.hasWidth(this._model.selectionEnd[0]) && this._model.selectionEnd[0]++;\n              }\n              t && t[0] === this._model.selectionEnd[0] && t[1] === this._model.selectionEnd[1] || this.refresh(!0);\n            }\n            _dragScroll() {\n              if (this._model.selectionEnd && this._model.selectionStart && this._dragScrollAmount) {\n                this._onRequestScrollLines.fire({\n                  amount: this._dragScrollAmount,\n                  suppressScrollEvent: !1\n                });\n                const e = this._bufferService.buffer;\n                this._dragScrollAmount > 0 ? (3 !== this._activeSelectionMode && (this._model.selectionEnd[0] = this._bufferService.cols), this._model.selectionEnd[1] = Math.min(e.ydisp + this._bufferService.rows, e.lines.length - 1)) : (3 !== this._activeSelectionMode && (this._model.selectionEnd[0] = 0), this._model.selectionEnd[1] = e.ydisp), this.refresh();\n              }\n            }\n            _onMouseUp(e) {\n              const t = e.timeStamp - this._mouseDownTimeStamp;\n              if (this._removeMouseDownListeners(), this.selectionText.length <= 1 && t < 500 && e.altKey && this._optionsService.rawOptions.altClickMovesCursor) {\n                if (this._bufferService.buffer.ybase === this._bufferService.buffer.ydisp) {\n                  const t = this._mouseService.getCoords(e, this._element, this._bufferService.cols, this._bufferService.rows, !1);\n                  if (t && void 0 !== t[0] && void 0 !== t[1]) {\n                    const e = (0, _.moveToCellSequence)(t[0] - 1, t[1] - 1, this._bufferService, this._coreService.decPrivateModes.applicationCursorKeys);\n                    this._coreService.triggerDataEvent(e, !0);\n                  }\n                }\n              } else this._fireEventIfSelectionChanged();\n            }\n            _fireEventIfSelectionChanged() {\n              const e = this._model.finalSelectionStart,\n                t = this._model.finalSelectionEnd,\n                i = !(!e || !t || e[0] === t[0] && e[1] === t[1]);\n              i ? e && t && (this._oldSelectionStart && this._oldSelectionEnd && e[0] === this._oldSelectionStart[0] && e[1] === this._oldSelectionStart[1] && t[0] === this._oldSelectionEnd[0] && t[1] === this._oldSelectionEnd[1] || this._fireOnSelectionChange(e, t, i)) : this._oldHasSelection && this._fireOnSelectionChange(e, t, i);\n            }\n            _fireOnSelectionChange(e, t, i) {\n              this._oldSelectionStart = e, this._oldSelectionEnd = t, this._oldHasSelection = i, this._onSelectionChange.fire();\n            }\n            _onBufferActivate(e) {\n              this.clearSelection(), this._trimListener.dispose(), this._trimListener = e.activeBuffer.lines.onTrim(e => this._onTrim(e));\n            }\n            _convertViewportColToCharacterIndex(e, t) {\n              let i = t[0];\n              for (let s = 0; t[0] >= s; s++) {\n                const r = e.loadCell(s, this._workCell).getChars().length;\n                0 === this._workCell.getWidth() ? i-- : r > 1 && t[0] !== s && (i += r - 1);\n              }\n              return i;\n            }\n            setSelection(e, t, i) {\n              this._model.clearSelection(), this._removeMouseDownListeners(), this._model.selectionStart = [e, t], this._model.selectionStartLength = i, this.refresh(), this._fireEventIfSelectionChanged();\n            }\n            rightClickSelect(e) {\n              this._isClickInSelection(e) || (this._selectWordAtCursor(e, !1) && this.refresh(!0), this._fireEventIfSelectionChanged());\n            }\n            _getWordAt(e, t, i = !0, s = !0) {\n              if (e[0] >= this._bufferService.cols) return;\n              const r = this._bufferService.buffer,\n                n = r.lines.get(e[1]);\n              if (!n) return;\n              const o = r.translateBufferLineToString(e[1], !1);\n              let a = this._convertViewportColToCharacterIndex(n, e),\n                h = a;\n              const c = e[0] - a;\n              let l = 0,\n                d = 0,\n                _ = 0,\n                u = 0;\n              if (\" \" === o.charAt(a)) {\n                for (; a > 0 && \" \" === o.charAt(a - 1);) a--;\n                for (; h < o.length && \" \" === o.charAt(h + 1);) h++;\n              } else {\n                let t = e[0],\n                  i = e[0];\n                0 === n.getWidth(t) && (l++, t--), 2 === n.getWidth(i) && (d++, i++);\n                const s = n.getString(i).length;\n                for (s > 1 && (u += s - 1, h += s - 1); t > 0 && a > 0 && !this._isCharWordSeparator(n.loadCell(t - 1, this._workCell));) {\n                  n.loadCell(t - 1, this._workCell);\n                  const e = this._workCell.getChars().length;\n                  0 === this._workCell.getWidth() ? (l++, t--) : e > 1 && (_ += e - 1, a -= e - 1), a--, t--;\n                }\n                for (; i < n.length && h + 1 < o.length && !this._isCharWordSeparator(n.loadCell(i + 1, this._workCell));) {\n                  n.loadCell(i + 1, this._workCell);\n                  const e = this._workCell.getChars().length;\n                  2 === this._workCell.getWidth() ? (d++, i++) : e > 1 && (u += e - 1, h += e - 1), h++, i++;\n                }\n              }\n              h++;\n              let f = a + c - l + _,\n                v = Math.min(this._bufferService.cols, h - a + l + d - _ - u);\n              if (t || \"\" !== o.slice(a, h).trim()) {\n                if (i && 0 === f && 32 !== n.getCodePoint(0)) {\n                  const t = r.lines.get(e[1] - 1);\n                  if (t && n.isWrapped && 32 !== t.getCodePoint(this._bufferService.cols - 1)) {\n                    const t = this._getWordAt([this._bufferService.cols - 1, e[1] - 1], !1, !0, !1);\n                    if (t) {\n                      const e = this._bufferService.cols - t.start;\n                      f -= e, v += e;\n                    }\n                  }\n                }\n                if (s && f + v === this._bufferService.cols && 32 !== n.getCodePoint(this._bufferService.cols - 1)) {\n                  const t = r.lines.get(e[1] + 1);\n                  if ((null == t ? void 0 : t.isWrapped) && 32 !== t.getCodePoint(0)) {\n                    const t = this._getWordAt([0, e[1] + 1], !1, !1, !0);\n                    t && (v += t.length);\n                  }\n                }\n                return {\n                  start: f,\n                  length: v\n                };\n              }\n            }\n            _selectWordAt(e, t) {\n              const i = this._getWordAt(e, t);\n              if (i) {\n                for (; i.start < 0;) i.start += this._bufferService.cols, e[1]--;\n                this._model.selectionStart = [i.start, e[1]], this._model.selectionStartLength = i.length;\n              }\n            }\n            _selectToWordAt(e) {\n              const t = this._getWordAt(e, !0);\n              if (t) {\n                let i = e[1];\n                for (; t.start < 0;) t.start += this._bufferService.cols, i--;\n                if (!this._model.areSelectionValuesReversed()) for (; t.start + t.length > this._bufferService.cols;) t.length -= this._bufferService.cols, i++;\n                this._model.selectionEnd = [this._model.areSelectionValuesReversed() ? t.start : t.start + t.length, i];\n              }\n            }\n            _isCharWordSeparator(e) {\n              return 0 !== e.getWidth() && this._optionsService.rawOptions.wordSeparator.indexOf(e.getChars()) >= 0;\n            }\n            _selectLineAt(e) {\n              const t = this._bufferService.buffer.getWrappedRangeForLine(e),\n                i = {\n                  start: {\n                    x: 0,\n                    y: t.first\n                  },\n                  end: {\n                    x: this._bufferService.cols - 1,\n                    y: t.last\n                  }\n                };\n              this._model.selectionStart = [0, t.first], this._model.selectionEnd = void 0, this._model.selectionStartLength = (0, f.getRangeLength)(i, this._bufferService.cols);\n            }\n          };\n          p = s([r(3, l.IBufferService), r(4, l.ICoreService), r(5, c.IMouseService), r(6, l.IOptionsService), r(7, c.IRenderService), r(8, c.ICoreBrowserService)], p), t.SelectionService = p;\n        },\n        4725: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.ICharacterJoinerService = t.ISelectionService = t.IRenderService = t.IMouseService = t.ICoreBrowserService = t.ICharSizeService = void 0;\n          const s = i(8343);\n          t.ICharSizeService = (0, s.createDecorator)(\"CharSizeService\"), t.ICoreBrowserService = (0, s.createDecorator)(\"CoreBrowserService\"), t.IMouseService = (0, s.createDecorator)(\"MouseService\"), t.IRenderService = (0, s.createDecorator)(\"RenderService\"), t.ISelectionService = (0, s.createDecorator)(\"SelectionService\"), t.ICharacterJoinerService = (0, s.createDecorator)(\"CharacterJoinerService\");\n        },\n        6349: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.CircularList = void 0;\n          const s = i(8460);\n          t.CircularList = class {\n            constructor(e) {\n              this._maxLength = e, this.onDeleteEmitter = new s.EventEmitter(), this.onInsertEmitter = new s.EventEmitter(), this.onTrimEmitter = new s.EventEmitter(), this._array = new Array(this._maxLength), this._startIndex = 0, this._length = 0;\n            }\n            get onDelete() {\n              return this.onDeleteEmitter.event;\n            }\n            get onInsert() {\n              return this.onInsertEmitter.event;\n            }\n            get onTrim() {\n              return this.onTrimEmitter.event;\n            }\n            get maxLength() {\n              return this._maxLength;\n            }\n            set maxLength(e) {\n              if (this._maxLength === e) return;\n              const t = new Array(e);\n              for (let i = 0; i < Math.min(e, this.length); i++) t[i] = this._array[this._getCyclicIndex(i)];\n              this._array = t, this._maxLength = e, this._startIndex = 0;\n            }\n            get length() {\n              return this._length;\n            }\n            set length(e) {\n              if (e > this._length) for (let t = this._length; t < e; t++) this._array[t] = void 0;\n              this._length = e;\n            }\n            get(e) {\n              return this._array[this._getCyclicIndex(e)];\n            }\n            set(e, t) {\n              this._array[this._getCyclicIndex(e)] = t;\n            }\n            push(e) {\n              this._array[this._getCyclicIndex(this._length)] = e, this._length === this._maxLength ? (this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1)) : this._length++;\n            }\n            recycle() {\n              if (this._length !== this._maxLength) throw new Error(\"Can only recycle when the buffer is full\");\n              return this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1), this._array[this._getCyclicIndex(this._length - 1)];\n            }\n            get isFull() {\n              return this._length === this._maxLength;\n            }\n            pop() {\n              return this._array[this._getCyclicIndex(this._length-- - 1)];\n            }\n            splice(e, t, ...i) {\n              if (t) {\n                for (let i = e; i < this._length - t; i++) this._array[this._getCyclicIndex(i)] = this._array[this._getCyclicIndex(i + t)];\n                this._length -= t, this.onDeleteEmitter.fire({\n                  index: e,\n                  amount: t\n                });\n              }\n              for (let t = this._length - 1; t >= e; t--) this._array[this._getCyclicIndex(t + i.length)] = this._array[this._getCyclicIndex(t)];\n              for (let t = 0; t < i.length; t++) this._array[this._getCyclicIndex(e + t)] = i[t];\n              if (i.length && this.onInsertEmitter.fire({\n                index: e,\n                amount: i.length\n              }), this._length + i.length > this._maxLength) {\n                const e = this._length + i.length - this._maxLength;\n                this._startIndex += e, this._length = this._maxLength, this.onTrimEmitter.fire(e);\n              } else this._length += i.length;\n            }\n            trimStart(e) {\n              e > this._length && (e = this._length), this._startIndex += e, this._length -= e, this.onTrimEmitter.fire(e);\n            }\n            shiftElements(e, t, i) {\n              if (!(t <= 0)) {\n                if (e < 0 || e >= this._length) throw new Error(\"start argument out of range\");\n                if (e + i < 0) throw new Error(\"Cannot shift elements in list beyond index 0\");\n                if (i > 0) {\n                  for (let s = t - 1; s >= 0; s--) this.set(e + s + i, this.get(e + s));\n                  const s = e + t + i - this._length;\n                  if (s > 0) for (this._length += s; this._length > this._maxLength;) this._length--, this._startIndex++, this.onTrimEmitter.fire(1);\n                } else for (let s = 0; s < t; s++) this.set(e + s + i, this.get(e + s));\n              }\n            }\n            _getCyclicIndex(e) {\n              return (this._startIndex + e) % this._maxLength;\n            }\n          };\n        },\n        1439: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.clone = void 0, t.clone = function e(t, i = 5) {\n            if (\"object\" != typeof t) return t;\n            const s = Array.isArray(t) ? [] : {};\n            for (const r in t) s[r] = i <= 1 ? t[r] : t[r] && e(t[r], i - 1);\n            return s;\n          };\n        },\n        8055: (e, t) => {\n          var i, s, r;\n          function n(e) {\n            const t = e.toString(16);\n            return t.length < 2 ? \"0\" + t : t;\n          }\n          function o(e, t) {\n            return e < t ? (t + .05) / (e + .05) : (e + .05) / (t + .05);\n          }\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.contrastRatio = t.toPaddedHex = t.rgba = t.rgb = t.css = t.color = t.channels = void 0, function (e) {\n            e.toCss = function (e, t, i, s) {\n              return void 0 !== s ? `#${n(e)}${n(t)}${n(i)}${n(s)}` : `#${n(e)}${n(t)}${n(i)}`;\n            }, e.toRgba = function (e, t, i, s = 255) {\n              return (e << 24 | t << 16 | i << 8 | s) >>> 0;\n            };\n          }(i = t.channels || (t.channels = {})), function (e) {\n            function t(e, t) {\n              const s = Math.round(255 * t),\n                [n, o, a] = r.toChannels(e.rgba);\n              return {\n                css: i.toCss(n, o, a, s),\n                rgba: i.toRgba(n, o, a, s)\n              };\n            }\n            e.blend = function (e, t) {\n              const s = (255 & t.rgba) / 255;\n              if (1 === s) return {\n                css: t.css,\n                rgba: t.rgba\n              };\n              const r = t.rgba >> 24 & 255,\n                n = t.rgba >> 16 & 255,\n                o = t.rgba >> 8 & 255,\n                a = e.rgba >> 24 & 255,\n                h = e.rgba >> 16 & 255,\n                c = e.rgba >> 8 & 255,\n                l = a + Math.round((r - a) * s),\n                d = h + Math.round((n - h) * s),\n                _ = c + Math.round((o - c) * s);\n              return {\n                css: i.toCss(l, d, _),\n                rgba: i.toRgba(l, d, _)\n              };\n            }, e.isOpaque = function (e) {\n              return 255 == (255 & e.rgba);\n            }, e.ensureContrastRatio = function (e, t, i) {\n              const s = r.ensureContrastRatio(e.rgba, t.rgba, i);\n              if (s) return r.toColor(s >> 24 & 255, s >> 16 & 255, s >> 8 & 255);\n            }, e.opaque = function (e) {\n              const t = (255 | e.rgba) >>> 0,\n                [s, n, o] = r.toChannels(t);\n              return {\n                css: i.toCss(s, n, o),\n                rgba: t\n              };\n            }, e.opacity = t, e.multiplyOpacity = function (e, i) {\n              return t(e, (255 & e.rgba) * i / 255);\n            }, e.toColorRGB = function (e) {\n              return [e.rgba >> 24 & 255, e.rgba >> 16 & 255, e.rgba >> 8 & 255];\n            };\n          }(t.color || (t.color = {})), (t.css || (t.css = {})).toColor = function (e) {\n            if (e.match(/#[0-9a-f]{3,8}/i)) switch (e.length) {\n              case 4:\n                {\n                  const t = parseInt(e.slice(1, 2).repeat(2), 16),\n                    i = parseInt(e.slice(2, 3).repeat(2), 16),\n                    s = parseInt(e.slice(3, 4).repeat(2), 16);\n                  return r.toColor(t, i, s);\n                }\n              case 5:\n                {\n                  const t = parseInt(e.slice(1, 2).repeat(2), 16),\n                    i = parseInt(e.slice(2, 3).repeat(2), 16),\n                    s = parseInt(e.slice(3, 4).repeat(2), 16),\n                    n = parseInt(e.slice(4, 5).repeat(2), 16);\n                  return r.toColor(t, i, s, n);\n                }\n              case 7:\n                return {\n                  css: e,\n                  rgba: (parseInt(e.slice(1), 16) << 8 | 255) >>> 0\n                };\n              case 9:\n                return {\n                  css: e,\n                  rgba: parseInt(e.slice(1), 16) >>> 0\n                };\n            }\n            const t = e.match(/rgba?\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*(,\\s*(0|1|\\d?\\.(\\d+))\\s*)?\\)/);\n            if (t) {\n              const e = parseInt(t[1]),\n                i = parseInt(t[2]),\n                s = parseInt(t[3]),\n                n = Math.round(255 * (void 0 === t[5] ? 1 : parseFloat(t[5])));\n              return r.toColor(e, i, s, n);\n            }\n            throw new Error(\"css.toColor: Unsupported css format\");\n          }, function (e) {\n            function t(e, t, i) {\n              const s = e / 255,\n                r = t / 255,\n                n = i / 255;\n              return .2126 * (s <= .03928 ? s / 12.92 : Math.pow((s + .055) / 1.055, 2.4)) + .7152 * (r <= .03928 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4)) + .0722 * (n <= .03928 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4));\n            }\n            e.relativeLuminance = function (e) {\n              return t(e >> 16 & 255, e >> 8 & 255, 255 & e);\n            }, e.relativeLuminance2 = t;\n          }(s = t.rgb || (t.rgb = {})), function (e) {\n            function t(e, t, i) {\n              const r = e >> 24 & 255,\n                n = e >> 16 & 255,\n                a = e >> 8 & 255;\n              let h = t >> 24 & 255,\n                c = t >> 16 & 255,\n                l = t >> 8 & 255,\n                d = o(s.relativeLuminance2(h, c, l), s.relativeLuminance2(r, n, a));\n              for (; d < i && (h > 0 || c > 0 || l > 0);) h -= Math.max(0, Math.ceil(.1 * h)), c -= Math.max(0, Math.ceil(.1 * c)), l -= Math.max(0, Math.ceil(.1 * l)), d = o(s.relativeLuminance2(h, c, l), s.relativeLuminance2(r, n, a));\n              return (h << 24 | c << 16 | l << 8 | 255) >>> 0;\n            }\n            function r(e, t, i) {\n              const r = e >> 24 & 255,\n                n = e >> 16 & 255,\n                a = e >> 8 & 255;\n              let h = t >> 24 & 255,\n                c = t >> 16 & 255,\n                l = t >> 8 & 255,\n                d = o(s.relativeLuminance2(h, c, l), s.relativeLuminance2(r, n, a));\n              for (; d < i && (h < 255 || c < 255 || l < 255);) h = Math.min(255, h + Math.ceil(.1 * (255 - h))), c = Math.min(255, c + Math.ceil(.1 * (255 - c))), l = Math.min(255, l + Math.ceil(.1 * (255 - l))), d = o(s.relativeLuminance2(h, c, l), s.relativeLuminance2(r, n, a));\n              return (h << 24 | c << 16 | l << 8 | 255) >>> 0;\n            }\n            e.ensureContrastRatio = function (e, i, n) {\n              const a = s.relativeLuminance(e >> 8),\n                h = s.relativeLuminance(i >> 8);\n              if (o(a, h) < n) {\n                if (h < a) {\n                  const h = t(e, i, n),\n                    c = o(a, s.relativeLuminance(h >> 8));\n                  if (c < n) {\n                    const t = r(e, i, n);\n                    return c > o(a, s.relativeLuminance(t >> 8)) ? h : t;\n                  }\n                  return h;\n                }\n                const c = r(e, i, n),\n                  l = o(a, s.relativeLuminance(c >> 8));\n                if (l < n) {\n                  const r = t(e, i, n);\n                  return l > o(a, s.relativeLuminance(r >> 8)) ? c : r;\n                }\n                return c;\n              }\n            }, e.reduceLuminance = t, e.increaseLuminance = r, e.toChannels = function (e) {\n              return [e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e];\n            }, e.toColor = function (e, t, s, r) {\n              return {\n                css: i.toCss(e, t, s, r),\n                rgba: i.toRgba(e, t, s, r)\n              };\n            };\n          }(r = t.rgba || (t.rgba = {})), t.toPaddedHex = n, t.contrastRatio = o;\n        },\n        8969: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.CoreTerminal = void 0;\n          const s = i(844),\n            r = i(2585),\n            n = i(4348),\n            o = i(7866),\n            a = i(744),\n            h = i(7302),\n            c = i(6975),\n            l = i(8460),\n            d = i(1753),\n            _ = i(3730),\n            u = i(1480),\n            f = i(7994),\n            v = i(9282),\n            g = i(5435),\n            p = i(5981),\n            S = i(2660);\n          let m = !1;\n          class C extends s.Disposable {\n            constructor(e) {\n              super(), this._onBinary = new l.EventEmitter(), this._onData = new l.EventEmitter(), this._onLineFeed = new l.EventEmitter(), this._onResize = new l.EventEmitter(), this._onScroll = new l.EventEmitter(), this._onWriteParsed = new l.EventEmitter(), this._instantiationService = new n.InstantiationService(), this.optionsService = new h.OptionsService(e), this._instantiationService.setService(r.IOptionsService, this.optionsService), this._bufferService = this.register(this._instantiationService.createInstance(a.BufferService)), this._instantiationService.setService(r.IBufferService, this._bufferService), this._logService = this._instantiationService.createInstance(o.LogService), this._instantiationService.setService(r.ILogService, this._logService), this.coreService = this.register(this._instantiationService.createInstance(c.CoreService, () => this.scrollToBottom())), this._instantiationService.setService(r.ICoreService, this.coreService), this.coreMouseService = this._instantiationService.createInstance(d.CoreMouseService), this._instantiationService.setService(r.ICoreMouseService, this.coreMouseService), this._dirtyRowService = this._instantiationService.createInstance(_.DirtyRowService), this._instantiationService.setService(r.IDirtyRowService, this._dirtyRowService), this.unicodeService = this._instantiationService.createInstance(u.UnicodeService), this._instantiationService.setService(r.IUnicodeService, this.unicodeService), this._charsetService = this._instantiationService.createInstance(f.CharsetService), this._instantiationService.setService(r.ICharsetService, this._charsetService), this._oscLinkService = this._instantiationService.createInstance(S.OscLinkService), this._instantiationService.setService(r.IOscLinkService, this._oscLinkService), this._inputHandler = new g.InputHandler(this._bufferService, this._charsetService, this.coreService, this._dirtyRowService, this._logService, this.optionsService, this._oscLinkService, this.coreMouseService, this.unicodeService), this.register((0, l.forwardEvent)(this._inputHandler.onLineFeed, this._onLineFeed)), this.register(this._inputHandler), this.register((0, l.forwardEvent)(this._bufferService.onResize, this._onResize)), this.register((0, l.forwardEvent)(this.coreService.onData, this._onData)), this.register((0, l.forwardEvent)(this.coreService.onBinary, this._onBinary)), this.register(this.optionsService.onOptionChange(e => this._updateOptions(e))), this.register(this._bufferService.onScroll(e => {\n                this._onScroll.fire({\n                  position: this._bufferService.buffer.ydisp,\n                  source: 0\n                }), this._dirtyRowService.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);\n              })), this.register(this._inputHandler.onScroll(e => {\n                this._onScroll.fire({\n                  position: this._bufferService.buffer.ydisp,\n                  source: 0\n                }), this._dirtyRowService.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);\n              })), this._writeBuffer = new p.WriteBuffer((e, t) => this._inputHandler.parse(e, t)), this.register((0, l.forwardEvent)(this._writeBuffer.onWriteParsed, this._onWriteParsed));\n            }\n            get onBinary() {\n              return this._onBinary.event;\n            }\n            get onData() {\n              return this._onData.event;\n            }\n            get onLineFeed() {\n              return this._onLineFeed.event;\n            }\n            get onResize() {\n              return this._onResize.event;\n            }\n            get onWriteParsed() {\n              return this._onWriteParsed.event;\n            }\n            get onScroll() {\n              return this._onScrollApi || (this._onScrollApi = new l.EventEmitter(), this.register(this._onScroll.event(e => {\n                var t;\n                null === (t = this._onScrollApi) || void 0 === t || t.fire(e.position);\n              }))), this._onScrollApi.event;\n            }\n            get cols() {\n              return this._bufferService.cols;\n            }\n            get rows() {\n              return this._bufferService.rows;\n            }\n            get buffers() {\n              return this._bufferService.buffers;\n            }\n            get options() {\n              return this.optionsService.options;\n            }\n            set options(e) {\n              for (const t in e) this.optionsService.options[t] = e[t];\n            }\n            dispose() {\n              var e;\n              this._isDisposed || (super.dispose(), null === (e = this._windowsMode) || void 0 === e || e.dispose(), this._windowsMode = void 0);\n            }\n            write(e, t) {\n              this._writeBuffer.write(e, t);\n            }\n            writeSync(e, t) {\n              this._logService.logLevel <= r.LogLevelEnum.WARN && !m && (this._logService.warn(\"writeSync is unreliable and will be removed soon.\"), m = !0), this._writeBuffer.writeSync(e, t);\n            }\n            resize(e, t) {\n              isNaN(e) || isNaN(t) || (e = Math.max(e, a.MINIMUM_COLS), t = Math.max(t, a.MINIMUM_ROWS), this._bufferService.resize(e, t));\n            }\n            scroll(e, t = !1) {\n              this._bufferService.scroll(e, t);\n            }\n            scrollLines(e, t, i) {\n              this._bufferService.scrollLines(e, t, i);\n            }\n            scrollPages(e) {\n              this._bufferService.scrollPages(e);\n            }\n            scrollToTop() {\n              this._bufferService.scrollToTop();\n            }\n            scrollToBottom() {\n              this._bufferService.scrollToBottom();\n            }\n            scrollToLine(e) {\n              this._bufferService.scrollToLine(e);\n            }\n            registerEscHandler(e, t) {\n              return this._inputHandler.registerEscHandler(e, t);\n            }\n            registerDcsHandler(e, t) {\n              return this._inputHandler.registerDcsHandler(e, t);\n            }\n            registerCsiHandler(e, t) {\n              return this._inputHandler.registerCsiHandler(e, t);\n            }\n            registerOscHandler(e, t) {\n              return this._inputHandler.registerOscHandler(e, t);\n            }\n            _setup() {\n              this.optionsService.rawOptions.windowsMode && this._enableWindowsMode();\n            }\n            reset() {\n              this._inputHandler.reset(), this._bufferService.reset(), this._charsetService.reset(), this.coreService.reset(), this.coreMouseService.reset();\n            }\n            _updateOptions(e) {\n              var t;\n              switch (e) {\n                case \"scrollback\":\n                  this.buffers.resize(this.cols, this.rows);\n                  break;\n                case \"windowsMode\":\n                  this.optionsService.rawOptions.windowsMode ? this._enableWindowsMode() : (null === (t = this._windowsMode) || void 0 === t || t.dispose(), this._windowsMode = void 0);\n              }\n            }\n            _enableWindowsMode() {\n              if (!this._windowsMode) {\n                const e = [];\n                e.push(this.onLineFeed(v.updateWindowsModeWrappedState.bind(null, this._bufferService))), e.push(this.registerCsiHandler({\n                  final: \"H\"\n                }, () => ((0, v.updateWindowsModeWrappedState)(this._bufferService), !1))), this._windowsMode = {\n                  dispose: () => {\n                    for (const t of e) t.dispose();\n                  }\n                };\n              }\n            }\n          }\n          t.CoreTerminal = C;\n        },\n        8460: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.forwardEvent = t.EventEmitter = void 0, t.EventEmitter = class {\n            constructor() {\n              this._listeners = [], this._disposed = !1;\n            }\n            get event() {\n              return this._event || (this._event = e => (this._listeners.push(e), {\n                dispose: () => {\n                  if (!this._disposed) for (let t = 0; t < this._listeners.length; t++) if (this._listeners[t] === e) return void this._listeners.splice(t, 1);\n                }\n              })), this._event;\n            }\n            fire(e, t) {\n              const i = [];\n              for (let e = 0; e < this._listeners.length; e++) i.push(this._listeners[e]);\n              for (let s = 0; s < i.length; s++) i[s].call(void 0, e, t);\n            }\n            dispose() {\n              this._listeners && (this._listeners.length = 0), this._disposed = !0;\n            }\n          }, t.forwardEvent = function (e, t) {\n            return e(e => t.fire(e));\n          };\n        },\n        5435: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.InputHandler = t.WindowsOptionsReportType = void 0;\n          const s = i(2584),\n            r = i(7116),\n            n = i(2015),\n            o = i(844),\n            a = i(482),\n            h = i(8437),\n            c = i(8460),\n            l = i(643),\n            d = i(511),\n            _ = i(3734),\n            u = i(2585),\n            f = i(6242),\n            v = i(6351),\n            g = i(5941),\n            p = {\n              \"(\": 0,\n              \")\": 1,\n              \"*\": 2,\n              \"+\": 3,\n              \"-\": 1,\n              \".\": 2\n            },\n            S = 131072;\n          function m(e, t) {\n            if (e > 24) return t.setWinLines || !1;\n            switch (e) {\n              case 1:\n                return !!t.restoreWin;\n              case 2:\n                return !!t.minimizeWin;\n              case 3:\n                return !!t.setWinPosition;\n              case 4:\n                return !!t.setWinSizePixels;\n              case 5:\n                return !!t.raiseWin;\n              case 6:\n                return !!t.lowerWin;\n              case 7:\n                return !!t.refreshWin;\n              case 8:\n                return !!t.setWinSizeChars;\n              case 9:\n                return !!t.maximizeWin;\n              case 10:\n                return !!t.fullscreenWin;\n              case 11:\n                return !!t.getWinState;\n              case 13:\n                return !!t.getWinPosition;\n              case 14:\n                return !!t.getWinSizePixels;\n              case 15:\n                return !!t.getScreenSizePixels;\n              case 16:\n                return !!t.getCellSizePixels;\n              case 18:\n                return !!t.getWinSizeChars;\n              case 19:\n                return !!t.getScreenSizeChars;\n              case 20:\n                return !!t.getIconTitle;\n              case 21:\n                return !!t.getWinTitle;\n              case 22:\n                return !!t.pushTitle;\n              case 23:\n                return !!t.popTitle;\n              case 24:\n                return !!t.setWinLines;\n            }\n            return !1;\n          }\n          var C;\n          !function (e) {\n            e[e.GET_WIN_SIZE_PIXELS = 0] = \"GET_WIN_SIZE_PIXELS\", e[e.GET_CELL_SIZE_PIXELS = 1] = \"GET_CELL_SIZE_PIXELS\";\n          }(C = t.WindowsOptionsReportType || (t.WindowsOptionsReportType = {}));\n          class b extends o.Disposable {\n            constructor(e, t, i, o, l, _, u, g, p, S = new n.EscapeSequenceParser()) {\n              super(), this._bufferService = e, this._charsetService = t, this._coreService = i, this._dirtyRowService = o, this._logService = l, this._optionsService = _, this._oscLinkService = u, this._coreMouseService = g, this._unicodeService = p, this._parser = S, this._parseBuffer = new Uint32Array(4096), this._stringDecoder = new a.StringToUtf32(), this._utf8Decoder = new a.Utf8ToUtf32(), this._workCell = new d.CellData(), this._windowTitle = \"\", this._iconName = \"\", this._windowTitleStack = [], this._iconNameStack = [], this._curAttrData = h.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = h.DEFAULT_ATTR_DATA.clone(), this._onRequestBell = new c.EventEmitter(), this._onRequestRefreshRows = new c.EventEmitter(), this._onRequestReset = new c.EventEmitter(), this._onRequestSendFocus = new c.EventEmitter(), this._onRequestSyncScrollBar = new c.EventEmitter(), this._onRequestWindowsOptionsReport = new c.EventEmitter(), this._onA11yChar = new c.EventEmitter(), this._onA11yTab = new c.EventEmitter(), this._onCursorMove = new c.EventEmitter(), this._onLineFeed = new c.EventEmitter(), this._onScroll = new c.EventEmitter(), this._onTitleChange = new c.EventEmitter(), this._onColor = new c.EventEmitter(), this._parseStack = {\n                paused: !1,\n                cursorStartX: 0,\n                cursorStartY: 0,\n                decodedLength: 0,\n                position: 0\n              }, this._specialColors = [256, 257, 258], this.register(this._parser), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate(e => this._activeBuffer = e.activeBuffer)), this._parser.setCsiHandlerFallback((e, t) => {\n                this._logService.debug(\"Unknown CSI code: \", {\n                  identifier: this._parser.identToString(e),\n                  params: t.toArray()\n                });\n              }), this._parser.setEscHandlerFallback(e => {\n                this._logService.debug(\"Unknown ESC code: \", {\n                  identifier: this._parser.identToString(e)\n                });\n              }), this._parser.setExecuteHandlerFallback(e => {\n                this._logService.debug(\"Unknown EXECUTE code: \", {\n                  code: e\n                });\n              }), this._parser.setOscHandlerFallback((e, t, i) => {\n                this._logService.debug(\"Unknown OSC code: \", {\n                  identifier: e,\n                  action: t,\n                  data: i\n                });\n              }), this._parser.setDcsHandlerFallback((e, t, i) => {\n                \"HOOK\" === t && (i = i.toArray()), this._logService.debug(\"Unknown DCS code: \", {\n                  identifier: this._parser.identToString(e),\n                  action: t,\n                  payload: i\n                });\n              }), this._parser.setPrintHandler((e, t, i) => this.print(e, t, i)), this._parser.registerCsiHandler({\n                final: \"@\"\n              }, e => this.insertChars(e)), this._parser.registerCsiHandler({\n                intermediates: \" \",\n                final: \"@\"\n              }, e => this.scrollLeft(e)), this._parser.registerCsiHandler({\n                final: \"A\"\n              }, e => this.cursorUp(e)), this._parser.registerCsiHandler({\n                intermediates: \" \",\n                final: \"A\"\n              }, e => this.scrollRight(e)), this._parser.registerCsiHandler({\n                final: \"B\"\n              }, e => this.cursorDown(e)), this._parser.registerCsiHandler({\n                final: \"C\"\n              }, e => this.cursorForward(e)), this._parser.registerCsiHandler({\n                final: \"D\"\n              }, e => this.cursorBackward(e)), this._parser.registerCsiHandler({\n                final: \"E\"\n              }, e => this.cursorNextLine(e)), this._parser.registerCsiHandler({\n                final: \"F\"\n              }, e => this.cursorPrecedingLine(e)), this._parser.registerCsiHandler({\n                final: \"G\"\n              }, e => this.cursorCharAbsolute(e)), this._parser.registerCsiHandler({\n                final: \"H\"\n              }, e => this.cursorPosition(e)), this._parser.registerCsiHandler({\n                final: \"I\"\n              }, e => this.cursorForwardTab(e)), this._parser.registerCsiHandler({\n                final: \"J\"\n              }, e => this.eraseInDisplay(e, !1)), this._parser.registerCsiHandler({\n                prefix: \"?\",\n                final: \"J\"\n              }, e => this.eraseInDisplay(e, !0)), this._parser.registerCsiHandler({\n                final: \"K\"\n              }, e => this.eraseInLine(e, !1)), this._parser.registerCsiHandler({\n                prefix: \"?\",\n                final: \"K\"\n              }, e => this.eraseInLine(e, !0)), this._parser.registerCsiHandler({\n                final: \"L\"\n              }, e => this.insertLines(e)), this._parser.registerCsiHandler({\n                final: \"M\"\n              }, e => this.deleteLines(e)), this._parser.registerCsiHandler({\n                final: \"P\"\n              }, e => this.deleteChars(e)), this._parser.registerCsiHandler({\n                final: \"S\"\n              }, e => this.scrollUp(e)), this._parser.registerCsiHandler({\n                final: \"T\"\n              }, e => this.scrollDown(e)), this._parser.registerCsiHandler({\n                final: \"X\"\n              }, e => this.eraseChars(e)), this._parser.registerCsiHandler({\n                final: \"Z\"\n              }, e => this.cursorBackwardTab(e)), this._parser.registerCsiHandler({\n                final: \"`\"\n              }, e => this.charPosAbsolute(e)), this._parser.registerCsiHandler({\n                final: \"a\"\n              }, e => this.hPositionRelative(e)), this._parser.registerCsiHandler({\n                final: \"b\"\n              }, e => this.repeatPrecedingCharacter(e)), this._parser.registerCsiHandler({\n                final: \"c\"\n              }, e => this.sendDeviceAttributesPrimary(e)), this._parser.registerCsiHandler({\n                prefix: \">\",\n                final: \"c\"\n              }, e => this.sendDeviceAttributesSecondary(e)), this._parser.registerCsiHandler({\n                final: \"d\"\n              }, e => this.linePosAbsolute(e)), this._parser.registerCsiHandler({\n                final: \"e\"\n              }, e => this.vPositionRelative(e)), this._parser.registerCsiHandler({\n                final: \"f\"\n              }, e => this.hVPosition(e)), this._parser.registerCsiHandler({\n                final: \"g\"\n              }, e => this.tabClear(e)), this._parser.registerCsiHandler({\n                final: \"h\"\n              }, e => this.setMode(e)), this._parser.registerCsiHandler({\n                prefix: \"?\",\n                final: \"h\"\n              }, e => this.setModePrivate(e)), this._parser.registerCsiHandler({\n                final: \"l\"\n              }, e => this.resetMode(e)), this._parser.registerCsiHandler({\n                prefix: \"?\",\n                final: \"l\"\n              }, e => this.resetModePrivate(e)), this._parser.registerCsiHandler({\n                final: \"m\"\n              }, e => this.charAttributes(e)), this._parser.registerCsiHandler({\n                final: \"n\"\n              }, e => this.deviceStatus(e)), this._parser.registerCsiHandler({\n                prefix: \"?\",\n                final: \"n\"\n              }, e => this.deviceStatusPrivate(e)), this._parser.registerCsiHandler({\n                intermediates: \"!\",\n                final: \"p\"\n              }, e => this.softReset(e)), this._parser.registerCsiHandler({\n                intermediates: \" \",\n                final: \"q\"\n              }, e => this.setCursorStyle(e)), this._parser.registerCsiHandler({\n                final: \"r\"\n              }, e => this.setScrollRegion(e)), this._parser.registerCsiHandler({\n                final: \"s\"\n              }, e => this.saveCursor(e)), this._parser.registerCsiHandler({\n                final: \"t\"\n              }, e => this.windowOptions(e)), this._parser.registerCsiHandler({\n                final: \"u\"\n              }, e => this.restoreCursor(e)), this._parser.registerCsiHandler({\n                intermediates: \"'\",\n                final: \"}\"\n              }, e => this.insertColumns(e)), this._parser.registerCsiHandler({\n                intermediates: \"'\",\n                final: \"~\"\n              }, e => this.deleteColumns(e)), this._parser.registerCsiHandler({\n                intermediates: '\"',\n                final: \"q\"\n              }, e => this.selectProtected(e)), this._parser.registerCsiHandler({\n                intermediates: \"$\",\n                final: \"p\"\n              }, e => this.requestMode(e, !0)), this._parser.registerCsiHandler({\n                prefix: \"?\",\n                intermediates: \"$\",\n                final: \"p\"\n              }, e => this.requestMode(e, !1)), this._parser.setExecuteHandler(s.C0.BEL, () => this.bell()), this._parser.setExecuteHandler(s.C0.LF, () => this.lineFeed()), this._parser.setExecuteHandler(s.C0.VT, () => this.lineFeed()), this._parser.setExecuteHandler(s.C0.FF, () => this.lineFeed()), this._parser.setExecuteHandler(s.C0.CR, () => this.carriageReturn()), this._parser.setExecuteHandler(s.C0.BS, () => this.backspace()), this._parser.setExecuteHandler(s.C0.HT, () => this.tab()), this._parser.setExecuteHandler(s.C0.SO, () => this.shiftOut()), this._parser.setExecuteHandler(s.C0.SI, () => this.shiftIn()), this._parser.setExecuteHandler(s.C1.IND, () => this.index()), this._parser.setExecuteHandler(s.C1.NEL, () => this.nextLine()), this._parser.setExecuteHandler(s.C1.HTS, () => this.tabSet()), this._parser.registerOscHandler(0, new f.OscHandler(e => (this.setTitle(e), this.setIconName(e), !0))), this._parser.registerOscHandler(1, new f.OscHandler(e => this.setIconName(e))), this._parser.registerOscHandler(2, new f.OscHandler(e => this.setTitle(e))), this._parser.registerOscHandler(4, new f.OscHandler(e => this.setOrReportIndexedColor(e))), this._parser.registerOscHandler(8, new f.OscHandler(e => this.setHyperlink(e))), this._parser.registerOscHandler(10, new f.OscHandler(e => this.setOrReportFgColor(e))), this._parser.registerOscHandler(11, new f.OscHandler(e => this.setOrReportBgColor(e))), this._parser.registerOscHandler(12, new f.OscHandler(e => this.setOrReportCursorColor(e))), this._parser.registerOscHandler(104, new f.OscHandler(e => this.restoreIndexedColor(e))), this._parser.registerOscHandler(110, new f.OscHandler(e => this.restoreFgColor(e))), this._parser.registerOscHandler(111, new f.OscHandler(e => this.restoreBgColor(e))), this._parser.registerOscHandler(112, new f.OscHandler(e => this.restoreCursorColor(e))), this._parser.registerEscHandler({\n                final: \"7\"\n              }, () => this.saveCursor()), this._parser.registerEscHandler({\n                final: \"8\"\n              }, () => this.restoreCursor()), this._parser.registerEscHandler({\n                final: \"D\"\n              }, () => this.index()), this._parser.registerEscHandler({\n                final: \"E\"\n              }, () => this.nextLine()), this._parser.registerEscHandler({\n                final: \"H\"\n              }, () => this.tabSet()), this._parser.registerEscHandler({\n                final: \"M\"\n              }, () => this.reverseIndex()), this._parser.registerEscHandler({\n                final: \"=\"\n              }, () => this.keypadApplicationMode()), this._parser.registerEscHandler({\n                final: \">\"\n              }, () => this.keypadNumericMode()), this._parser.registerEscHandler({\n                final: \"c\"\n              }, () => this.fullReset()), this._parser.registerEscHandler({\n                final: \"n\"\n              }, () => this.setgLevel(2)), this._parser.registerEscHandler({\n                final: \"o\"\n              }, () => this.setgLevel(3)), this._parser.registerEscHandler({\n                final: \"|\"\n              }, () => this.setgLevel(3)), this._parser.registerEscHandler({\n                final: \"}\"\n              }, () => this.setgLevel(2)), this._parser.registerEscHandler({\n                final: \"~\"\n              }, () => this.setgLevel(1)), this._parser.registerEscHandler({\n                intermediates: \"%\",\n                final: \"@\"\n              }, () => this.selectDefaultCharset()), this._parser.registerEscHandler({\n                intermediates: \"%\",\n                final: \"G\"\n              }, () => this.selectDefaultCharset());\n              for (const e in r.CHARSETS) this._parser.registerEscHandler({\n                intermediates: \"(\",\n                final: e\n              }, () => this.selectCharset(\"(\" + e)), this._parser.registerEscHandler({\n                intermediates: \")\",\n                final: e\n              }, () => this.selectCharset(\")\" + e)), this._parser.registerEscHandler({\n                intermediates: \"*\",\n                final: e\n              }, () => this.selectCharset(\"*\" + e)), this._parser.registerEscHandler({\n                intermediates: \"+\",\n                final: e\n              }, () => this.selectCharset(\"+\" + e)), this._parser.registerEscHandler({\n                intermediates: \"-\",\n                final: e\n              }, () => this.selectCharset(\"-\" + e)), this._parser.registerEscHandler({\n                intermediates: \".\",\n                final: e\n              }, () => this.selectCharset(\".\" + e)), this._parser.registerEscHandler({\n                intermediates: \"/\",\n                final: e\n              }, () => this.selectCharset(\"/\" + e));\n              this._parser.registerEscHandler({\n                intermediates: \"#\",\n                final: \"8\"\n              }, () => this.screenAlignmentPattern()), this._parser.setErrorHandler(e => (this._logService.error(\"Parsing error: \", e), e)), this._parser.registerDcsHandler({\n                intermediates: \"$\",\n                final: \"q\"\n              }, new v.DcsHandler((e, t) => this.requestStatusString(e, t)));\n            }\n            getAttrData() {\n              return this._curAttrData;\n            }\n            get onRequestBell() {\n              return this._onRequestBell.event;\n            }\n            get onRequestRefreshRows() {\n              return this._onRequestRefreshRows.event;\n            }\n            get onRequestReset() {\n              return this._onRequestReset.event;\n            }\n            get onRequestSendFocus() {\n              return this._onRequestSendFocus.event;\n            }\n            get onRequestSyncScrollBar() {\n              return this._onRequestSyncScrollBar.event;\n            }\n            get onRequestWindowsOptionsReport() {\n              return this._onRequestWindowsOptionsReport.event;\n            }\n            get onA11yChar() {\n              return this._onA11yChar.event;\n            }\n            get onA11yTab() {\n              return this._onA11yTab.event;\n            }\n            get onCursorMove() {\n              return this._onCursorMove.event;\n            }\n            get onLineFeed() {\n              return this._onLineFeed.event;\n            }\n            get onScroll() {\n              return this._onScroll.event;\n            }\n            get onTitleChange() {\n              return this._onTitleChange.event;\n            }\n            get onColor() {\n              return this._onColor.event;\n            }\n            dispose() {\n              super.dispose();\n            }\n            _preserveStack(e, t, i, s) {\n              this._parseStack.paused = !0, this._parseStack.cursorStartX = e, this._parseStack.cursorStartY = t, this._parseStack.decodedLength = i, this._parseStack.position = s;\n            }\n            _logSlowResolvingAsync(e) {\n              this._logService.logLevel <= u.LogLevelEnum.WARN && Promise.race([e, new Promise((e, t) => setTimeout(() => t(\"#SLOW_TIMEOUT\"), 5e3))]).catch(e => {\n                if (\"#SLOW_TIMEOUT\" !== e) throw e;\n                console.warn(\"async parser handler taking longer than 5000 ms\");\n              });\n            }\n            parse(e, t) {\n              let i,\n                s = this._activeBuffer.x,\n                r = this._activeBuffer.y,\n                n = 0;\n              const o = this._parseStack.paused;\n              if (o) {\n                if (i = this._parser.parse(this._parseBuffer, this._parseStack.decodedLength, t)) return this._logSlowResolvingAsync(i), i;\n                s = this._parseStack.cursorStartX, r = this._parseStack.cursorStartY, this._parseStack.paused = !1, e.length > S && (n = this._parseStack.position + S);\n              }\n              if (this._logService.logLevel <= u.LogLevelEnum.DEBUG && this._logService.debug(\"parsing data\" + (\"string\" == typeof e ? ` \"${e}\"` : ` \"${Array.prototype.map.call(e, e => String.fromCharCode(e)).join(\"\")}\"`), \"string\" == typeof e ? e.split(\"\").map(e => e.charCodeAt(0)) : e), this._parseBuffer.length < e.length && this._parseBuffer.length < S && (this._parseBuffer = new Uint32Array(Math.min(e.length, S))), o || this._dirtyRowService.clearRange(), e.length > S) for (let t = n; t < e.length; t += S) {\n                const n = t + S < e.length ? t + S : e.length,\n                  o = \"string\" == typeof e ? this._stringDecoder.decode(e.substring(t, n), this._parseBuffer) : this._utf8Decoder.decode(e.subarray(t, n), this._parseBuffer);\n                if (i = this._parser.parse(this._parseBuffer, o)) return this._preserveStack(s, r, o, t), this._logSlowResolvingAsync(i), i;\n              } else if (!o) {\n                const t = \"string\" == typeof e ? this._stringDecoder.decode(e, this._parseBuffer) : this._utf8Decoder.decode(e, this._parseBuffer);\n                if (i = this._parser.parse(this._parseBuffer, t)) return this._preserveStack(s, r, t, 0), this._logSlowResolvingAsync(i), i;\n              }\n              this._activeBuffer.x === s && this._activeBuffer.y === r || this._onCursorMove.fire(), this._onRequestRefreshRows.fire(this._dirtyRowService.start, this._dirtyRowService.end);\n            }\n            print(e, t, i) {\n              let s, r;\n              const n = this._charsetService.charset,\n                o = this._optionsService.rawOptions.screenReaderMode,\n                h = this._bufferService.cols,\n                c = this._coreService.decPrivateModes.wraparound,\n                d = this._coreService.modes.insertMode,\n                _ = this._curAttrData;\n              let u = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);\n              this._dirtyRowService.markDirty(this._activeBuffer.y), this._activeBuffer.x && i - t > 0 && 2 === u.getWidth(this._activeBuffer.x - 1) && u.setCellFromCodePoint(this._activeBuffer.x - 1, 0, 1, _.fg, _.bg, _.extended);\n              for (let f = t; f < i; ++f) {\n                if (s = e[f], r = this._unicodeService.wcwidth(s), s < 127 && n) {\n                  const e = n[String.fromCharCode(s)];\n                  e && (s = e.charCodeAt(0));\n                }\n                if (o && this._onA11yChar.fire((0, a.stringFromCodePoint)(s)), void 0 !== this._currentLinkId && this._oscLinkService.addLineToLink(this._currentLinkId, this._activeBuffer.ybase + this._activeBuffer.y), r || !this._activeBuffer.x) {\n                  if (this._activeBuffer.x + r - 1 >= h) if (c) {\n                    for (; this._activeBuffer.x < h;) u.setCellFromCodePoint(this._activeBuffer.x++, 0, 1, _.fg, _.bg, _.extended);\n                    this._activeBuffer.x = 0, this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData(), !0)) : (this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !0), u = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);\n                  } else if (this._activeBuffer.x = h - 1, 2 === r) continue;\n                  if (d && (u.insertCells(this._activeBuffer.x, r, this._activeBuffer.getNullCell(_), _), 2 === u.getWidth(h - 1) && u.setCellFromCodePoint(h - 1, l.NULL_CELL_CODE, l.NULL_CELL_WIDTH, _.fg, _.bg, _.extended)), u.setCellFromCodePoint(this._activeBuffer.x++, s, r, _.fg, _.bg, _.extended), r > 0) for (; --r;) u.setCellFromCodePoint(this._activeBuffer.x++, 0, 0, _.fg, _.bg, _.extended);\n                } else u.getWidth(this._activeBuffer.x - 1) ? u.addCodepointToCell(this._activeBuffer.x - 1, s) : u.addCodepointToCell(this._activeBuffer.x - 2, s);\n              }\n              i - t > 0 && (u.loadCell(this._activeBuffer.x - 1, this._workCell), 2 === this._workCell.getWidth() || this._workCell.getCode() > 65535 ? this._parser.precedingCodepoint = 0 : this._workCell.isCombined() ? this._parser.precedingCodepoint = this._workCell.getChars().charCodeAt(0) : this._parser.precedingCodepoint = this._workCell.content), this._activeBuffer.x < h && i - t > 0 && 0 === u.getWidth(this._activeBuffer.x) && !u.hasContent(this._activeBuffer.x) && u.setCellFromCodePoint(this._activeBuffer.x, 0, 1, _.fg, _.bg, _.extended), this._dirtyRowService.markDirty(this._activeBuffer.y);\n            }\n            registerCsiHandler(e, t) {\n              return \"t\" !== e.final || e.prefix || e.intermediates ? this._parser.registerCsiHandler(e, t) : this._parser.registerCsiHandler(e, e => !m(e.params[0], this._optionsService.rawOptions.windowOptions) || t(e));\n            }\n            registerDcsHandler(e, t) {\n              return this._parser.registerDcsHandler(e, new v.DcsHandler(t));\n            }\n            registerEscHandler(e, t) {\n              return this._parser.registerEscHandler(e, t);\n            }\n            registerOscHandler(e, t) {\n              return this._parser.registerOscHandler(e, new f.OscHandler(t));\n            }\n            bell() {\n              return this._onRequestBell.fire(), !0;\n            }\n            lineFeed() {\n              return this._dirtyRowService.markDirty(this._activeBuffer.y), this._optionsService.rawOptions.convertEol && (this._activeBuffer.x = 0), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._activeBuffer.x >= this._bufferService.cols && this._activeBuffer.x--, this._dirtyRowService.markDirty(this._activeBuffer.y), this._onLineFeed.fire(), !0;\n            }\n            carriageReturn() {\n              return this._activeBuffer.x = 0, !0;\n            }\n            backspace() {\n              var e;\n              if (!this._coreService.decPrivateModes.reverseWraparound) return this._restrictCursor(), this._activeBuffer.x > 0 && this._activeBuffer.x--, !0;\n              if (this._restrictCursor(this._bufferService.cols), this._activeBuffer.x > 0) this._activeBuffer.x--;else if (0 === this._activeBuffer.x && this._activeBuffer.y > this._activeBuffer.scrollTop && this._activeBuffer.y <= this._activeBuffer.scrollBottom && (null === (e = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y)) || void 0 === e ? void 0 : e.isWrapped)) {\n                this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = !1, this._activeBuffer.y--, this._activeBuffer.x = this._bufferService.cols - 1;\n                const e = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);\n                e.hasWidth(this._activeBuffer.x) && !e.hasContent(this._activeBuffer.x) && this._activeBuffer.x--;\n              }\n              return this._restrictCursor(), !0;\n            }\n            tab() {\n              if (this._activeBuffer.x >= this._bufferService.cols) return !0;\n              const e = this._activeBuffer.x;\n              return this._activeBuffer.x = this._activeBuffer.nextStop(), this._optionsService.rawOptions.screenReaderMode && this._onA11yTab.fire(this._activeBuffer.x - e), !0;\n            }\n            shiftOut() {\n              return this._charsetService.setgLevel(1), !0;\n            }\n            shiftIn() {\n              return this._charsetService.setgLevel(0), !0;\n            }\n            _restrictCursor(e = this._bufferService.cols - 1) {\n              this._activeBuffer.x = Math.min(e, Math.max(0, this._activeBuffer.x)), this._activeBuffer.y = this._coreService.decPrivateModes.origin ? Math.min(this._activeBuffer.scrollBottom, Math.max(this._activeBuffer.scrollTop, this._activeBuffer.y)) : Math.min(this._bufferService.rows - 1, Math.max(0, this._activeBuffer.y)), this._dirtyRowService.markDirty(this._activeBuffer.y);\n            }\n            _setCursor(e, t) {\n              this._dirtyRowService.markDirty(this._activeBuffer.y), this._coreService.decPrivateModes.origin ? (this._activeBuffer.x = e, this._activeBuffer.y = this._activeBuffer.scrollTop + t) : (this._activeBuffer.x = e, this._activeBuffer.y = t), this._restrictCursor(), this._dirtyRowService.markDirty(this._activeBuffer.y);\n            }\n            _moveCursor(e, t) {\n              this._restrictCursor(), this._setCursor(this._activeBuffer.x + e, this._activeBuffer.y + t);\n            }\n            cursorUp(e) {\n              const t = this._activeBuffer.y - this._activeBuffer.scrollTop;\n              return t >= 0 ? this._moveCursor(0, -Math.min(t, e.params[0] || 1)) : this._moveCursor(0, -(e.params[0] || 1)), !0;\n            }\n            cursorDown(e) {\n              const t = this._activeBuffer.scrollBottom - this._activeBuffer.y;\n              return t >= 0 ? this._moveCursor(0, Math.min(t, e.params[0] || 1)) : this._moveCursor(0, e.params[0] || 1), !0;\n            }\n            cursorForward(e) {\n              return this._moveCursor(e.params[0] || 1, 0), !0;\n            }\n            cursorBackward(e) {\n              return this._moveCursor(-(e.params[0] || 1), 0), !0;\n            }\n            cursorNextLine(e) {\n              return this.cursorDown(e), this._activeBuffer.x = 0, !0;\n            }\n            cursorPrecedingLine(e) {\n              return this.cursorUp(e), this._activeBuffer.x = 0, !0;\n            }\n            cursorCharAbsolute(e) {\n              return this._setCursor((e.params[0] || 1) - 1, this._activeBuffer.y), !0;\n            }\n            cursorPosition(e) {\n              return this._setCursor(e.length >= 2 ? (e.params[1] || 1) - 1 : 0, (e.params[0] || 1) - 1), !0;\n            }\n            charPosAbsolute(e) {\n              return this._setCursor((e.params[0] || 1) - 1, this._activeBuffer.y), !0;\n            }\n            hPositionRelative(e) {\n              return this._moveCursor(e.params[0] || 1, 0), !0;\n            }\n            linePosAbsolute(e) {\n              return this._setCursor(this._activeBuffer.x, (e.params[0] || 1) - 1), !0;\n            }\n            vPositionRelative(e) {\n              return this._moveCursor(0, e.params[0] || 1), !0;\n            }\n            hVPosition(e) {\n              return this.cursorPosition(e), !0;\n            }\n            tabClear(e) {\n              const t = e.params[0];\n              return 0 === t ? delete this._activeBuffer.tabs[this._activeBuffer.x] : 3 === t && (this._activeBuffer.tabs = {}), !0;\n            }\n            cursorForwardTab(e) {\n              if (this._activeBuffer.x >= this._bufferService.cols) return !0;\n              let t = e.params[0] || 1;\n              for (; t--;) this._activeBuffer.x = this._activeBuffer.nextStop();\n              return !0;\n            }\n            cursorBackwardTab(e) {\n              if (this._activeBuffer.x >= this._bufferService.cols) return !0;\n              let t = e.params[0] || 1;\n              for (; t--;) this._activeBuffer.x = this._activeBuffer.prevStop();\n              return !0;\n            }\n            selectProtected(e) {\n              const t = e.params[0];\n              return 1 === t && (this._curAttrData.bg |= 536870912), 2 !== t && 0 !== t || (this._curAttrData.bg &= -536870913), !0;\n            }\n            _eraseInBufferLine(e, t, i, s = !1, r = !1) {\n              const n = this._activeBuffer.lines.get(this._activeBuffer.ybase + e);\n              n.replaceCells(t, i, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData(), r), s && (n.isWrapped = !1);\n            }\n            _resetBufferLine(e, t = !1) {\n              const i = this._activeBuffer.lines.get(this._activeBuffer.ybase + e);\n              i.fill(this._activeBuffer.getNullCell(this._eraseAttrData()), t), this._bufferService.buffer.clearMarkers(this._activeBuffer.ybase + e), i.isWrapped = !1;\n            }\n            eraseInDisplay(e, t = !1) {\n              let i;\n              switch (this._restrictCursor(this._bufferService.cols), e.params[0]) {\n                case 0:\n                  for (i = this._activeBuffer.y, this._dirtyRowService.markDirty(i), this._eraseInBufferLine(i++, this._activeBuffer.x, this._bufferService.cols, 0 === this._activeBuffer.x, t); i < this._bufferService.rows; i++) this._resetBufferLine(i, t);\n                  this._dirtyRowService.markDirty(i);\n                  break;\n                case 1:\n                  for (i = this._activeBuffer.y, this._dirtyRowService.markDirty(i), this._eraseInBufferLine(i, 0, this._activeBuffer.x + 1, !0, t), this._activeBuffer.x + 1 >= this._bufferService.cols && (this._activeBuffer.lines.get(i + 1).isWrapped = !1); i--;) this._resetBufferLine(i, t);\n                  this._dirtyRowService.markDirty(0);\n                  break;\n                case 2:\n                  for (i = this._bufferService.rows, this._dirtyRowService.markDirty(i - 1); i--;) this._resetBufferLine(i, t);\n                  this._dirtyRowService.markDirty(0);\n                  break;\n                case 3:\n                  const e = this._activeBuffer.lines.length - this._bufferService.rows;\n                  e > 0 && (this._activeBuffer.lines.trimStart(e), this._activeBuffer.ybase = Math.max(this._activeBuffer.ybase - e, 0), this._activeBuffer.ydisp = Math.max(this._activeBuffer.ydisp - e, 0), this._onScroll.fire(0));\n              }\n              return !0;\n            }\n            eraseInLine(e, t = !1) {\n              switch (this._restrictCursor(this._bufferService.cols), e.params[0]) {\n                case 0:\n                  this._eraseInBufferLine(this._activeBuffer.y, this._activeBuffer.x, this._bufferService.cols, 0 === this._activeBuffer.x, t);\n                  break;\n                case 1:\n                  this._eraseInBufferLine(this._activeBuffer.y, 0, this._activeBuffer.x + 1, !1, t);\n                  break;\n                case 2:\n                  this._eraseInBufferLine(this._activeBuffer.y, 0, this._bufferService.cols, !0, t);\n              }\n              return this._dirtyRowService.markDirty(this._activeBuffer.y), !0;\n            }\n            insertLines(e) {\n              this._restrictCursor();\n              let t = e.params[0] || 1;\n              if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;\n              const i = this._activeBuffer.ybase + this._activeBuffer.y,\n                s = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom,\n                r = this._bufferService.rows - 1 + this._activeBuffer.ybase - s + 1;\n              for (; t--;) this._activeBuffer.lines.splice(r - 1, 1), this._activeBuffer.lines.splice(i, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));\n              return this._dirtyRowService.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, !0;\n            }\n            deleteLines(e) {\n              this._restrictCursor();\n              let t = e.params[0] || 1;\n              if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;\n              const i = this._activeBuffer.ybase + this._activeBuffer.y;\n              let s;\n              for (s = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, s = this._bufferService.rows - 1 + this._activeBuffer.ybase - s; t--;) this._activeBuffer.lines.splice(i, 1), this._activeBuffer.lines.splice(s, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));\n              return this._dirtyRowService.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, !0;\n            }\n            insertChars(e) {\n              this._restrictCursor();\n              const t = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);\n              return t && (t.insertCells(this._activeBuffer.x, e.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowService.markDirty(this._activeBuffer.y)), !0;\n            }\n            deleteChars(e) {\n              this._restrictCursor();\n              const t = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);\n              return t && (t.deleteCells(this._activeBuffer.x, e.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowService.markDirty(this._activeBuffer.y)), !0;\n            }\n            scrollUp(e) {\n              let t = e.params[0] || 1;\n              for (; t--;) this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));\n              return this._dirtyRowService.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;\n            }\n            scrollDown(e) {\n              let t = e.params[0] || 1;\n              for (; t--;) this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 0, this._activeBuffer.getBlankLine(h.DEFAULT_ATTR_DATA));\n              return this._dirtyRowService.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;\n            }\n            scrollLeft(e) {\n              if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;\n              const t = e.params[0] || 1;\n              for (let e = this._activeBuffer.scrollTop; e <= this._activeBuffer.scrollBottom; ++e) {\n                const i = this._activeBuffer.lines.get(this._activeBuffer.ybase + e);\n                i.deleteCells(0, t, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), i.isWrapped = !1;\n              }\n              return this._dirtyRowService.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;\n            }\n            scrollRight(e) {\n              if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;\n              const t = e.params[0] || 1;\n              for (let e = this._activeBuffer.scrollTop; e <= this._activeBuffer.scrollBottom; ++e) {\n                const i = this._activeBuffer.lines.get(this._activeBuffer.ybase + e);\n                i.insertCells(0, t, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), i.isWrapped = !1;\n              }\n              return this._dirtyRowService.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;\n            }\n            insertColumns(e) {\n              if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;\n              const t = e.params[0] || 1;\n              for (let e = this._activeBuffer.scrollTop; e <= this._activeBuffer.scrollBottom; ++e) {\n                const i = this._activeBuffer.lines.get(this._activeBuffer.ybase + e);\n                i.insertCells(this._activeBuffer.x, t, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), i.isWrapped = !1;\n              }\n              return this._dirtyRowService.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;\n            }\n            deleteColumns(e) {\n              if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return !0;\n              const t = e.params[0] || 1;\n              for (let e = this._activeBuffer.scrollTop; e <= this._activeBuffer.scrollBottom; ++e) {\n                const i = this._activeBuffer.lines.get(this._activeBuffer.ybase + e);\n                i.deleteCells(this._activeBuffer.x, t, this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), i.isWrapped = !1;\n              }\n              return this._dirtyRowService.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), !0;\n            }\n            eraseChars(e) {\n              this._restrictCursor();\n              const t = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);\n              return t && (t.replaceCells(this._activeBuffer.x, this._activeBuffer.x + (e.params[0] || 1), this._activeBuffer.getNullCell(this._eraseAttrData()), this._eraseAttrData()), this._dirtyRowService.markDirty(this._activeBuffer.y)), !0;\n            }\n            repeatPrecedingCharacter(e) {\n              if (!this._parser.precedingCodepoint) return !0;\n              const t = e.params[0] || 1,\n                i = new Uint32Array(t);\n              for (let e = 0; e < t; ++e) i[e] = this._parser.precedingCodepoint;\n              return this.print(i, 0, i.length), !0;\n            }\n            sendDeviceAttributesPrimary(e) {\n              return e.params[0] > 0 || (this._is(\"xterm\") || this._is(\"rxvt-unicode\") || this._is(\"screen\") ? this._coreService.triggerDataEvent(s.C0.ESC + \"[?1;2c\") : this._is(\"linux\") && this._coreService.triggerDataEvent(s.C0.ESC + \"[?6c\")), !0;\n            }\n            sendDeviceAttributesSecondary(e) {\n              return e.params[0] > 0 || (this._is(\"xterm\") ? this._coreService.triggerDataEvent(s.C0.ESC + \"[>0;276;0c\") : this._is(\"rxvt-unicode\") ? this._coreService.triggerDataEvent(s.C0.ESC + \"[>85;95;0c\") : this._is(\"linux\") ? this._coreService.triggerDataEvent(e.params[0] + \"c\") : this._is(\"screen\") && this._coreService.triggerDataEvent(s.C0.ESC + \"[>83;40003;0c\")), !0;\n            }\n            _is(e) {\n              return 0 === (this._optionsService.rawOptions.termName + \"\").indexOf(e);\n            }\n            setMode(e) {\n              for (let t = 0; t < e.length; t++) switch (e.params[t]) {\n                case 4:\n                  this._coreService.modes.insertMode = !0;\n                  break;\n                case 20:\n                  this._optionsService.options.convertEol = !0;\n              }\n              return !0;\n            }\n            setModePrivate(e) {\n              for (let t = 0; t < e.length; t++) switch (e.params[t]) {\n                case 1:\n                  this._coreService.decPrivateModes.applicationCursorKeys = !0;\n                  break;\n                case 2:\n                  this._charsetService.setgCharset(0, r.DEFAULT_CHARSET), this._charsetService.setgCharset(1, r.DEFAULT_CHARSET), this._charsetService.setgCharset(2, r.DEFAULT_CHARSET), this._charsetService.setgCharset(3, r.DEFAULT_CHARSET);\n                  break;\n                case 3:\n                  this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(132, this._bufferService.rows), this._onRequestReset.fire());\n                  break;\n                case 6:\n                  this._coreService.decPrivateModes.origin = !0, this._setCursor(0, 0);\n                  break;\n                case 7:\n                  this._coreService.decPrivateModes.wraparound = !0;\n                  break;\n                case 12:\n                  this._optionsService.options.cursorBlink = !0;\n                  break;\n                case 45:\n                  this._coreService.decPrivateModes.reverseWraparound = !0;\n                  break;\n                case 66:\n                  this._logService.debug(\"Serial port requested application keypad.\"), this._coreService.decPrivateModes.applicationKeypad = !0, this._onRequestSyncScrollBar.fire();\n                  break;\n                case 9:\n                  this._coreMouseService.activeProtocol = \"X10\";\n                  break;\n                case 1e3:\n                  this._coreMouseService.activeProtocol = \"VT200\";\n                  break;\n                case 1002:\n                  this._coreMouseService.activeProtocol = \"DRAG\";\n                  break;\n                case 1003:\n                  this._coreMouseService.activeProtocol = \"ANY\";\n                  break;\n                case 1004:\n                  this._coreService.decPrivateModes.sendFocus = !0, this._onRequestSendFocus.fire();\n                  break;\n                case 1005:\n                  this._logService.debug(\"DECSET 1005 not supported (see #2507)\");\n                  break;\n                case 1006:\n                  this._coreMouseService.activeEncoding = \"SGR\";\n                  break;\n                case 1015:\n                  this._logService.debug(\"DECSET 1015 not supported (see #2507)\");\n                  break;\n                case 1016:\n                  this._coreMouseService.activeEncoding = \"SGR_PIXELS\";\n                  break;\n                case 25:\n                  this._coreService.isCursorHidden = !1;\n                  break;\n                case 1048:\n                  this.saveCursor();\n                  break;\n                case 1049:\n                  this.saveCursor();\n                case 47:\n                case 1047:\n                  this._bufferService.buffers.activateAltBuffer(this._eraseAttrData()), this._coreService.isCursorInitialized = !0, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();\n                  break;\n                case 2004:\n                  this._coreService.decPrivateModes.bracketedPasteMode = !0;\n              }\n              return !0;\n            }\n            resetMode(e) {\n              for (let t = 0; t < e.length; t++) switch (e.params[t]) {\n                case 4:\n                  this._coreService.modes.insertMode = !1;\n                  break;\n                case 20:\n                  this._optionsService.options.convertEol = !1;\n              }\n              return !0;\n            }\n            resetModePrivate(e) {\n              for (let t = 0; t < e.length; t++) switch (e.params[t]) {\n                case 1:\n                  this._coreService.decPrivateModes.applicationCursorKeys = !1;\n                  break;\n                case 3:\n                  this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(80, this._bufferService.rows), this._onRequestReset.fire());\n                  break;\n                case 6:\n                  this._coreService.decPrivateModes.origin = !1, this._setCursor(0, 0);\n                  break;\n                case 7:\n                  this._coreService.decPrivateModes.wraparound = !1;\n                  break;\n                case 12:\n                  this._optionsService.options.cursorBlink = !1;\n                  break;\n                case 45:\n                  this._coreService.decPrivateModes.reverseWraparound = !1;\n                  break;\n                case 66:\n                  this._logService.debug(\"Switching back to normal keypad.\"), this._coreService.decPrivateModes.applicationKeypad = !1, this._onRequestSyncScrollBar.fire();\n                  break;\n                case 9:\n                case 1e3:\n                case 1002:\n                case 1003:\n                  this._coreMouseService.activeProtocol = \"NONE\";\n                  break;\n                case 1004:\n                  this._coreService.decPrivateModes.sendFocus = !1;\n                  break;\n                case 1005:\n                  this._logService.debug(\"DECRST 1005 not supported (see #2507)\");\n                  break;\n                case 1006:\n                case 1016:\n                  this._coreMouseService.activeEncoding = \"DEFAULT\";\n                  break;\n                case 1015:\n                  this._logService.debug(\"DECRST 1015 not supported (see #2507)\");\n                  break;\n                case 25:\n                  this._coreService.isCursorHidden = !0;\n                  break;\n                case 1048:\n                  this.restoreCursor();\n                  break;\n                case 1049:\n                case 47:\n                case 1047:\n                  this._bufferService.buffers.activateNormalBuffer(), 1049 === e.params[t] && this.restoreCursor(), this._coreService.isCursorInitialized = !0, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();\n                  break;\n                case 2004:\n                  this._coreService.decPrivateModes.bracketedPasteMode = !1;\n              }\n              return !0;\n            }\n            requestMode(e, t) {\n              const i = this._coreService.decPrivateModes,\n                {\n                  activeProtocol: r,\n                  activeEncoding: n\n                } = this._coreMouseService,\n                o = this._coreService,\n                {\n                  buffers: a,\n                  cols: h\n                } = this._bufferService,\n                {\n                  active: c,\n                  alt: l\n                } = a,\n                d = this._optionsService.rawOptions,\n                _ = e => e ? 1 : 2,\n                u = e.params[0];\n              return f = u, v = t ? 2 === u ? 3 : 4 === u ? _(o.modes.insertMode) : 12 === u ? 4 : 20 === u ? _(d.convertEol) : 0 : 1 === u ? _(i.applicationCursorKeys) : 3 === u ? d.windowOptions.setWinLines ? 80 === h ? 2 : 132 === h ? 1 : 0 : 0 : 6 === u ? _(i.origin) : 7 === u ? _(i.wraparound) : 8 === u ? 3 : 9 === u ? _(\"X10\" === r) : 12 === u ? _(d.cursorBlink) : 25 === u ? _(!o.isCursorHidden) : 45 === u ? _(i.reverseWraparound) : 66 === u ? _(i.applicationKeypad) : 1e3 === u ? _(\"VT200\" === r) : 1002 === u ? _(\"DRAG\" === r) : 1003 === u ? _(\"ANY\" === r) : 1004 === u ? _(i.sendFocus) : 1005 === u ? 4 : 1006 === u ? _(\"SGR\" === n) : 1015 === u ? 4 : 1016 === u ? _(\"SGR_PIXELS\" === n) : 1048 === u ? 1 : 47 === u || 1047 === u || 1049 === u ? _(c === l) : 2004 === u ? _(i.bracketedPasteMode) : 0, o.triggerDataEvent(`${s.C0.ESC}[${t ? \"\" : \"?\"}${f};${v}$y`), !0;\n              var f, v;\n            }\n            _updateAttrColor(e, t, i, s, r) {\n              return 2 === t ? (e |= 50331648, e &= -16777216, e |= _.AttributeData.fromColorRGB([i, s, r])) : 5 === t && (e &= -50331904, e |= 33554432 | 255 & i), e;\n            }\n            _extractColor(e, t, i) {\n              const s = [0, 0, -1, 0, 0, 0];\n              let r = 0,\n                n = 0;\n              do {\n                if (s[n + r] = e.params[t + n], e.hasSubParams(t + n)) {\n                  const i = e.getSubParams(t + n);\n                  let o = 0;\n                  do {\n                    5 === s[1] && (r = 1), s[n + o + 1 + r] = i[o];\n                  } while (++o < i.length && o + n + 1 + r < s.length);\n                  break;\n                }\n                if (5 === s[1] && n + r >= 2 || 2 === s[1] && n + r >= 5) break;\n                s[1] && (r = 1);\n              } while (++n + t < e.length && n + r < s.length);\n              for (let e = 2; e < s.length; ++e) -1 === s[e] && (s[e] = 0);\n              switch (s[0]) {\n                case 38:\n                  i.fg = this._updateAttrColor(i.fg, s[1], s[3], s[4], s[5]);\n                  break;\n                case 48:\n                  i.bg = this._updateAttrColor(i.bg, s[1], s[3], s[4], s[5]);\n                  break;\n                case 58:\n                  i.extended = i.extended.clone(), i.extended.underlineColor = this._updateAttrColor(i.extended.underlineColor, s[1], s[3], s[4], s[5]);\n              }\n              return n;\n            }\n            _processUnderline(e, t) {\n              t.extended = t.extended.clone(), (!~e || e > 5) && (e = 1), t.extended.underlineStyle = e, t.fg |= 268435456, 0 === e && (t.fg &= -268435457), t.updateExtended();\n            }\n            charAttributes(e) {\n              if (1 === e.length && 0 === e.params[0]) return this._curAttrData.fg = h.DEFAULT_ATTR_DATA.fg, this._curAttrData.bg = h.DEFAULT_ATTR_DATA.bg, !0;\n              const t = e.length;\n              let i;\n              const s = this._curAttrData;\n              for (let r = 0; r < t; r++) i = e.params[r], i >= 30 && i <= 37 ? (s.fg &= -50331904, s.fg |= 16777216 | i - 30) : i >= 40 && i <= 47 ? (s.bg &= -50331904, s.bg |= 16777216 | i - 40) : i >= 90 && i <= 97 ? (s.fg &= -50331904, s.fg |= 16777224 | i - 90) : i >= 100 && i <= 107 ? (s.bg &= -50331904, s.bg |= 16777224 | i - 100) : 0 === i ? (s.fg = h.DEFAULT_ATTR_DATA.fg, s.bg = h.DEFAULT_ATTR_DATA.bg) : 1 === i ? s.fg |= 134217728 : 3 === i ? s.bg |= 67108864 : 4 === i ? (s.fg |= 268435456, this._processUnderline(e.hasSubParams(r) ? e.getSubParams(r)[0] : 1, s)) : 5 === i ? s.fg |= 536870912 : 7 === i ? s.fg |= 67108864 : 8 === i ? s.fg |= 1073741824 : 9 === i ? s.fg |= 2147483648 : 2 === i ? s.bg |= 134217728 : 21 === i ? this._processUnderline(2, s) : 22 === i ? (s.fg &= -134217729, s.bg &= -134217729) : 23 === i ? s.bg &= -67108865 : 24 === i ? (s.fg &= -268435457, this._processUnderline(0, s)) : 25 === i ? s.fg &= -536870913 : 27 === i ? s.fg &= -67108865 : 28 === i ? s.fg &= -1073741825 : 29 === i ? s.fg &= 2147483647 : 39 === i ? (s.fg &= -67108864, s.fg |= 16777215 & h.DEFAULT_ATTR_DATA.fg) : 49 === i ? (s.bg &= -67108864, s.bg |= 16777215 & h.DEFAULT_ATTR_DATA.bg) : 38 === i || 48 === i || 58 === i ? r += this._extractColor(e, r, s) : 59 === i ? (s.extended = s.extended.clone(), s.extended.underlineColor = -1, s.updateExtended()) : 100 === i ? (s.fg &= -67108864, s.fg |= 16777215 & h.DEFAULT_ATTR_DATA.fg, s.bg &= -67108864, s.bg |= 16777215 & h.DEFAULT_ATTR_DATA.bg) : this._logService.debug(\"Unknown SGR attribute: %d.\", i);\n              return !0;\n            }\n            deviceStatus(e) {\n              switch (e.params[0]) {\n                case 5:\n                  this._coreService.triggerDataEvent(`${s.C0.ESC}[0n`);\n                  break;\n                case 6:\n                  const e = this._activeBuffer.y + 1,\n                    t = this._activeBuffer.x + 1;\n                  this._coreService.triggerDataEvent(`${s.C0.ESC}[${e};${t}R`);\n              }\n              return !0;\n            }\n            deviceStatusPrivate(e) {\n              if (6 === e.params[0]) {\n                const e = this._activeBuffer.y + 1,\n                  t = this._activeBuffer.x + 1;\n                this._coreService.triggerDataEvent(`${s.C0.ESC}[?${e};${t}R`);\n              }\n              return !0;\n            }\n            softReset(e) {\n              return this._coreService.isCursorHidden = !1, this._onRequestSyncScrollBar.fire(), this._activeBuffer.scrollTop = 0, this._activeBuffer.scrollBottom = this._bufferService.rows - 1, this._curAttrData = h.DEFAULT_ATTR_DATA.clone(), this._coreService.reset(), this._charsetService.reset(), this._activeBuffer.savedX = 0, this._activeBuffer.savedY = this._activeBuffer.ybase, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, this._coreService.decPrivateModes.origin = !1, !0;\n            }\n            setCursorStyle(e) {\n              const t = e.params[0] || 1;\n              switch (t) {\n                case 1:\n                case 2:\n                  this._optionsService.options.cursorStyle = \"block\";\n                  break;\n                case 3:\n                case 4:\n                  this._optionsService.options.cursorStyle = \"underline\";\n                  break;\n                case 5:\n                case 6:\n                  this._optionsService.options.cursorStyle = \"bar\";\n              }\n              const i = t % 2 == 1;\n              return this._optionsService.options.cursorBlink = i, !0;\n            }\n            setScrollRegion(e) {\n              const t = e.params[0] || 1;\n              let i;\n              return (e.length < 2 || (i = e.params[1]) > this._bufferService.rows || 0 === i) && (i = this._bufferService.rows), i > t && (this._activeBuffer.scrollTop = t - 1, this._activeBuffer.scrollBottom = i - 1, this._setCursor(0, 0)), !0;\n            }\n            windowOptions(e) {\n              if (!m(e.params[0], this._optionsService.rawOptions.windowOptions)) return !0;\n              const t = e.length > 1 ? e.params[1] : 0;\n              switch (e.params[0]) {\n                case 14:\n                  2 !== t && this._onRequestWindowsOptionsReport.fire(C.GET_WIN_SIZE_PIXELS);\n                  break;\n                case 16:\n                  this._onRequestWindowsOptionsReport.fire(C.GET_CELL_SIZE_PIXELS);\n                  break;\n                case 18:\n                  this._bufferService && this._coreService.triggerDataEvent(`${s.C0.ESC}[8;${this._bufferService.rows};${this._bufferService.cols}t`);\n                  break;\n                case 22:\n                  0 !== t && 2 !== t || (this._windowTitleStack.push(this._windowTitle), this._windowTitleStack.length > 10 && this._windowTitleStack.shift()), 0 !== t && 1 !== t || (this._iconNameStack.push(this._iconName), this._iconNameStack.length > 10 && this._iconNameStack.shift());\n                  break;\n                case 23:\n                  0 !== t && 2 !== t || this._windowTitleStack.length && this.setTitle(this._windowTitleStack.pop()), 0 !== t && 1 !== t || this._iconNameStack.length && this.setIconName(this._iconNameStack.pop());\n              }\n              return !0;\n            }\n            saveCursor(e) {\n              return this._activeBuffer.savedX = this._activeBuffer.x, this._activeBuffer.savedY = this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, !0;\n            }\n            restoreCursor(e) {\n              return this._activeBuffer.x = this._activeBuffer.savedX || 0, this._activeBuffer.y = Math.max(this._activeBuffer.savedY - this._activeBuffer.ybase, 0), this._curAttrData.fg = this._activeBuffer.savedCurAttrData.fg, this._curAttrData.bg = this._activeBuffer.savedCurAttrData.bg, this._charsetService.charset = this._savedCharset, this._activeBuffer.savedCharset && (this._charsetService.charset = this._activeBuffer.savedCharset), this._restrictCursor(), !0;\n            }\n            setTitle(e) {\n              return this._windowTitle = e, this._onTitleChange.fire(e), !0;\n            }\n            setIconName(e) {\n              return this._iconName = e, !0;\n            }\n            setOrReportIndexedColor(e) {\n              const t = [],\n                i = e.split(\";\");\n              for (; i.length > 1;) {\n                const e = i.shift(),\n                  s = i.shift();\n                if (/^\\d+$/.exec(e)) {\n                  const i = parseInt(e);\n                  if (0 <= i && i < 256) if (\"?\" === s) t.push({\n                    type: 0,\n                    index: i\n                  });else {\n                    const e = (0, g.parseColor)(s);\n                    e && t.push({\n                      type: 1,\n                      index: i,\n                      color: e\n                    });\n                  }\n                }\n              }\n              return t.length && this._onColor.fire(t), !0;\n            }\n            setHyperlink(e) {\n              const t = e.split(\";\");\n              return !(t.length < 2) && (t[1] ? this._createHyperlink(t[0], t[1]) : !t[0] && this._finishHyperlink());\n            }\n            _createHyperlink(e, t) {\n              void 0 !== this._currentLinkId && this._finishHyperlink();\n              const i = e.split(\":\");\n              let s;\n              const r = i.findIndex(e => e.startsWith(\"id=\"));\n              return -1 !== r && (s = i[r].slice(3) || void 0), this._curAttrData.extended = this._curAttrData.extended.clone(), this._currentLinkId = this._oscLinkService.registerLink({\n                id: s,\n                uri: t\n              }), this._curAttrData.extended.urlId = this._currentLinkId, this._curAttrData.updateExtended(), !0;\n            }\n            _finishHyperlink() {\n              return this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = 0, this._curAttrData.updateExtended(), this._currentLinkId = void 0, !0;\n            }\n            _setOrReportSpecialColor(e, t) {\n              const i = e.split(\";\");\n              for (let e = 0; e < i.length && !(t >= this._specialColors.length); ++e, ++t) if (\"?\" === i[e]) this._onColor.fire([{\n                type: 0,\n                index: this._specialColors[t]\n              }]);else {\n                const s = (0, g.parseColor)(i[e]);\n                s && this._onColor.fire([{\n                  type: 1,\n                  index: this._specialColors[t],\n                  color: s\n                }]);\n              }\n              return !0;\n            }\n            setOrReportFgColor(e) {\n              return this._setOrReportSpecialColor(e, 0);\n            }\n            setOrReportBgColor(e) {\n              return this._setOrReportSpecialColor(e, 1);\n            }\n            setOrReportCursorColor(e) {\n              return this._setOrReportSpecialColor(e, 2);\n            }\n            restoreIndexedColor(e) {\n              if (!e) return this._onColor.fire([{\n                type: 2\n              }]), !0;\n              const t = [],\n                i = e.split(\";\");\n              for (let e = 0; e < i.length; ++e) if (/^\\d+$/.exec(i[e])) {\n                const s = parseInt(i[e]);\n                0 <= s && s < 256 && t.push({\n                  type: 2,\n                  index: s\n                });\n              }\n              return t.length && this._onColor.fire(t), !0;\n            }\n            restoreFgColor(e) {\n              return this._onColor.fire([{\n                type: 2,\n                index: 256\n              }]), !0;\n            }\n            restoreBgColor(e) {\n              return this._onColor.fire([{\n                type: 2,\n                index: 257\n              }]), !0;\n            }\n            restoreCursorColor(e) {\n              return this._onColor.fire([{\n                type: 2,\n                index: 258\n              }]), !0;\n            }\n            nextLine() {\n              return this._activeBuffer.x = 0, this.index(), !0;\n            }\n            keypadApplicationMode() {\n              return this._logService.debug(\"Serial port requested application keypad.\"), this._coreService.decPrivateModes.applicationKeypad = !0, this._onRequestSyncScrollBar.fire(), !0;\n            }\n            keypadNumericMode() {\n              return this._logService.debug(\"Switching back to normal keypad.\"), this._coreService.decPrivateModes.applicationKeypad = !1, this._onRequestSyncScrollBar.fire(), !0;\n            }\n            selectDefaultCharset() {\n              return this._charsetService.setgLevel(0), this._charsetService.setgCharset(0, r.DEFAULT_CHARSET), !0;\n            }\n            selectCharset(e) {\n              return 2 !== e.length ? (this.selectDefaultCharset(), !0) : (\"/\" === e[0] || this._charsetService.setgCharset(p[e[0]], r.CHARSETS[e[1]] || r.DEFAULT_CHARSET), !0);\n            }\n            index() {\n              return this._restrictCursor(), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._restrictCursor(), !0;\n            }\n            tabSet() {\n              return this._activeBuffer.tabs[this._activeBuffer.x] = !0, !0;\n            }\n            reverseIndex() {\n              if (this._restrictCursor(), this._activeBuffer.y === this._activeBuffer.scrollTop) {\n                const e = this._activeBuffer.scrollBottom - this._activeBuffer.scrollTop;\n                this._activeBuffer.lines.shiftElements(this._activeBuffer.ybase + this._activeBuffer.y, e, 1), this._activeBuffer.lines.set(this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.getBlankLine(this._eraseAttrData())), this._dirtyRowService.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom);\n              } else this._activeBuffer.y--, this._restrictCursor();\n              return !0;\n            }\n            fullReset() {\n              return this._parser.reset(), this._onRequestReset.fire(), !0;\n            }\n            reset() {\n              this._curAttrData = h.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = h.DEFAULT_ATTR_DATA.clone();\n            }\n            _eraseAttrData() {\n              return this._eraseAttrDataInternal.bg &= -67108864, this._eraseAttrDataInternal.bg |= 67108863 & this._curAttrData.bg, this._eraseAttrDataInternal;\n            }\n            setgLevel(e) {\n              return this._charsetService.setgLevel(e), !0;\n            }\n            screenAlignmentPattern() {\n              const e = new d.CellData();\n              e.content = 1 << 22 | \"E\".charCodeAt(0), e.fg = this._curAttrData.fg, e.bg = this._curAttrData.bg, this._setCursor(0, 0);\n              for (let t = 0; t < this._bufferService.rows; ++t) {\n                const i = this._activeBuffer.ybase + this._activeBuffer.y + t,\n                  s = this._activeBuffer.lines.get(i);\n                s && (s.fill(e), s.isWrapped = !1);\n              }\n              return this._dirtyRowService.markAllDirty(), this._setCursor(0, 0), !0;\n            }\n            requestStatusString(e, t) {\n              const i = this._bufferService.buffer,\n                r = this._optionsService.rawOptions;\n              return (e => (this._coreService.triggerDataEvent(`${s.C0.ESC}${e}${s.C0.ESC}\\\\`), !0))('\"q' === e ? `P1$r${this._curAttrData.isProtected() ? 1 : 0}\"q` : '\"p' === e ? 'P1$r61;1\"p' : \"r\" === e ? `P1$r${i.scrollTop + 1};${i.scrollBottom + 1}r` : \"m\" === e ? \"P1$r0m\" : \" q\" === e ? `P1$r${{\n                block: 2,\n                underline: 4,\n                bar: 6\n              }[r.cursorStyle] - (r.cursorBlink ? 1 : 0)} q` : \"P0$r\");\n            }\n          }\n          t.InputHandler = b;\n        },\n        844: (e, t) => {\n          function i(e) {\n            for (const t of e) t.dispose();\n            e.length = 0;\n          }\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.getDisposeArrayDisposable = t.disposeArray = t.toDisposable = t.Disposable = void 0, t.Disposable = class {\n            constructor() {\n              this._disposables = [], this._isDisposed = !1;\n            }\n            dispose() {\n              this._isDisposed = !0;\n              for (const e of this._disposables) e.dispose();\n              this._disposables.length = 0;\n            }\n            register(e) {\n              return this._disposables.push(e), e;\n            }\n            unregister(e) {\n              const t = this._disposables.indexOf(e);\n              -1 !== t && this._disposables.splice(t, 1);\n            }\n          }, t.toDisposable = function (e) {\n            return {\n              dispose: e\n            };\n          }, t.disposeArray = i, t.getDisposeArrayDisposable = function (e) {\n            return {\n              dispose: () => i(e)\n            };\n          };\n        },\n        1505: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.FourKeyMap = t.TwoKeyMap = void 0;\n          class i {\n            constructor() {\n              this._data = {};\n            }\n            set(e, t, i) {\n              this._data[e] || (this._data[e] = {}), this._data[e][t] = i;\n            }\n            get(e, t) {\n              return this._data[e] ? this._data[e][t] : void 0;\n            }\n            clear() {\n              this._data = {};\n            }\n          }\n          t.TwoKeyMap = i, t.FourKeyMap = class {\n            constructor() {\n              this._data = new i();\n            }\n            set(e, t, s, r, n) {\n              this._data.get(e, t) || this._data.set(e, t, new i()), this._data.get(e, t).set(s, r, n);\n            }\n            get(e, t, i, s) {\n              var r;\n              return null === (r = this._data.get(e, t)) || void 0 === r ? void 0 : r.get(i, s);\n            }\n            clear() {\n              this._data.clear();\n            }\n          };\n        },\n        6114: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.isLinux = t.isWindows = t.isIphone = t.isIpad = t.isMac = t.isSafari = t.isLegacyEdge = t.isFirefox = void 0;\n          const i = \"undefined\" == typeof navigator,\n            s = i ? \"node\" : navigator.userAgent,\n            r = i ? \"node\" : navigator.platform;\n          t.isFirefox = s.includes(\"Firefox\"), t.isLegacyEdge = s.includes(\"Edge\"), t.isSafari = /^((?!chrome|android).)*safari/i.test(s), t.isMac = [\"Macintosh\", \"MacIntel\", \"MacPPC\", \"Mac68K\"].includes(r), t.isIpad = \"iPad\" === r, t.isIphone = \"iPhone\" === r, t.isWindows = [\"Windows\", \"Win16\", \"Win32\", \"WinCE\"].includes(r), t.isLinux = r.indexOf(\"Linux\") >= 0;\n        },\n        6106: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.SortedList = void 0;\n          let i = 0;\n          t.SortedList = class {\n            constructor(e) {\n              this._getKey = e, this._array = [];\n            }\n            clear() {\n              this._array.length = 0;\n            }\n            insert(e) {\n              0 !== this._array.length ? (i = this._search(this._getKey(e), 0, this._array.length - 1), this._array.splice(i, 0, e)) : this._array.push(e);\n            }\n            delete(e) {\n              if (0 === this._array.length) return !1;\n              const t = this._getKey(e);\n              if (void 0 === t) return !1;\n              if (i = this._search(t, 0, this._array.length - 1), -1 === i) return !1;\n              if (this._getKey(this._array[i]) !== t) return !1;\n              do {\n                if (this._array[i] === e) return this._array.splice(i, 1), !0;\n              } while (++i < this._array.length && this._getKey(this._array[i]) === t);\n              return !1;\n            }\n            *getKeyIterator(e) {\n              if (0 !== this._array.length && (i = this._search(e, 0, this._array.length - 1), !(i < 0 || i >= this._array.length) && this._getKey(this._array[i]) === e)) do {\n                yield this._array[i];\n              } while (++i < this._array.length && this._getKey(this._array[i]) === e);\n            }\n            forEachByKey(e, t) {\n              if (0 !== this._array.length && (i = this._search(e, 0, this._array.length - 1), !(i < 0 || i >= this._array.length) && this._getKey(this._array[i]) === e)) do {\n                t(this._array[i]);\n              } while (++i < this._array.length && this._getKey(this._array[i]) === e);\n            }\n            values() {\n              return this._array.values();\n            }\n            _search(e, t, i) {\n              if (i < t) return t;\n              let s = Math.floor((t + i) / 2);\n              const r = this._getKey(this._array[s]);\n              if (r > e) return this._search(e, t, s - 1);\n              if (r < e) return this._search(e, s + 1, i);\n              for (; s > 0 && this._getKey(this._array[s - 1]) === e;) s--;\n              return s;\n            }\n          };\n        },\n        8273: (e, t) => {\n          function i(e, t, i = 0, s = e.length) {\n            if (i >= e.length) return e;\n            i = (e.length + i) % e.length, s = s >= e.length ? e.length : (e.length + s) % e.length;\n            for (let r = i; r < s; ++r) e[r] = t;\n            return e;\n          }\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.concat = t.fillFallback = t.fill = void 0, t.fill = function (e, t, s, r) {\n            return e.fill ? e.fill(t, s, r) : i(e, t, s, r);\n          }, t.fillFallback = i, t.concat = function (e, t) {\n            const i = new e.constructor(e.length + t.length);\n            return i.set(e), i.set(t, e.length), i;\n          };\n        },\n        9282: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.updateWindowsModeWrappedState = void 0;\n          const s = i(643);\n          t.updateWindowsModeWrappedState = function (e) {\n            const t = e.buffer.lines.get(e.buffer.ybase + e.buffer.y - 1),\n              i = null == t ? void 0 : t.get(e.cols - 1),\n              r = e.buffer.lines.get(e.buffer.ybase + e.buffer.y);\n            r && i && (r.isWrapped = i[s.CHAR_DATA_CODE_INDEX] !== s.NULL_CELL_CODE && i[s.CHAR_DATA_CODE_INDEX] !== s.WHITESPACE_CELL_CODE);\n          };\n        },\n        3734: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.ExtendedAttrs = t.AttributeData = void 0;\n          class i {\n            constructor() {\n              this.fg = 0, this.bg = 0, this.extended = new s();\n            }\n            static toColorRGB(e) {\n              return [e >>> 16 & 255, e >>> 8 & 255, 255 & e];\n            }\n            static fromColorRGB(e) {\n              return (255 & e[0]) << 16 | (255 & e[1]) << 8 | 255 & e[2];\n            }\n            clone() {\n              const e = new i();\n              return e.fg = this.fg, e.bg = this.bg, e.extended = this.extended.clone(), e;\n            }\n            isInverse() {\n              return 67108864 & this.fg;\n            }\n            isBold() {\n              return 134217728 & this.fg;\n            }\n            isUnderline() {\n              return this.hasExtendedAttrs() && 0 !== this.extended.underlineStyle ? 1 : 268435456 & this.fg;\n            }\n            isBlink() {\n              return 536870912 & this.fg;\n            }\n            isInvisible() {\n              return 1073741824 & this.fg;\n            }\n            isItalic() {\n              return 67108864 & this.bg;\n            }\n            isDim() {\n              return 134217728 & this.bg;\n            }\n            isStrikethrough() {\n              return 2147483648 & this.fg;\n            }\n            isProtected() {\n              return 536870912 & this.bg;\n            }\n            getFgColorMode() {\n              return 50331648 & this.fg;\n            }\n            getBgColorMode() {\n              return 50331648 & this.bg;\n            }\n            isFgRGB() {\n              return 50331648 == (50331648 & this.fg);\n            }\n            isBgRGB() {\n              return 50331648 == (50331648 & this.bg);\n            }\n            isFgPalette() {\n              return 16777216 == (50331648 & this.fg) || 33554432 == (50331648 & this.fg);\n            }\n            isBgPalette() {\n              return 16777216 == (50331648 & this.bg) || 33554432 == (50331648 & this.bg);\n            }\n            isFgDefault() {\n              return 0 == (50331648 & this.fg);\n            }\n            isBgDefault() {\n              return 0 == (50331648 & this.bg);\n            }\n            isAttributeDefault() {\n              return 0 === this.fg && 0 === this.bg;\n            }\n            getFgColor() {\n              switch (50331648 & this.fg) {\n                case 16777216:\n                case 33554432:\n                  return 255 & this.fg;\n                case 50331648:\n                  return 16777215 & this.fg;\n                default:\n                  return -1;\n              }\n            }\n            getBgColor() {\n              switch (50331648 & this.bg) {\n                case 16777216:\n                case 33554432:\n                  return 255 & this.bg;\n                case 50331648:\n                  return 16777215 & this.bg;\n                default:\n                  return -1;\n              }\n            }\n            hasExtendedAttrs() {\n              return 268435456 & this.bg;\n            }\n            updateExtended() {\n              this.extended.isEmpty() ? this.bg &= -268435457 : this.bg |= 268435456;\n            }\n            getUnderlineColor() {\n              if (268435456 & this.bg && ~this.extended.underlineColor) switch (50331648 & this.extended.underlineColor) {\n                case 16777216:\n                case 33554432:\n                  return 255 & this.extended.underlineColor;\n                case 50331648:\n                  return 16777215 & this.extended.underlineColor;\n                default:\n                  return this.getFgColor();\n              }\n              return this.getFgColor();\n            }\n            getUnderlineColorMode() {\n              return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 & this.extended.underlineColor : this.getFgColorMode();\n            }\n            isUnderlineColorRGB() {\n              return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 == (50331648 & this.extended.underlineColor) : this.isFgRGB();\n            }\n            isUnderlineColorPalette() {\n              return 268435456 & this.bg && ~this.extended.underlineColor ? 16777216 == (50331648 & this.extended.underlineColor) || 33554432 == (50331648 & this.extended.underlineColor) : this.isFgPalette();\n            }\n            isUnderlineColorDefault() {\n              return 268435456 & this.bg && ~this.extended.underlineColor ? 0 == (50331648 & this.extended.underlineColor) : this.isFgDefault();\n            }\n            getUnderlineStyle() {\n              return 268435456 & this.fg ? 268435456 & this.bg ? this.extended.underlineStyle : 1 : 0;\n            }\n          }\n          t.AttributeData = i;\n          class s {\n            constructor(e = 0, t = 0) {\n              this._ext = 0, this._urlId = 0, this._ext = e, this._urlId = t;\n            }\n            get ext() {\n              return this._urlId ? -469762049 & this._ext | this.underlineStyle << 26 : this._ext;\n            }\n            set ext(e) {\n              this._ext = e;\n            }\n            get underlineStyle() {\n              return this._urlId ? 5 : (469762048 & this._ext) >> 26;\n            }\n            set underlineStyle(e) {\n              this._ext &= -469762049, this._ext |= e << 26 & 469762048;\n            }\n            get underlineColor() {\n              return 67108863 & this._ext;\n            }\n            set underlineColor(e) {\n              this._ext &= -67108864, this._ext |= 67108863 & e;\n            }\n            get urlId() {\n              return this._urlId;\n            }\n            set urlId(e) {\n              this._urlId = e;\n            }\n            clone() {\n              return new s(this._ext, this._urlId);\n            }\n            isEmpty() {\n              return 0 === this.underlineStyle && 0 === this._urlId;\n            }\n          }\n          t.ExtendedAttrs = s;\n        },\n        9092: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.BufferStringIterator = t.Buffer = t.MAX_BUFFER_SIZE = void 0;\n          const s = i(6349),\n            r = i(8437),\n            n = i(511),\n            o = i(643),\n            a = i(4634),\n            h = i(4863),\n            c = i(7116),\n            l = i(3734);\n          t.MAX_BUFFER_SIZE = 4294967295, t.Buffer = class {\n            constructor(e, t, i) {\n              this._hasScrollback = e, this._optionsService = t, this._bufferService = i, this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.savedY = 0, this.savedX = 0, this.savedCurAttrData = r.DEFAULT_ATTR_DATA.clone(), this.savedCharset = c.DEFAULT_CHARSET, this.markers = [], this._nullCell = n.CellData.fromCharData([0, o.NULL_CELL_CHAR, o.NULL_CELL_WIDTH, o.NULL_CELL_CODE]), this._whitespaceCell = n.CellData.fromCharData([0, o.WHITESPACE_CELL_CHAR, o.WHITESPACE_CELL_WIDTH, o.WHITESPACE_CELL_CODE]), this._isClearing = !1, this._cols = this._bufferService.cols, this._rows = this._bufferService.rows, this.lines = new s.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();\n            }\n            getNullCell(e) {\n              return e ? (this._nullCell.fg = e.fg, this._nullCell.bg = e.bg, this._nullCell.extended = e.extended) : (this._nullCell.fg = 0, this._nullCell.bg = 0, this._nullCell.extended = new l.ExtendedAttrs()), this._nullCell;\n            }\n            getWhitespaceCell(e) {\n              return e ? (this._whitespaceCell.fg = e.fg, this._whitespaceCell.bg = e.bg, this._whitespaceCell.extended = e.extended) : (this._whitespaceCell.fg = 0, this._whitespaceCell.bg = 0, this._whitespaceCell.extended = new l.ExtendedAttrs()), this._whitespaceCell;\n            }\n            getBlankLine(e, t) {\n              return new r.BufferLine(this._bufferService.cols, this.getNullCell(e), t);\n            }\n            get hasScrollback() {\n              return this._hasScrollback && this.lines.maxLength > this._rows;\n            }\n            get isCursorInViewport() {\n              const e = this.ybase + this.y - this.ydisp;\n              return e >= 0 && e < this._rows;\n            }\n            _getCorrectBufferLength(e) {\n              if (!this._hasScrollback) return e;\n              const i = e + this._optionsService.rawOptions.scrollback;\n              return i > t.MAX_BUFFER_SIZE ? t.MAX_BUFFER_SIZE : i;\n            }\n            fillViewportRows(e) {\n              if (0 === this.lines.length) {\n                void 0 === e && (e = r.DEFAULT_ATTR_DATA);\n                let t = this._rows;\n                for (; t--;) this.lines.push(this.getBlankLine(e));\n              }\n            }\n            clear() {\n              this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.lines = new s.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();\n            }\n            resize(e, t) {\n              const i = this.getNullCell(r.DEFAULT_ATTR_DATA),\n                s = this._getCorrectBufferLength(t);\n              if (s > this.lines.maxLength && (this.lines.maxLength = s), this.lines.length > 0) {\n                if (this._cols < e) for (let t = 0; t < this.lines.length; t++) this.lines.get(t).resize(e, i);\n                let n = 0;\n                if (this._rows < t) for (let s = this._rows; s < t; s++) this.lines.length < t + this.ybase && (this._optionsService.rawOptions.windowsMode ? this.lines.push(new r.BufferLine(e, i)) : this.ybase > 0 && this.lines.length <= this.ybase + this.y + n + 1 ? (this.ybase--, n++, this.ydisp > 0 && this.ydisp--) : this.lines.push(new r.BufferLine(e, i)));else for (let e = this._rows; e > t; e--) this.lines.length > t + this.ybase && (this.lines.length > this.ybase + this.y + 1 ? this.lines.pop() : (this.ybase++, this.ydisp++));\n                if (s < this.lines.maxLength) {\n                  const e = this.lines.length - s;\n                  e > 0 && (this.lines.trimStart(e), this.ybase = Math.max(this.ybase - e, 0), this.ydisp = Math.max(this.ydisp - e, 0), this.savedY = Math.max(this.savedY - e, 0)), this.lines.maxLength = s;\n                }\n                this.x = Math.min(this.x, e - 1), this.y = Math.min(this.y, t - 1), n && (this.y += n), this.savedX = Math.min(this.savedX, e - 1), this.scrollTop = 0;\n              }\n              if (this.scrollBottom = t - 1, this._isReflowEnabled && (this._reflow(e, t), this._cols > e)) for (let t = 0; t < this.lines.length; t++) this.lines.get(t).resize(e, i);\n              this._cols = e, this._rows = t;\n            }\n            get _isReflowEnabled() {\n              return this._hasScrollback && !this._optionsService.rawOptions.windowsMode;\n            }\n            _reflow(e, t) {\n              this._cols !== e && (e > this._cols ? this._reflowLarger(e, t) : this._reflowSmaller(e, t));\n            }\n            _reflowLarger(e, t) {\n              const i = (0, a.reflowLargerGetLinesToRemove)(this.lines, this._cols, e, this.ybase + this.y, this.getNullCell(r.DEFAULT_ATTR_DATA));\n              if (i.length > 0) {\n                const s = (0, a.reflowLargerCreateNewLayout)(this.lines, i);\n                (0, a.reflowLargerApplyNewLayout)(this.lines, s.layout), this._reflowLargerAdjustViewport(e, t, s.countRemoved);\n              }\n            }\n            _reflowLargerAdjustViewport(e, t, i) {\n              const s = this.getNullCell(r.DEFAULT_ATTR_DATA);\n              let n = i;\n              for (; n-- > 0;) 0 === this.ybase ? (this.y > 0 && this.y--, this.lines.length < t && this.lines.push(new r.BufferLine(e, s))) : (this.ydisp === this.ybase && this.ydisp--, this.ybase--);\n              this.savedY = Math.max(this.savedY - i, 0);\n            }\n            _reflowSmaller(e, t) {\n              const i = this.getNullCell(r.DEFAULT_ATTR_DATA),\n                s = [];\n              let n = 0;\n              for (let o = this.lines.length - 1; o >= 0; o--) {\n                let h = this.lines.get(o);\n                if (!h || !h.isWrapped && h.getTrimmedLength() <= e) continue;\n                const c = [h];\n                for (; h.isWrapped && o > 0;) h = this.lines.get(--o), c.unshift(h);\n                const l = this.ybase + this.y;\n                if (l >= o && l < o + c.length) continue;\n                const d = c[c.length - 1].getTrimmedLength(),\n                  _ = (0, a.reflowSmallerGetNewLineLengths)(c, this._cols, e),\n                  u = _.length - c.length;\n                let f;\n                f = 0 === this.ybase && this.y !== this.lines.length - 1 ? Math.max(0, this.y - this.lines.maxLength + u) : Math.max(0, this.lines.length - this.lines.maxLength + u);\n                const v = [];\n                for (let e = 0; e < u; e++) {\n                  const e = this.getBlankLine(r.DEFAULT_ATTR_DATA, !0);\n                  v.push(e);\n                }\n                v.length > 0 && (s.push({\n                  start: o + c.length + n,\n                  newLines: v\n                }), n += v.length), c.push(...v);\n                let g = _.length - 1,\n                  p = _[g];\n                0 === p && (g--, p = _[g]);\n                let S = c.length - u - 1,\n                  m = d;\n                for (; S >= 0;) {\n                  const e = Math.min(m, p);\n                  if (void 0 === c[g]) break;\n                  if (c[g].copyCellsFrom(c[S], m - e, p - e, e, !0), p -= e, 0 === p && (g--, p = _[g]), m -= e, 0 === m) {\n                    S--;\n                    const e = Math.max(S, 0);\n                    m = (0, a.getWrappedLineTrimmedLength)(c, e, this._cols);\n                  }\n                }\n                for (let t = 0; t < c.length; t++) _[t] < e && c[t].setCell(_[t], i);\n                let C = u - f;\n                for (; C-- > 0;) 0 === this.ybase ? this.y < t - 1 ? (this.y++, this.lines.pop()) : (this.ybase++, this.ydisp++) : this.ybase < Math.min(this.lines.maxLength, this.lines.length + n) - t && (this.ybase === this.ydisp && this.ydisp++, this.ybase++);\n                this.savedY = Math.min(this.savedY + u, this.ybase + t - 1);\n              }\n              if (s.length > 0) {\n                const e = [],\n                  t = [];\n                for (let e = 0; e < this.lines.length; e++) t.push(this.lines.get(e));\n                const i = this.lines.length;\n                let r = i - 1,\n                  o = 0,\n                  a = s[o];\n                this.lines.length = Math.min(this.lines.maxLength, this.lines.length + n);\n                let h = 0;\n                for (let c = Math.min(this.lines.maxLength - 1, i + n - 1); c >= 0; c--) if (a && a.start > r + h) {\n                  for (let e = a.newLines.length - 1; e >= 0; e--) this.lines.set(c--, a.newLines[e]);\n                  c++, e.push({\n                    index: r + 1,\n                    amount: a.newLines.length\n                  }), h += a.newLines.length, a = s[++o];\n                } else this.lines.set(c, t[r--]);\n                let c = 0;\n                for (let t = e.length - 1; t >= 0; t--) e[t].index += c, this.lines.onInsertEmitter.fire(e[t]), c += e[t].amount;\n                const l = Math.max(0, i + n - this.lines.maxLength);\n                l > 0 && this.lines.onTrimEmitter.fire(l);\n              }\n            }\n            stringIndexToBufferIndex(e, t, i = !1) {\n              for (; t;) {\n                const s = this.lines.get(e);\n                if (!s) return [-1, -1];\n                const r = i ? s.getTrimmedLength() : s.length;\n                for (let i = 0; i < r; ++i) if (s.get(i)[o.CHAR_DATA_WIDTH_INDEX] && (t -= s.get(i)[o.CHAR_DATA_CHAR_INDEX].length || 1), t < 0) return [e, i];\n                e++;\n              }\n              return [e, 0];\n            }\n            translateBufferLineToString(e, t, i = 0, s) {\n              const r = this.lines.get(e);\n              return r ? r.translateToString(t, i, s) : \"\";\n            }\n            getWrappedRangeForLine(e) {\n              let t = e,\n                i = e;\n              for (; t > 0 && this.lines.get(t).isWrapped;) t--;\n              for (; i + 1 < this.lines.length && this.lines.get(i + 1).isWrapped;) i++;\n              return {\n                first: t,\n                last: i\n              };\n            }\n            setupTabStops(e) {\n              for (null != e ? this.tabs[e] || (e = this.prevStop(e)) : (this.tabs = {}, e = 0); e < this._cols; e += this._optionsService.rawOptions.tabStopWidth) this.tabs[e] = !0;\n            }\n            prevStop(e) {\n              for (null == e && (e = this.x); !this.tabs[--e] && e > 0;);\n              return e >= this._cols ? this._cols - 1 : e < 0 ? 0 : e;\n            }\n            nextStop(e) {\n              for (null == e && (e = this.x); !this.tabs[++e] && e < this._cols;);\n              return e >= this._cols ? this._cols - 1 : e < 0 ? 0 : e;\n            }\n            clearMarkers(e) {\n              this._isClearing = !0;\n              for (let t = 0; t < this.markers.length; t++) this.markers[t].line === e && (this.markers[t].dispose(), this.markers.splice(t--, 1));\n              this._isClearing = !1;\n            }\n            clearAllMarkers() {\n              this._isClearing = !0;\n              for (let e = 0; e < this.markers.length; e++) this.markers[e].dispose(), this.markers.splice(e--, 1);\n              this._isClearing = !1;\n            }\n            addMarker(e) {\n              const t = new h.Marker(e);\n              return this.markers.push(t), t.register(this.lines.onTrim(e => {\n                t.line -= e, t.line < 0 && t.dispose();\n              })), t.register(this.lines.onInsert(e => {\n                t.line >= e.index && (t.line += e.amount);\n              })), t.register(this.lines.onDelete(e => {\n                t.line >= e.index && t.line < e.index + e.amount && t.dispose(), t.line > e.index && (t.line -= e.amount);\n              })), t.register(t.onDispose(() => this._removeMarker(t))), t;\n            }\n            _removeMarker(e) {\n              this._isClearing || this.markers.splice(this.markers.indexOf(e), 1);\n            }\n            iterator(e, t, i, s, r) {\n              return new d(this, e, t, i, s, r);\n            }\n          };\n          class d {\n            constructor(e, t, i = 0, s = e.lines.length, r = 0, n = 0) {\n              this._buffer = e, this._trimRight = t, this._startIndex = i, this._endIndex = s, this._startOverscan = r, this._endOverscan = n, this._startIndex < 0 && (this._startIndex = 0), this._endIndex > this._buffer.lines.length && (this._endIndex = this._buffer.lines.length), this._current = this._startIndex;\n            }\n            hasNext() {\n              return this._current < this._endIndex;\n            }\n            next() {\n              const e = this._buffer.getWrappedRangeForLine(this._current);\n              e.first < this._startIndex - this._startOverscan && (e.first = this._startIndex - this._startOverscan), e.last > this._endIndex + this._endOverscan && (e.last = this._endIndex + this._endOverscan), e.first = Math.max(e.first, 0), e.last = Math.min(e.last, this._buffer.lines.length);\n              let t = \"\";\n              for (let i = e.first; i <= e.last; ++i) t += this._buffer.translateBufferLineToString(i, this._trimRight);\n              return this._current = e.last + 1, {\n                range: e,\n                content: t\n              };\n            }\n          }\n          t.BufferStringIterator = d;\n        },\n        8437: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.BufferLine = t.DEFAULT_ATTR_DATA = void 0;\n          const s = i(482),\n            r = i(643),\n            n = i(511),\n            o = i(3734);\n          t.DEFAULT_ATTR_DATA = Object.freeze(new o.AttributeData());\n          const a = {\n            startIndex: 0\n          };\n          class h {\n            constructor(e, t, i = !1) {\n              this.isWrapped = i, this._combined = {}, this._extendedAttrs = {}, this._data = new Uint32Array(3 * e);\n              const s = t || n.CellData.fromCharData([0, r.NULL_CELL_CHAR, r.NULL_CELL_WIDTH, r.NULL_CELL_CODE]);\n              for (let t = 0; t < e; ++t) this.setCell(t, s);\n              this.length = e;\n            }\n            get(e) {\n              const t = this._data[3 * e + 0],\n                i = 2097151 & t;\n              return [this._data[3 * e + 1], 2097152 & t ? this._combined[e] : i ? (0, s.stringFromCodePoint)(i) : \"\", t >> 22, 2097152 & t ? this._combined[e].charCodeAt(this._combined[e].length - 1) : i];\n            }\n            set(e, t) {\n              this._data[3 * e + 1] = t[r.CHAR_DATA_ATTR_INDEX], t[r.CHAR_DATA_CHAR_INDEX].length > 1 ? (this._combined[e] = t[1], this._data[3 * e + 0] = 2097152 | e | t[r.CHAR_DATA_WIDTH_INDEX] << 22) : this._data[3 * e + 0] = t[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | t[r.CHAR_DATA_WIDTH_INDEX] << 22;\n            }\n            getWidth(e) {\n              return this._data[3 * e + 0] >> 22;\n            }\n            hasWidth(e) {\n              return 12582912 & this._data[3 * e + 0];\n            }\n            getFg(e) {\n              return this._data[3 * e + 1];\n            }\n            getBg(e) {\n              return this._data[3 * e + 2];\n            }\n            hasContent(e) {\n              return 4194303 & this._data[3 * e + 0];\n            }\n            getCodePoint(e) {\n              const t = this._data[3 * e + 0];\n              return 2097152 & t ? this._combined[e].charCodeAt(this._combined[e].length - 1) : 2097151 & t;\n            }\n            isCombined(e) {\n              return 2097152 & this._data[3 * e + 0];\n            }\n            getString(e) {\n              const t = this._data[3 * e + 0];\n              return 2097152 & t ? this._combined[e] : 2097151 & t ? (0, s.stringFromCodePoint)(2097151 & t) : \"\";\n            }\n            isProtected(e) {\n              return 536870912 & this._data[3 * e + 2];\n            }\n            loadCell(e, t) {\n              return a.startIndex = 3 * e, t.content = this._data[a.startIndex + 0], t.fg = this._data[a.startIndex + 1], t.bg = this._data[a.startIndex + 2], 2097152 & t.content && (t.combinedData = this._combined[e]), 268435456 & t.bg && (t.extended = this._extendedAttrs[e]), t;\n            }\n            setCell(e, t) {\n              2097152 & t.content && (this._combined[e] = t.combinedData), 268435456 & t.bg && (this._extendedAttrs[e] = t.extended), this._data[3 * e + 0] = t.content, this._data[3 * e + 1] = t.fg, this._data[3 * e + 2] = t.bg;\n            }\n            setCellFromCodePoint(e, t, i, s, r, n) {\n              268435456 & r && (this._extendedAttrs[e] = n), this._data[3 * e + 0] = t | i << 22, this._data[3 * e + 1] = s, this._data[3 * e + 2] = r;\n            }\n            addCodepointToCell(e, t) {\n              let i = this._data[3 * e + 0];\n              2097152 & i ? this._combined[e] += (0, s.stringFromCodePoint)(t) : (2097151 & i ? (this._combined[e] = (0, s.stringFromCodePoint)(2097151 & i) + (0, s.stringFromCodePoint)(t), i &= -2097152, i |= 2097152) : i = t | 1 << 22, this._data[3 * e + 0] = i);\n            }\n            insertCells(e, t, i, s) {\n              if ((e %= this.length) && 2 === this.getWidth(e - 1) && this.setCellFromCodePoint(e - 1, 0, 1, (null == s ? void 0 : s.fg) || 0, (null == s ? void 0 : s.bg) || 0, (null == s ? void 0 : s.extended) || new o.ExtendedAttrs()), t < this.length - e) {\n                const s = new n.CellData();\n                for (let i = this.length - e - t - 1; i >= 0; --i) this.setCell(e + t + i, this.loadCell(e + i, s));\n                for (let s = 0; s < t; ++s) this.setCell(e + s, i);\n              } else for (let t = e; t < this.length; ++t) this.setCell(t, i);\n              2 === this.getWidth(this.length - 1) && this.setCellFromCodePoint(this.length - 1, 0, 1, (null == s ? void 0 : s.fg) || 0, (null == s ? void 0 : s.bg) || 0, (null == s ? void 0 : s.extended) || new o.ExtendedAttrs());\n            }\n            deleteCells(e, t, i, s) {\n              if (e %= this.length, t < this.length - e) {\n                const s = new n.CellData();\n                for (let i = 0; i < this.length - e - t; ++i) this.setCell(e + i, this.loadCell(e + t + i, s));\n                for (let e = this.length - t; e < this.length; ++e) this.setCell(e, i);\n              } else for (let t = e; t < this.length; ++t) this.setCell(t, i);\n              e && 2 === this.getWidth(e - 1) && this.setCellFromCodePoint(e - 1, 0, 1, (null == s ? void 0 : s.fg) || 0, (null == s ? void 0 : s.bg) || 0, (null == s ? void 0 : s.extended) || new o.ExtendedAttrs()), 0 !== this.getWidth(e) || this.hasContent(e) || this.setCellFromCodePoint(e, 0, 1, (null == s ? void 0 : s.fg) || 0, (null == s ? void 0 : s.bg) || 0, (null == s ? void 0 : s.extended) || new o.ExtendedAttrs());\n            }\n            replaceCells(e, t, i, s, r = !1) {\n              if (r) for (e && 2 === this.getWidth(e - 1) && !this.isProtected(e - 1) && this.setCellFromCodePoint(e - 1, 0, 1, (null == s ? void 0 : s.fg) || 0, (null == s ? void 0 : s.bg) || 0, (null == s ? void 0 : s.extended) || new o.ExtendedAttrs()), t < this.length && 2 === this.getWidth(t - 1) && !this.isProtected(t) && this.setCellFromCodePoint(t, 0, 1, (null == s ? void 0 : s.fg) || 0, (null == s ? void 0 : s.bg) || 0, (null == s ? void 0 : s.extended) || new o.ExtendedAttrs()); e < t && e < this.length;) this.isProtected(e) || this.setCell(e, i), e++;else for (e && 2 === this.getWidth(e - 1) && this.setCellFromCodePoint(e - 1, 0, 1, (null == s ? void 0 : s.fg) || 0, (null == s ? void 0 : s.bg) || 0, (null == s ? void 0 : s.extended) || new o.ExtendedAttrs()), t < this.length && 2 === this.getWidth(t - 1) && this.setCellFromCodePoint(t, 0, 1, (null == s ? void 0 : s.fg) || 0, (null == s ? void 0 : s.bg) || 0, (null == s ? void 0 : s.extended) || new o.ExtendedAttrs()); e < t && e < this.length;) this.setCell(e++, i);\n            }\n            resize(e, t) {\n              if (e !== this.length) {\n                if (e > this.length) {\n                  const i = new Uint32Array(3 * e);\n                  this.length && (3 * e < this._data.length ? i.set(this._data.subarray(0, 3 * e)) : i.set(this._data)), this._data = i;\n                  for (let i = this.length; i < e; ++i) this.setCell(i, t);\n                } else if (e) {\n                  const t = new Uint32Array(3 * e);\n                  t.set(this._data.subarray(0, 3 * e)), this._data = t;\n                  const i = Object.keys(this._combined);\n                  for (let t = 0; t < i.length; t++) {\n                    const s = parseInt(i[t], 10);\n                    s >= e && delete this._combined[s];\n                  }\n                } else this._data = new Uint32Array(0), this._combined = {};\n                this.length = e;\n              }\n            }\n            fill(e, t = !1) {\n              if (t) for (let t = 0; t < this.length; ++t) this.isProtected(t) || this.setCell(t, e);else {\n                this._combined = {}, this._extendedAttrs = {};\n                for (let t = 0; t < this.length; ++t) this.setCell(t, e);\n              }\n            }\n            copyFrom(e) {\n              this.length !== e.length ? this._data = new Uint32Array(e._data) : this._data.set(e._data), this.length = e.length, this._combined = {};\n              for (const t in e._combined) this._combined[t] = e._combined[t];\n              this._extendedAttrs = {};\n              for (const t in e._extendedAttrs) this._extendedAttrs[t] = e._extendedAttrs[t];\n              this.isWrapped = e.isWrapped;\n            }\n            clone() {\n              const e = new h(0);\n              e._data = new Uint32Array(this._data), e.length = this.length;\n              for (const t in this._combined) e._combined[t] = this._combined[t];\n              for (const t in this._extendedAttrs) e._extendedAttrs[t] = this._extendedAttrs[t];\n              return e.isWrapped = this.isWrapped, e;\n            }\n            getTrimmedLength() {\n              for (let e = this.length - 1; e >= 0; --e) if (4194303 & this._data[3 * e + 0]) return e + (this._data[3 * e + 0] >> 22);\n              return 0;\n            }\n            copyCellsFrom(e, t, i, s, r) {\n              const n = e._data;\n              if (r) for (let r = s - 1; r >= 0; r--) {\n                for (let e = 0; e < 3; e++) this._data[3 * (i + r) + e] = n[3 * (t + r) + e];\n                268435456 & n[3 * (t + r) + 2] && (this._extendedAttrs[i + r] = e._extendedAttrs[t + r]);\n              } else for (let r = 0; r < s; r++) {\n                for (let e = 0; e < 3; e++) this._data[3 * (i + r) + e] = n[3 * (t + r) + e];\n                268435456 & n[3 * (t + r) + 2] && (this._extendedAttrs[i + r] = e._extendedAttrs[t + r]);\n              }\n              const o = Object.keys(e._combined);\n              for (let s = 0; s < o.length; s++) {\n                const r = parseInt(o[s], 10);\n                r >= t && (this._combined[r - t + i] = e._combined[r]);\n              }\n            }\n            translateToString(e = !1, t = 0, i = this.length) {\n              e && (i = Math.min(i, this.getTrimmedLength()));\n              let n = \"\";\n              for (; t < i;) {\n                const e = this._data[3 * t + 0],\n                  i = 2097151 & e;\n                n += 2097152 & e ? this._combined[t] : i ? (0, s.stringFromCodePoint)(i) : r.WHITESPACE_CELL_CHAR, t += e >> 22 || 1;\n              }\n              return n;\n            }\n          }\n          t.BufferLine = h;\n        },\n        4841: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.getRangeLength = void 0, t.getRangeLength = function (e, t) {\n            if (e.start.y > e.end.y) throw new Error(`Buffer range end (${e.end.x}, ${e.end.y}) cannot be before start (${e.start.x}, ${e.start.y})`);\n            return t * (e.end.y - e.start.y) + (e.end.x - e.start.x + 1);\n          };\n        },\n        4634: (e, t) => {\n          function i(e, t, i) {\n            if (t === e.length - 1) return e[t].getTrimmedLength();\n            const s = !e[t].hasContent(i - 1) && 1 === e[t].getWidth(i - 1),\n              r = 2 === e[t + 1].getWidth(0);\n            return s && r ? i - 1 : i;\n          }\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.getWrappedLineTrimmedLength = t.reflowSmallerGetNewLineLengths = t.reflowLargerApplyNewLayout = t.reflowLargerCreateNewLayout = t.reflowLargerGetLinesToRemove = void 0, t.reflowLargerGetLinesToRemove = function (e, t, s, r, n) {\n            const o = [];\n            for (let a = 0; a < e.length - 1; a++) {\n              let h = a,\n                c = e.get(++h);\n              if (!c.isWrapped) continue;\n              const l = [e.get(a)];\n              for (; h < e.length && c.isWrapped;) l.push(c), c = e.get(++h);\n              if (r >= a && r < h) {\n                a += l.length - 1;\n                continue;\n              }\n              let d = 0,\n                _ = i(l, d, t),\n                u = 1,\n                f = 0;\n              for (; u < l.length;) {\n                const e = i(l, u, t),\n                  r = e - f,\n                  o = s - _,\n                  a = Math.min(r, o);\n                l[d].copyCellsFrom(l[u], f, _, a, !1), _ += a, _ === s && (d++, _ = 0), f += a, f === e && (u++, f = 0), 0 === _ && 0 !== d && 2 === l[d - 1].getWidth(s - 1) && (l[d].copyCellsFrom(l[d - 1], s - 1, _++, 1, !1), l[d - 1].setCell(s - 1, n));\n              }\n              l[d].replaceCells(_, s, n);\n              let v = 0;\n              for (let e = l.length - 1; e > 0 && (e > d || 0 === l[e].getTrimmedLength()); e--) v++;\n              v > 0 && (o.push(a + l.length - v), o.push(v)), a += l.length - 1;\n            }\n            return o;\n          }, t.reflowLargerCreateNewLayout = function (e, t) {\n            const i = [];\n            let s = 0,\n              r = t[s],\n              n = 0;\n            for (let o = 0; o < e.length; o++) if (r === o) {\n              const i = t[++s];\n              e.onDeleteEmitter.fire({\n                index: o - n,\n                amount: i\n              }), o += i - 1, n += i, r = t[++s];\n            } else i.push(o);\n            return {\n              layout: i,\n              countRemoved: n\n            };\n          }, t.reflowLargerApplyNewLayout = function (e, t) {\n            const i = [];\n            for (let s = 0; s < t.length; s++) i.push(e.get(t[s]));\n            for (let t = 0; t < i.length; t++) e.set(t, i[t]);\n            e.length = t.length;\n          }, t.reflowSmallerGetNewLineLengths = function (e, t, s) {\n            const r = [],\n              n = e.map((s, r) => i(e, r, t)).reduce((e, t) => e + t);\n            let o = 0,\n              a = 0,\n              h = 0;\n            for (; h < n;) {\n              if (n - h < s) {\n                r.push(n - h);\n                break;\n              }\n              o += s;\n              const c = i(e, a, t);\n              o > c && (o -= c, a++);\n              const l = 2 === e[a].getWidth(o - 1);\n              l && o--;\n              const d = l ? s - 1 : s;\n              r.push(d), h += d;\n            }\n            return r;\n          }, t.getWrappedLineTrimmedLength = i;\n        },\n        5295: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.BufferSet = void 0;\n          const s = i(9092),\n            r = i(8460),\n            n = i(844);\n          class o extends n.Disposable {\n            constructor(e, t) {\n              super(), this._optionsService = e, this._bufferService = t, this._onBufferActivate = this.register(new r.EventEmitter()), this.reset();\n            }\n            get onBufferActivate() {\n              return this._onBufferActivate.event;\n            }\n            reset() {\n              this._normal = new s.Buffer(!0, this._optionsService, this._bufferService), this._normal.fillViewportRows(), this._alt = new s.Buffer(!1, this._optionsService, this._bufferService), this._activeBuffer = this._normal, this._onBufferActivate.fire({\n                activeBuffer: this._normal,\n                inactiveBuffer: this._alt\n              }), this.setupTabStops();\n            }\n            get alt() {\n              return this._alt;\n            }\n            get active() {\n              return this._activeBuffer;\n            }\n            get normal() {\n              return this._normal;\n            }\n            activateNormalBuffer() {\n              this._activeBuffer !== this._normal && (this._normal.x = this._alt.x, this._normal.y = this._alt.y, this._alt.clearAllMarkers(), this._alt.clear(), this._activeBuffer = this._normal, this._onBufferActivate.fire({\n                activeBuffer: this._normal,\n                inactiveBuffer: this._alt\n              }));\n            }\n            activateAltBuffer(e) {\n              this._activeBuffer !== this._alt && (this._alt.fillViewportRows(e), this._alt.x = this._normal.x, this._alt.y = this._normal.y, this._activeBuffer = this._alt, this._onBufferActivate.fire({\n                activeBuffer: this._alt,\n                inactiveBuffer: this._normal\n              }));\n            }\n            resize(e, t) {\n              this._normal.resize(e, t), this._alt.resize(e, t);\n            }\n            setupTabStops(e) {\n              this._normal.setupTabStops(e), this._alt.setupTabStops(e);\n            }\n          }\n          t.BufferSet = o;\n        },\n        511: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.CellData = void 0;\n          const s = i(482),\n            r = i(643),\n            n = i(3734);\n          class o extends n.AttributeData {\n            constructor() {\n              super(...arguments), this.content = 0, this.fg = 0, this.bg = 0, this.extended = new n.ExtendedAttrs(), this.combinedData = \"\";\n            }\n            static fromCharData(e) {\n              const t = new o();\n              return t.setFromCharData(e), t;\n            }\n            isCombined() {\n              return 2097152 & this.content;\n            }\n            getWidth() {\n              return this.content >> 22;\n            }\n            getChars() {\n              return 2097152 & this.content ? this.combinedData : 2097151 & this.content ? (0, s.stringFromCodePoint)(2097151 & this.content) : \"\";\n            }\n            getCode() {\n              return this.isCombined() ? this.combinedData.charCodeAt(this.combinedData.length - 1) : 2097151 & this.content;\n            }\n            setFromCharData(e) {\n              this.fg = e[r.CHAR_DATA_ATTR_INDEX], this.bg = 0;\n              let t = !1;\n              if (e[r.CHAR_DATA_CHAR_INDEX].length > 2) t = !0;else if (2 === e[r.CHAR_DATA_CHAR_INDEX].length) {\n                const i = e[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0);\n                if (55296 <= i && i <= 56319) {\n                  const s = e[r.CHAR_DATA_CHAR_INDEX].charCodeAt(1);\n                  56320 <= s && s <= 57343 ? this.content = 1024 * (i - 55296) + s - 56320 + 65536 | e[r.CHAR_DATA_WIDTH_INDEX] << 22 : t = !0;\n                } else t = !0;\n              } else this.content = e[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | e[r.CHAR_DATA_WIDTH_INDEX] << 22;\n              t && (this.combinedData = e[r.CHAR_DATA_CHAR_INDEX], this.content = 2097152 | e[r.CHAR_DATA_WIDTH_INDEX] << 22);\n            }\n            getAsCharData() {\n              return [this.fg, this.getChars(), this.getWidth(), this.getCode()];\n            }\n          }\n          t.CellData = o;\n        },\n        643: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.WHITESPACE_CELL_CODE = t.WHITESPACE_CELL_WIDTH = t.WHITESPACE_CELL_CHAR = t.NULL_CELL_CODE = t.NULL_CELL_WIDTH = t.NULL_CELL_CHAR = t.CHAR_DATA_CODE_INDEX = t.CHAR_DATA_WIDTH_INDEX = t.CHAR_DATA_CHAR_INDEX = t.CHAR_DATA_ATTR_INDEX = t.DEFAULT_EXT = t.DEFAULT_ATTR = t.DEFAULT_COLOR = void 0, t.DEFAULT_COLOR = 256, t.DEFAULT_ATTR = 256 | t.DEFAULT_COLOR << 9, t.DEFAULT_EXT = 0, t.CHAR_DATA_ATTR_INDEX = 0, t.CHAR_DATA_CHAR_INDEX = 1, t.CHAR_DATA_WIDTH_INDEX = 2, t.CHAR_DATA_CODE_INDEX = 3, t.NULL_CELL_CHAR = \"\", t.NULL_CELL_WIDTH = 1, t.NULL_CELL_CODE = 0, t.WHITESPACE_CELL_CHAR = \" \", t.WHITESPACE_CELL_WIDTH = 1, t.WHITESPACE_CELL_CODE = 32;\n        },\n        4863: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.Marker = void 0;\n          const s = i(8460),\n            r = i(844);\n          class n extends r.Disposable {\n            constructor(e) {\n              super(), this.line = e, this._id = n._nextId++, this.isDisposed = !1, this._onDispose = new s.EventEmitter();\n            }\n            get id() {\n              return this._id;\n            }\n            get onDispose() {\n              return this._onDispose.event;\n            }\n            dispose() {\n              this.isDisposed || (this.isDisposed = !0, this.line = -1, this._onDispose.fire(), super.dispose());\n            }\n          }\n          t.Marker = n, n._nextId = 1;\n        },\n        7116: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.DEFAULT_CHARSET = t.CHARSETS = void 0, t.CHARSETS = {}, t.DEFAULT_CHARSET = t.CHARSETS.B, t.CHARSETS[0] = {\n            \"`\": \"◆\",\n            a: \"▒\",\n            b: \"␉\",\n            c: \"␌\",\n            d: \"␍\",\n            e: \"␊\",\n            f: \"°\",\n            g: \"±\",\n            h: \"␤\",\n            i: \"␋\",\n            j: \"┘\",\n            k: \"┐\",\n            l: \"┌\",\n            m: \"└\",\n            n: \"┼\",\n            o: \"⎺\",\n            p: \"⎻\",\n            q: \"─\",\n            r: \"⎼\",\n            s: \"⎽\",\n            t: \"├\",\n            u: \"┤\",\n            v: \"┴\",\n            w: \"┬\",\n            x: \"│\",\n            y: \"≤\",\n            z: \"≥\",\n            \"{\": \"π\",\n            \"|\": \"≠\",\n            \"}\": \"£\",\n            \"~\": \"·\"\n          }, t.CHARSETS.A = {\n            \"#\": \"£\"\n          }, t.CHARSETS.B = void 0, t.CHARSETS[4] = {\n            \"#\": \"£\",\n            \"@\": \"¾\",\n            \"[\": \"ij\",\n            \"\\\\\": \"½\",\n            \"]\": \"|\",\n            \"{\": \"¨\",\n            \"|\": \"f\",\n            \"}\": \"¼\",\n            \"~\": \"´\"\n          }, t.CHARSETS.C = t.CHARSETS[5] = {\n            \"[\": \"Ä\",\n            \"\\\\\": \"Ö\",\n            \"]\": \"Å\",\n            \"^\": \"Ü\",\n            \"`\": \"é\",\n            \"{\": \"ä\",\n            \"|\": \"ö\",\n            \"}\": \"å\",\n            \"~\": \"ü\"\n          }, t.CHARSETS.R = {\n            \"#\": \"£\",\n            \"@\": \"à\",\n            \"[\": \"°\",\n            \"\\\\\": \"ç\",\n            \"]\": \"§\",\n            \"{\": \"é\",\n            \"|\": \"ù\",\n            \"}\": \"è\",\n            \"~\": \"¨\"\n          }, t.CHARSETS.Q = {\n            \"@\": \"à\",\n            \"[\": \"â\",\n            \"\\\\\": \"ç\",\n            \"]\": \"ê\",\n            \"^\": \"î\",\n            \"`\": \"ô\",\n            \"{\": \"é\",\n            \"|\": \"ù\",\n            \"}\": \"è\",\n            \"~\": \"û\"\n          }, t.CHARSETS.K = {\n            \"@\": \"§\",\n            \"[\": \"Ä\",\n            \"\\\\\": \"Ö\",\n            \"]\": \"Ü\",\n            \"{\": \"ä\",\n            \"|\": \"ö\",\n            \"}\": \"ü\",\n            \"~\": \"ß\"\n          }, t.CHARSETS.Y = {\n            \"#\": \"£\",\n            \"@\": \"§\",\n            \"[\": \"°\",\n            \"\\\\\": \"ç\",\n            \"]\": \"é\",\n            \"`\": \"ù\",\n            \"{\": \"à\",\n            \"|\": \"ò\",\n            \"}\": \"è\",\n            \"~\": \"ì\"\n          }, t.CHARSETS.E = t.CHARSETS[6] = {\n            \"@\": \"Ä\",\n            \"[\": \"Æ\",\n            \"\\\\\": \"Ø\",\n            \"]\": \"Å\",\n            \"^\": \"Ü\",\n            \"`\": \"ä\",\n            \"{\": \"æ\",\n            \"|\": \"ø\",\n            \"}\": \"å\",\n            \"~\": \"ü\"\n          }, t.CHARSETS.Z = {\n            \"#\": \"£\",\n            \"@\": \"§\",\n            \"[\": \"¡\",\n            \"\\\\\": \"Ñ\",\n            \"]\": \"¿\",\n            \"{\": \"°\",\n            \"|\": \"ñ\",\n            \"}\": \"ç\"\n          }, t.CHARSETS.H = t.CHARSETS[7] = {\n            \"@\": \"É\",\n            \"[\": \"Ä\",\n            \"\\\\\": \"Ö\",\n            \"]\": \"Å\",\n            \"^\": \"Ü\",\n            \"`\": \"é\",\n            \"{\": \"ä\",\n            \"|\": \"ö\",\n            \"}\": \"å\",\n            \"~\": \"ü\"\n          }, t.CHARSETS[\"=\"] = {\n            \"#\": \"ù\",\n            \"@\": \"à\",\n            \"[\": \"é\",\n            \"\\\\\": \"ç\",\n            \"]\": \"ê\",\n            \"^\": \"î\",\n            _: \"è\",\n            \"`\": \"ô\",\n            \"{\": \"ä\",\n            \"|\": \"ö\",\n            \"}\": \"ü\",\n            \"~\": \"û\"\n          };\n        },\n        2584: (e, t) => {\n          var i, s;\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.C1_ESCAPED = t.C1 = t.C0 = void 0, function (e) {\n            e.NUL = \"\\0\", e.SOH = \"\u0001\", e.STX = \"\u0002\", e.ETX = \"\u0003\", e.EOT = \"\u0004\", e.ENQ = \"\u0005\", e.ACK = \"\u0006\", e.BEL = \"\u0007\", e.BS = \"\\b\", e.HT = \"\\t\", e.LF = \"\\n\", e.VT = \"\\v\", e.FF = \"\\f\", e.CR = \"\\r\", e.SO = \"\u000e\", e.SI = \"\u000f\", e.DLE = \"\u0010\", e.DC1 = \"\u0011\", e.DC2 = \"\u0012\", e.DC3 = \"\u0013\", e.DC4 = \"\u0014\", e.NAK = \"\u0015\", e.SYN = \"\u0016\", e.ETB = \"\u0017\", e.CAN = \"\u0018\", e.EM = \"\u0019\", e.SUB = \"\u001a\", e.ESC = \"\u001b\", e.FS = \"\u001c\", e.GS = \"\u001d\", e.RS = \"\u001e\", e.US = \"\u001f\", e.SP = \" \", e.DEL = \"\";\n          }(i = t.C0 || (t.C0 = {})), (s = t.C1 || (t.C1 = {})).PAD = \"\", s.HOP = \"\", s.BPH = \"\", s.NBH = \"\", s.IND = \"\", s.NEL = \"\", s.SSA = \"\", s.ESA = \"\", s.HTS = \"\", s.HTJ = \"\", s.VTS = \"\", s.PLD = \"\", s.PLU = \"\", s.RI = \"\", s.SS2 = \"\", s.SS3 = \"\", s.DCS = \"\", s.PU1 = \"\", s.PU2 = \"\", s.STS = \"\", s.CCH = \"\", s.MW = \"\", s.SPA = \"\", s.EPA = \"\", s.SOS = \"\", s.SGCI = \"\", s.SCI = \"\", s.CSI = \"\", s.ST = \"\", s.OSC = \"\", s.PM = \"\", s.APC = \"\", (t.C1_ESCAPED || (t.C1_ESCAPED = {})).ST = `${i.ESC}\\\\`;\n        },\n        7399: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.evaluateKeyboardEvent = void 0;\n          const s = i(2584),\n            r = {\n              48: [\"0\", \")\"],\n              49: [\"1\", \"!\"],\n              50: [\"2\", \"@\"],\n              51: [\"3\", \"#\"],\n              52: [\"4\", \"$\"],\n              53: [\"5\", \"%\"],\n              54: [\"6\", \"^\"],\n              55: [\"7\", \"&\"],\n              56: [\"8\", \"*\"],\n              57: [\"9\", \"(\"],\n              186: [\";\", \":\"],\n              187: [\"=\", \"+\"],\n              188: [\",\", \"<\"],\n              189: [\"-\", \"_\"],\n              190: [\".\", \">\"],\n              191: [\"/\", \"?\"],\n              192: [\"`\", \"~\"],\n              219: [\"[\", \"{\"],\n              220: [\"\\\\\", \"|\"],\n              221: [\"]\", \"}\"],\n              222: [\"'\", '\"']\n            };\n          t.evaluateKeyboardEvent = function (e, t, i, n) {\n            const o = {\n                type: 0,\n                cancel: !1,\n                key: void 0\n              },\n              a = (e.shiftKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.ctrlKey ? 4 : 0) | (e.metaKey ? 8 : 0);\n            switch (e.keyCode) {\n              case 0:\n                \"UIKeyInputUpArrow\" === e.key ? o.key = t ? s.C0.ESC + \"OA\" : s.C0.ESC + \"[A\" : \"UIKeyInputLeftArrow\" === e.key ? o.key = t ? s.C0.ESC + \"OD\" : s.C0.ESC + \"[D\" : \"UIKeyInputRightArrow\" === e.key ? o.key = t ? s.C0.ESC + \"OC\" : s.C0.ESC + \"[C\" : \"UIKeyInputDownArrow\" === e.key && (o.key = t ? s.C0.ESC + \"OB\" : s.C0.ESC + \"[B\");\n                break;\n              case 8:\n                if (e.altKey) {\n                  o.key = s.C0.ESC + s.C0.DEL;\n                  break;\n                }\n                o.key = s.C0.DEL;\n                break;\n              case 9:\n                if (e.shiftKey) {\n                  o.key = s.C0.ESC + \"[Z\";\n                  break;\n                }\n                o.key = s.C0.HT, o.cancel = !0;\n                break;\n              case 13:\n                o.key = e.altKey ? s.C0.ESC + s.C0.CR : s.C0.CR, o.cancel = !0;\n                break;\n              case 27:\n                o.key = s.C0.ESC, e.altKey && (o.key = s.C0.ESC + s.C0.ESC), o.cancel = !0;\n                break;\n              case 37:\n                if (e.metaKey) break;\n                a ? (o.key = s.C0.ESC + \"[1;\" + (a + 1) + \"D\", o.key === s.C0.ESC + \"[1;3D\" && (o.key = s.C0.ESC + (i ? \"b\" : \"[1;5D\"))) : o.key = t ? s.C0.ESC + \"OD\" : s.C0.ESC + \"[D\";\n                break;\n              case 39:\n                if (e.metaKey) break;\n                a ? (o.key = s.C0.ESC + \"[1;\" + (a + 1) + \"C\", o.key === s.C0.ESC + \"[1;3C\" && (o.key = s.C0.ESC + (i ? \"f\" : \"[1;5C\"))) : o.key = t ? s.C0.ESC + \"OC\" : s.C0.ESC + \"[C\";\n                break;\n              case 38:\n                if (e.metaKey) break;\n                a ? (o.key = s.C0.ESC + \"[1;\" + (a + 1) + \"A\", i || o.key !== s.C0.ESC + \"[1;3A\" || (o.key = s.C0.ESC + \"[1;5A\")) : o.key = t ? s.C0.ESC + \"OA\" : s.C0.ESC + \"[A\";\n                break;\n              case 40:\n                if (e.metaKey) break;\n                a ? (o.key = s.C0.ESC + \"[1;\" + (a + 1) + \"B\", i || o.key !== s.C0.ESC + \"[1;3B\" || (o.key = s.C0.ESC + \"[1;5B\")) : o.key = t ? s.C0.ESC + \"OB\" : s.C0.ESC + \"[B\";\n                break;\n              case 45:\n                e.shiftKey || e.ctrlKey || (o.key = s.C0.ESC + \"[2~\");\n                break;\n              case 46:\n                o.key = a ? s.C0.ESC + \"[3;\" + (a + 1) + \"~\" : s.C0.ESC + \"[3~\";\n                break;\n              case 36:\n                o.key = a ? s.C0.ESC + \"[1;\" + (a + 1) + \"H\" : t ? s.C0.ESC + \"OH\" : s.C0.ESC + \"[H\";\n                break;\n              case 35:\n                o.key = a ? s.C0.ESC + \"[1;\" + (a + 1) + \"F\" : t ? s.C0.ESC + \"OF\" : s.C0.ESC + \"[F\";\n                break;\n              case 33:\n                e.shiftKey ? o.type = 2 : e.ctrlKey ? o.key = s.C0.ESC + \"[5;\" + (a + 1) + \"~\" : o.key = s.C0.ESC + \"[5~\";\n                break;\n              case 34:\n                e.shiftKey ? o.type = 3 : e.ctrlKey ? o.key = s.C0.ESC + \"[6;\" + (a + 1) + \"~\" : o.key = s.C0.ESC + \"[6~\";\n                break;\n              case 112:\n                o.key = a ? s.C0.ESC + \"[1;\" + (a + 1) + \"P\" : s.C0.ESC + \"OP\";\n                break;\n              case 113:\n                o.key = a ? s.C0.ESC + \"[1;\" + (a + 1) + \"Q\" : s.C0.ESC + \"OQ\";\n                break;\n              case 114:\n                o.key = a ? s.C0.ESC + \"[1;\" + (a + 1) + \"R\" : s.C0.ESC + \"OR\";\n                break;\n              case 115:\n                o.key = a ? s.C0.ESC + \"[1;\" + (a + 1) + \"S\" : s.C0.ESC + \"OS\";\n                break;\n              case 116:\n                o.key = a ? s.C0.ESC + \"[15;\" + (a + 1) + \"~\" : s.C0.ESC + \"[15~\";\n                break;\n              case 117:\n                o.key = a ? s.C0.ESC + \"[17;\" + (a + 1) + \"~\" : s.C0.ESC + \"[17~\";\n                break;\n              case 118:\n                o.key = a ? s.C0.ESC + \"[18;\" + (a + 1) + \"~\" : s.C0.ESC + \"[18~\";\n                break;\n              case 119:\n                o.key = a ? s.C0.ESC + \"[19;\" + (a + 1) + \"~\" : s.C0.ESC + \"[19~\";\n                break;\n              case 120:\n                o.key = a ? s.C0.ESC + \"[20;\" + (a + 1) + \"~\" : s.C0.ESC + \"[20~\";\n                break;\n              case 121:\n                o.key = a ? s.C0.ESC + \"[21;\" + (a + 1) + \"~\" : s.C0.ESC + \"[21~\";\n                break;\n              case 122:\n                o.key = a ? s.C0.ESC + \"[23;\" + (a + 1) + \"~\" : s.C0.ESC + \"[23~\";\n                break;\n              case 123:\n                o.key = a ? s.C0.ESC + \"[24;\" + (a + 1) + \"~\" : s.C0.ESC + \"[24~\";\n                break;\n              default:\n                if (!e.ctrlKey || e.shiftKey || e.altKey || e.metaKey) {\n                  if (i && !n || !e.altKey || e.metaKey) !i || e.altKey || e.ctrlKey || e.shiftKey || !e.metaKey ? e.key && !e.ctrlKey && !e.altKey && !e.metaKey && e.keyCode >= 48 && 1 === e.key.length ? o.key = e.key : e.key && e.ctrlKey && (\"_\" === e.key && (o.key = s.C0.US), \"@\" === e.key && (o.key = s.C0.NUL)) : 65 === e.keyCode && (o.type = 1);else {\n                    const t = r[e.keyCode],\n                      i = null == t ? void 0 : t[e.shiftKey ? 1 : 0];\n                    if (i) o.key = s.C0.ESC + i;else if (e.keyCode >= 65 && e.keyCode <= 90) {\n                      const t = e.ctrlKey ? e.keyCode - 64 : e.keyCode + 32;\n                      let i = String.fromCharCode(t);\n                      e.shiftKey && (i = i.toUpperCase()), o.key = s.C0.ESC + i;\n                    } else if (\"Dead\" === e.key && e.code.startsWith(\"Key\")) {\n                      let t = e.code.slice(3, 4);\n                      e.shiftKey || (t = t.toLowerCase()), o.key = s.C0.ESC + t, o.cancel = !0;\n                    }\n                  }\n                } else e.keyCode >= 65 && e.keyCode <= 90 ? o.key = String.fromCharCode(e.keyCode - 64) : 32 === e.keyCode ? o.key = s.C0.NUL : e.keyCode >= 51 && e.keyCode <= 55 ? o.key = String.fromCharCode(e.keyCode - 51 + 27) : 56 === e.keyCode ? o.key = s.C0.DEL : 219 === e.keyCode ? o.key = s.C0.ESC : 220 === e.keyCode ? o.key = s.C0.FS : 221 === e.keyCode && (o.key = s.C0.GS);\n            }\n            return o;\n          };\n        },\n        482: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.Utf8ToUtf32 = t.StringToUtf32 = t.utf32ToString = t.stringFromCodePoint = void 0, t.stringFromCodePoint = function (e) {\n            return e > 65535 ? (e -= 65536, String.fromCharCode(55296 + (e >> 10)) + String.fromCharCode(e % 1024 + 56320)) : String.fromCharCode(e);\n          }, t.utf32ToString = function (e, t = 0, i = e.length) {\n            let s = \"\";\n            for (let r = t; r < i; ++r) {\n              let t = e[r];\n              t > 65535 ? (t -= 65536, s += String.fromCharCode(55296 + (t >> 10)) + String.fromCharCode(t % 1024 + 56320)) : s += String.fromCharCode(t);\n            }\n            return s;\n          }, t.StringToUtf32 = class {\n            constructor() {\n              this._interim = 0;\n            }\n            clear() {\n              this._interim = 0;\n            }\n            decode(e, t) {\n              const i = e.length;\n              if (!i) return 0;\n              let s = 0,\n                r = 0;\n              if (this._interim) {\n                const i = e.charCodeAt(r++);\n                56320 <= i && i <= 57343 ? t[s++] = 1024 * (this._interim - 55296) + i - 56320 + 65536 : (t[s++] = this._interim, t[s++] = i), this._interim = 0;\n              }\n              for (let n = r; n < i; ++n) {\n                const r = e.charCodeAt(n);\n                if (55296 <= r && r <= 56319) {\n                  if (++n >= i) return this._interim = r, s;\n                  const o = e.charCodeAt(n);\n                  56320 <= o && o <= 57343 ? t[s++] = 1024 * (r - 55296) + o - 56320 + 65536 : (t[s++] = r, t[s++] = o);\n                } else 65279 !== r && (t[s++] = r);\n              }\n              return s;\n            }\n          }, t.Utf8ToUtf32 = class {\n            constructor() {\n              this.interim = new Uint8Array(3);\n            }\n            clear() {\n              this.interim.fill(0);\n            }\n            decode(e, t) {\n              const i = e.length;\n              if (!i) return 0;\n              let s,\n                r,\n                n,\n                o,\n                a = 0,\n                h = 0,\n                c = 0;\n              if (this.interim[0]) {\n                let s = !1,\n                  r = this.interim[0];\n                r &= 192 == (224 & r) ? 31 : 224 == (240 & r) ? 15 : 7;\n                let n,\n                  o = 0;\n                for (; (n = 63 & this.interim[++o]) && o < 4;) r <<= 6, r |= n;\n                const h = 192 == (224 & this.interim[0]) ? 2 : 224 == (240 & this.interim[0]) ? 3 : 4,\n                  l = h - o;\n                for (; c < l;) {\n                  if (c >= i) return 0;\n                  if (n = e[c++], 128 != (192 & n)) {\n                    c--, s = !0;\n                    break;\n                  }\n                  this.interim[o++] = n, r <<= 6, r |= 63 & n;\n                }\n                s || (2 === h ? r < 128 ? c-- : t[a++] = r : 3 === h ? r < 2048 || r >= 55296 && r <= 57343 || 65279 === r || (t[a++] = r) : r < 65536 || r > 1114111 || (t[a++] = r)), this.interim.fill(0);\n              }\n              const l = i - 4;\n              let d = c;\n              for (; d < i;) {\n                for (; !(!(d < l) || 128 & (s = e[d]) || 128 & (r = e[d + 1]) || 128 & (n = e[d + 2]) || 128 & (o = e[d + 3]));) t[a++] = s, t[a++] = r, t[a++] = n, t[a++] = o, d += 4;\n                if (s = e[d++], s < 128) t[a++] = s;else if (192 == (224 & s)) {\n                  if (d >= i) return this.interim[0] = s, a;\n                  if (r = e[d++], 128 != (192 & r)) {\n                    d--;\n                    continue;\n                  }\n                  if (h = (31 & s) << 6 | 63 & r, h < 128) {\n                    d--;\n                    continue;\n                  }\n                  t[a++] = h;\n                } else if (224 == (240 & s)) {\n                  if (d >= i) return this.interim[0] = s, a;\n                  if (r = e[d++], 128 != (192 & r)) {\n                    d--;\n                    continue;\n                  }\n                  if (d >= i) return this.interim[0] = s, this.interim[1] = r, a;\n                  if (n = e[d++], 128 != (192 & n)) {\n                    d--;\n                    continue;\n                  }\n                  if (h = (15 & s) << 12 | (63 & r) << 6 | 63 & n, h < 2048 || h >= 55296 && h <= 57343 || 65279 === h) continue;\n                  t[a++] = h;\n                } else if (240 == (248 & s)) {\n                  if (d >= i) return this.interim[0] = s, a;\n                  if (r = e[d++], 128 != (192 & r)) {\n                    d--;\n                    continue;\n                  }\n                  if (d >= i) return this.interim[0] = s, this.interim[1] = r, a;\n                  if (n = e[d++], 128 != (192 & n)) {\n                    d--;\n                    continue;\n                  }\n                  if (d >= i) return this.interim[0] = s, this.interim[1] = r, this.interim[2] = n, a;\n                  if (o = e[d++], 128 != (192 & o)) {\n                    d--;\n                    continue;\n                  }\n                  if (h = (7 & s) << 18 | (63 & r) << 12 | (63 & n) << 6 | 63 & o, h < 65536 || h > 1114111) continue;\n                  t[a++] = h;\n                }\n              }\n              return a;\n            }\n          };\n        },\n        225: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.UnicodeV6 = void 0;\n          const s = i(8273),\n            r = [[768, 879], [1155, 1158], [1160, 1161], [1425, 1469], [1471, 1471], [1473, 1474], [1476, 1477], [1479, 1479], [1536, 1539], [1552, 1557], [1611, 1630], [1648, 1648], [1750, 1764], [1767, 1768], [1770, 1773], [1807, 1807], [1809, 1809], [1840, 1866], [1958, 1968], [2027, 2035], [2305, 2306], [2364, 2364], [2369, 2376], [2381, 2381], [2385, 2388], [2402, 2403], [2433, 2433], [2492, 2492], [2497, 2500], [2509, 2509], [2530, 2531], [2561, 2562], [2620, 2620], [2625, 2626], [2631, 2632], [2635, 2637], [2672, 2673], [2689, 2690], [2748, 2748], [2753, 2757], [2759, 2760], [2765, 2765], [2786, 2787], [2817, 2817], [2876, 2876], [2879, 2879], [2881, 2883], [2893, 2893], [2902, 2902], [2946, 2946], [3008, 3008], [3021, 3021], [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3260, 3260], [3263, 3263], [3270, 3270], [3276, 3277], [3298, 3299], [3393, 3395], [3405, 3405], [3530, 3530], [3538, 3540], [3542, 3542], [3633, 3633], [3636, 3642], [3655, 3662], [3761, 3761], [3764, 3769], [3771, 3772], [3784, 3789], [3864, 3865], [3893, 3893], [3895, 3895], [3897, 3897], [3953, 3966], [3968, 3972], [3974, 3975], [3984, 3991], [3993, 4028], [4038, 4038], [4141, 4144], [4146, 4146], [4150, 4151], [4153, 4153], [4184, 4185], [4448, 4607], [4959, 4959], [5906, 5908], [5938, 5940], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], [6086, 6086], [6089, 6099], [6109, 6109], [6155, 6157], [6313, 6313], [6432, 6434], [6439, 6440], [6450, 6450], [6457, 6459], [6679, 6680], [6912, 6915], [6964, 6964], [6966, 6970], [6972, 6972], [6978, 6978], [7019, 7027], [7616, 7626], [7678, 7679], [8203, 8207], [8234, 8238], [8288, 8291], [8298, 8303], [8400, 8431], [12330, 12335], [12441, 12442], [43014, 43014], [43019, 43019], [43045, 43046], [64286, 64286], [65024, 65039], [65056, 65059], [65279, 65279], [65529, 65531]],\n            n = [[68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], [68159, 68159], [119143, 119145], [119155, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [917505, 917505], [917536, 917631], [917760, 917999]];\n          let o;\n          t.UnicodeV6 = class {\n            constructor() {\n              if (this.version = \"6\", !o) {\n                o = new Uint8Array(65536), (0, s.fill)(o, 1), o[0] = 0, (0, s.fill)(o, 0, 1, 32), (0, s.fill)(o, 0, 127, 160), (0, s.fill)(o, 2, 4352, 4448), o[9001] = 2, o[9002] = 2, (0, s.fill)(o, 2, 11904, 42192), o[12351] = 1, (0, s.fill)(o, 2, 44032, 55204), (0, s.fill)(o, 2, 63744, 64256), (0, s.fill)(o, 2, 65040, 65050), (0, s.fill)(o, 2, 65072, 65136), (0, s.fill)(o, 2, 65280, 65377), (0, s.fill)(o, 2, 65504, 65511);\n                for (let e = 0; e < r.length; ++e) (0, s.fill)(o, 0, r[e][0], r[e][1] + 1);\n              }\n            }\n            wcwidth(e) {\n              return e < 32 ? 0 : e < 127 ? 1 : e < 65536 ? o[e] : function (e, t) {\n                let i,\n                  s = 0,\n                  r = t.length - 1;\n                if (e < t[0][0] || e > t[r][1]) return !1;\n                for (; r >= s;) if (i = s + r >> 1, e > t[i][1]) s = i + 1;else {\n                  if (!(e < t[i][0])) return !0;\n                  r = i - 1;\n                }\n                return !1;\n              }(e, n) ? 0 : e >= 131072 && e <= 196605 || e >= 196608 && e <= 262141 ? 2 : 1;\n            }\n          };\n        },\n        5981: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.WriteBuffer = void 0;\n          const s = i(8460),\n            r = \"undefined\" == typeof queueMicrotask ? e => {\n              Promise.resolve().then(e);\n            } : queueMicrotask;\n          t.WriteBuffer = class {\n            constructor(e) {\n              this._action = e, this._writeBuffer = [], this._callbacks = [], this._pendingData = 0, this._bufferOffset = 0, this._isSyncWriting = !1, this._syncCalls = 0, this._onWriteParsed = new s.EventEmitter();\n            }\n            get onWriteParsed() {\n              return this._onWriteParsed.event;\n            }\n            writeSync(e, t) {\n              if (void 0 !== t && this._syncCalls > t) return void (this._syncCalls = 0);\n              if (this._pendingData += e.length, this._writeBuffer.push(e), this._callbacks.push(void 0), this._syncCalls++, this._isSyncWriting) return;\n              let i;\n              for (this._isSyncWriting = !0; i = this._writeBuffer.shift();) {\n                this._action(i);\n                const e = this._callbacks.shift();\n                e && e();\n              }\n              this._pendingData = 0, this._bufferOffset = 2147483647, this._isSyncWriting = !1, this._syncCalls = 0;\n            }\n            write(e, t) {\n              if (this._pendingData > 5e7) throw new Error(\"write data discarded, use flow control to avoid losing data\");\n              this._writeBuffer.length || (this._bufferOffset = 0, setTimeout(() => this._innerWrite())), this._pendingData += e.length, this._writeBuffer.push(e), this._callbacks.push(t);\n            }\n            _innerWrite(e = 0, t = !0) {\n              const i = e || Date.now();\n              for (; this._writeBuffer.length > this._bufferOffset;) {\n                const e = this._writeBuffer[this._bufferOffset],\n                  s = this._action(e, t);\n                if (s) {\n                  const e = e => Date.now() - i >= 12 ? setTimeout(() => this._innerWrite(0, e)) : this._innerWrite(i, e);\n                  return void s.catch(e => (r(() => {\n                    throw e;\n                  }), Promise.resolve(!1))).then(e);\n                }\n                const n = this._callbacks[this._bufferOffset];\n                if (n && n(), this._bufferOffset++, this._pendingData -= e.length, Date.now() - i >= 12) break;\n              }\n              this._writeBuffer.length > this._bufferOffset ? (this._bufferOffset > 50 && (this._writeBuffer = this._writeBuffer.slice(this._bufferOffset), this._callbacks = this._callbacks.slice(this._bufferOffset), this._bufferOffset = 0), setTimeout(() => this._innerWrite())) : (this._writeBuffer.length = 0, this._callbacks.length = 0, this._pendingData = 0, this._bufferOffset = 0), this._onWriteParsed.fire();\n            }\n          };\n        },\n        5941: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.toRgbString = t.parseColor = void 0;\n          const i = /^([\\da-f])\\/([\\da-f])\\/([\\da-f])$|^([\\da-f]{2})\\/([\\da-f]{2})\\/([\\da-f]{2})$|^([\\da-f]{3})\\/([\\da-f]{3})\\/([\\da-f]{3})$|^([\\da-f]{4})\\/([\\da-f]{4})\\/([\\da-f]{4})$/,\n            s = /^[\\da-f]+$/;\n          function r(e, t) {\n            const i = e.toString(16),\n              s = i.length < 2 ? \"0\" + i : i;\n            switch (t) {\n              case 4:\n                return i[0];\n              case 8:\n                return s;\n              case 12:\n                return (s + s).slice(0, 3);\n              default:\n                return s + s;\n            }\n          }\n          t.parseColor = function (e) {\n            if (!e) return;\n            let t = e.toLowerCase();\n            if (0 === t.indexOf(\"rgb:\")) {\n              t = t.slice(4);\n              const e = i.exec(t);\n              if (e) {\n                const t = e[1] ? 15 : e[4] ? 255 : e[7] ? 4095 : 65535;\n                return [Math.round(parseInt(e[1] || e[4] || e[7] || e[10], 16) / t * 255), Math.round(parseInt(e[2] || e[5] || e[8] || e[11], 16) / t * 255), Math.round(parseInt(e[3] || e[6] || e[9] || e[12], 16) / t * 255)];\n              }\n            } else if (0 === t.indexOf(\"#\") && (t = t.slice(1), s.exec(t) && [3, 6, 9, 12].includes(t.length))) {\n              const e = t.length / 3,\n                i = [0, 0, 0];\n              for (let s = 0; s < 3; ++s) {\n                const r = parseInt(t.slice(e * s, e * s + e), 16);\n                i[s] = 1 === e ? r << 4 : 2 === e ? r : 3 === e ? r >> 4 : r >> 8;\n              }\n              return i;\n            }\n          }, t.toRgbString = function (e, t = 16) {\n            const [i, s, n] = e;\n            return `rgb:${r(i, t)}/${r(s, t)}/${r(n, t)}`;\n          };\n        },\n        5770: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.PAYLOAD_LIMIT = void 0, t.PAYLOAD_LIMIT = 1e7;\n        },\n        6351: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.DcsHandler = t.DcsParser = void 0;\n          const s = i(482),\n            r = i(8742),\n            n = i(5770),\n            o = [];\n          t.DcsParser = class {\n            constructor() {\n              this._handlers = Object.create(null), this._active = o, this._ident = 0, this._handlerFb = () => {}, this._stack = {\n                paused: !1,\n                loopPosition: 0,\n                fallThrough: !1\n              };\n            }\n            dispose() {\n              this._handlers = Object.create(null), this._handlerFb = () => {}, this._active = o;\n            }\n            registerHandler(e, t) {\n              void 0 === this._handlers[e] && (this._handlers[e] = []);\n              const i = this._handlers[e];\n              return i.push(t), {\n                dispose: () => {\n                  const e = i.indexOf(t);\n                  -1 !== e && i.splice(e, 1);\n                }\n              };\n            }\n            clearHandler(e) {\n              this._handlers[e] && delete this._handlers[e];\n            }\n            setHandlerFallback(e) {\n              this._handlerFb = e;\n            }\n            reset() {\n              if (this._active.length) for (let e = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; e >= 0; --e) this._active[e].unhook(!1);\n              this._stack.paused = !1, this._active = o, this._ident = 0;\n            }\n            hook(e, t) {\n              if (this.reset(), this._ident = e, this._active = this._handlers[e] || o, this._active.length) for (let e = this._active.length - 1; e >= 0; e--) this._active[e].hook(t);else this._handlerFb(this._ident, \"HOOK\", t);\n            }\n            put(e, t, i) {\n              if (this._active.length) for (let s = this._active.length - 1; s >= 0; s--) this._active[s].put(e, t, i);else this._handlerFb(this._ident, \"PUT\", (0, s.utf32ToString)(e, t, i));\n            }\n            unhook(e, t = !0) {\n              if (this._active.length) {\n                let i = !1,\n                  s = this._active.length - 1,\n                  r = !1;\n                if (this._stack.paused && (s = this._stack.loopPosition - 1, i = t, r = this._stack.fallThrough, this._stack.paused = !1), !r && !1 === i) {\n                  for (; s >= 0 && (i = this._active[s].unhook(e), !0 !== i); s--) if (i instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = s, this._stack.fallThrough = !1, i;\n                  s--;\n                }\n                for (; s >= 0; s--) if (i = this._active[s].unhook(!1), i instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = s, this._stack.fallThrough = !0, i;\n              } else this._handlerFb(this._ident, \"UNHOOK\", e);\n              this._active = o, this._ident = 0;\n            }\n          };\n          const a = new r.Params();\n          a.addParam(0), t.DcsHandler = class {\n            constructor(e) {\n              this._handler = e, this._data = \"\", this._params = a, this._hitLimit = !1;\n            }\n            hook(e) {\n              this._params = e.length > 1 || e.params[0] ? e.clone() : a, this._data = \"\", this._hitLimit = !1;\n            }\n            put(e, t, i) {\n              this._hitLimit || (this._data += (0, s.utf32ToString)(e, t, i), this._data.length > n.PAYLOAD_LIMIT && (this._data = \"\", this._hitLimit = !0));\n            }\n            unhook(e) {\n              let t = !1;\n              if (this._hitLimit) t = !1;else if (e && (t = this._handler(this._data, this._params), t instanceof Promise)) return t.then(e => (this._params = a, this._data = \"\", this._hitLimit = !1, e));\n              return this._params = a, this._data = \"\", this._hitLimit = !1, t;\n            }\n          };\n        },\n        2015: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.EscapeSequenceParser = t.VT500_TRANSITION_TABLE = t.TransitionTable = void 0;\n          const s = i(844),\n            r = i(8273),\n            n = i(8742),\n            o = i(6242),\n            a = i(6351);\n          class h {\n            constructor(e) {\n              this.table = new Uint8Array(e);\n            }\n            setDefault(e, t) {\n              (0, r.fill)(this.table, e << 4 | t);\n            }\n            add(e, t, i, s) {\n              this.table[t << 8 | e] = i << 4 | s;\n            }\n            addMany(e, t, i, s) {\n              for (let r = 0; r < e.length; r++) this.table[t << 8 | e[r]] = i << 4 | s;\n            }\n          }\n          t.TransitionTable = h;\n          const c = 160;\n          t.VT500_TRANSITION_TABLE = function () {\n            const e = new h(4095),\n              t = Array.apply(null, Array(256)).map((e, t) => t),\n              i = (e, i) => t.slice(e, i),\n              s = i(32, 127),\n              r = i(0, 24);\n            r.push(25), r.push.apply(r, i(28, 32));\n            const n = i(0, 14);\n            let o;\n            for (o in e.setDefault(1, 0), e.addMany(s, 0, 2, 0), n) e.addMany([24, 26, 153, 154], o, 3, 0), e.addMany(i(128, 144), o, 3, 0), e.addMany(i(144, 152), o, 3, 0), e.add(156, o, 0, 0), e.add(27, o, 11, 1), e.add(157, o, 4, 8), e.addMany([152, 158, 159], o, 0, 7), e.add(155, o, 11, 3), e.add(144, o, 11, 9);\n            return e.addMany(r, 0, 3, 0), e.addMany(r, 1, 3, 1), e.add(127, 1, 0, 1), e.addMany(r, 8, 0, 8), e.addMany(r, 3, 3, 3), e.add(127, 3, 0, 3), e.addMany(r, 4, 3, 4), e.add(127, 4, 0, 4), e.addMany(r, 6, 3, 6), e.addMany(r, 5, 3, 5), e.add(127, 5, 0, 5), e.addMany(r, 2, 3, 2), e.add(127, 2, 0, 2), e.add(93, 1, 4, 8), e.addMany(s, 8, 5, 8), e.add(127, 8, 5, 8), e.addMany([156, 27, 24, 26, 7], 8, 6, 0), e.addMany(i(28, 32), 8, 0, 8), e.addMany([88, 94, 95], 1, 0, 7), e.addMany(s, 7, 0, 7), e.addMany(r, 7, 0, 7), e.add(156, 7, 0, 0), e.add(127, 7, 0, 7), e.add(91, 1, 11, 3), e.addMany(i(64, 127), 3, 7, 0), e.addMany(i(48, 60), 3, 8, 4), e.addMany([60, 61, 62, 63], 3, 9, 4), e.addMany(i(48, 60), 4, 8, 4), e.addMany(i(64, 127), 4, 7, 0), e.addMany([60, 61, 62, 63], 4, 0, 6), e.addMany(i(32, 64), 6, 0, 6), e.add(127, 6, 0, 6), e.addMany(i(64, 127), 6, 0, 0), e.addMany(i(32, 48), 3, 9, 5), e.addMany(i(32, 48), 5, 9, 5), e.addMany(i(48, 64), 5, 0, 6), e.addMany(i(64, 127), 5, 7, 0), e.addMany(i(32, 48), 4, 9, 5), e.addMany(i(32, 48), 1, 9, 2), e.addMany(i(32, 48), 2, 9, 2), e.addMany(i(48, 127), 2, 10, 0), e.addMany(i(48, 80), 1, 10, 0), e.addMany(i(81, 88), 1, 10, 0), e.addMany([89, 90, 92], 1, 10, 0), e.addMany(i(96, 127), 1, 10, 0), e.add(80, 1, 11, 9), e.addMany(r, 9, 0, 9), e.add(127, 9, 0, 9), e.addMany(i(28, 32), 9, 0, 9), e.addMany(i(32, 48), 9, 9, 12), e.addMany(i(48, 60), 9, 8, 10), e.addMany([60, 61, 62, 63], 9, 9, 10), e.addMany(r, 11, 0, 11), e.addMany(i(32, 128), 11, 0, 11), e.addMany(i(28, 32), 11, 0, 11), e.addMany(r, 10, 0, 10), e.add(127, 10, 0, 10), e.addMany(i(28, 32), 10, 0, 10), e.addMany(i(48, 60), 10, 8, 10), e.addMany([60, 61, 62, 63], 10, 0, 11), e.addMany(i(32, 48), 10, 9, 12), e.addMany(r, 12, 0, 12), e.add(127, 12, 0, 12), e.addMany(i(28, 32), 12, 0, 12), e.addMany(i(32, 48), 12, 9, 12), e.addMany(i(48, 64), 12, 0, 11), e.addMany(i(64, 127), 12, 12, 13), e.addMany(i(64, 127), 10, 12, 13), e.addMany(i(64, 127), 9, 12, 13), e.addMany(r, 13, 13, 13), e.addMany(s, 13, 13, 13), e.add(127, 13, 0, 13), e.addMany([27, 156, 24, 26], 13, 14, 0), e.add(c, 0, 2, 0), e.add(c, 8, 5, 8), e.add(c, 6, 0, 6), e.add(c, 11, 0, 11), e.add(c, 13, 13, 13), e;\n          }();\n          class l extends s.Disposable {\n            constructor(e = t.VT500_TRANSITION_TABLE) {\n              super(), this._transitions = e, this._parseStack = {\n                state: 0,\n                handlers: [],\n                handlerPos: 0,\n                transition: 0,\n                chunkPos: 0\n              }, this.initialState = 0, this.currentState = this.initialState, this._params = new n.Params(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0, this._printHandlerFb = (e, t, i) => {}, this._executeHandlerFb = e => {}, this._csiHandlerFb = (e, t) => {}, this._escHandlerFb = e => {}, this._errorHandlerFb = e => e, this._printHandler = this._printHandlerFb, this._executeHandlers = Object.create(null), this._csiHandlers = Object.create(null), this._escHandlers = Object.create(null), this._oscParser = new o.OscParser(), this._dcsParser = new a.DcsParser(), this._errorHandler = this._errorHandlerFb, this.registerEscHandler({\n                final: \"\\\\\"\n              }, () => !0);\n            }\n            _identifier(e, t = [64, 126]) {\n              let i = 0;\n              if (e.prefix) {\n                if (e.prefix.length > 1) throw new Error(\"only one byte as prefix supported\");\n                if (i = e.prefix.charCodeAt(0), i && 60 > i || i > 63) throw new Error(\"prefix must be in range 0x3c .. 0x3f\");\n              }\n              if (e.intermediates) {\n                if (e.intermediates.length > 2) throw new Error(\"only two bytes as intermediates are supported\");\n                for (let t = 0; t < e.intermediates.length; ++t) {\n                  const s = e.intermediates.charCodeAt(t);\n                  if (32 > s || s > 47) throw new Error(\"intermediate must be in range 0x20 .. 0x2f\");\n                  i <<= 8, i |= s;\n                }\n              }\n              if (1 !== e.final.length) throw new Error(\"final must be a single byte\");\n              const s = e.final.charCodeAt(0);\n              if (t[0] > s || s > t[1]) throw new Error(`final must be in range ${t[0]} .. ${t[1]}`);\n              return i <<= 8, i |= s, i;\n            }\n            identToString(e) {\n              const t = [];\n              for (; e;) t.push(String.fromCharCode(255 & e)), e >>= 8;\n              return t.reverse().join(\"\");\n            }\n            dispose() {\n              this._csiHandlers = Object.create(null), this._executeHandlers = Object.create(null), this._escHandlers = Object.create(null), this._oscParser.dispose(), this._dcsParser.dispose();\n            }\n            setPrintHandler(e) {\n              this._printHandler = e;\n            }\n            clearPrintHandler() {\n              this._printHandler = this._printHandlerFb;\n            }\n            registerEscHandler(e, t) {\n              const i = this._identifier(e, [48, 126]);\n              void 0 === this._escHandlers[i] && (this._escHandlers[i] = []);\n              const s = this._escHandlers[i];\n              return s.push(t), {\n                dispose: () => {\n                  const e = s.indexOf(t);\n                  -1 !== e && s.splice(e, 1);\n                }\n              };\n            }\n            clearEscHandler(e) {\n              this._escHandlers[this._identifier(e, [48, 126])] && delete this._escHandlers[this._identifier(e, [48, 126])];\n            }\n            setEscHandlerFallback(e) {\n              this._escHandlerFb = e;\n            }\n            setExecuteHandler(e, t) {\n              this._executeHandlers[e.charCodeAt(0)] = t;\n            }\n            clearExecuteHandler(e) {\n              this._executeHandlers[e.charCodeAt(0)] && delete this._executeHandlers[e.charCodeAt(0)];\n            }\n            setExecuteHandlerFallback(e) {\n              this._executeHandlerFb = e;\n            }\n            registerCsiHandler(e, t) {\n              const i = this._identifier(e);\n              void 0 === this._csiHandlers[i] && (this._csiHandlers[i] = []);\n              const s = this._csiHandlers[i];\n              return s.push(t), {\n                dispose: () => {\n                  const e = s.indexOf(t);\n                  -1 !== e && s.splice(e, 1);\n                }\n              };\n            }\n            clearCsiHandler(e) {\n              this._csiHandlers[this._identifier(e)] && delete this._csiHandlers[this._identifier(e)];\n            }\n            setCsiHandlerFallback(e) {\n              this._csiHandlerFb = e;\n            }\n            registerDcsHandler(e, t) {\n              return this._dcsParser.registerHandler(this._identifier(e), t);\n            }\n            clearDcsHandler(e) {\n              this._dcsParser.clearHandler(this._identifier(e));\n            }\n            setDcsHandlerFallback(e) {\n              this._dcsParser.setHandlerFallback(e);\n            }\n            registerOscHandler(e, t) {\n              return this._oscParser.registerHandler(e, t);\n            }\n            clearOscHandler(e) {\n              this._oscParser.clearHandler(e);\n            }\n            setOscHandlerFallback(e) {\n              this._oscParser.setHandlerFallback(e);\n            }\n            setErrorHandler(e) {\n              this._errorHandler = e;\n            }\n            clearErrorHandler() {\n              this._errorHandler = this._errorHandlerFb;\n            }\n            reset() {\n              this.currentState = this.initialState, this._oscParser.reset(), this._dcsParser.reset(), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0, 0 !== this._parseStack.state && (this._parseStack.state = 2, this._parseStack.handlers = []);\n            }\n            _preserveStack(e, t, i, s, r) {\n              this._parseStack.state = e, this._parseStack.handlers = t, this._parseStack.handlerPos = i, this._parseStack.transition = s, this._parseStack.chunkPos = r;\n            }\n            parse(e, t, i) {\n              let s,\n                r = 0,\n                n = 0,\n                o = 0;\n              if (this._parseStack.state) if (2 === this._parseStack.state) this._parseStack.state = 0, o = this._parseStack.chunkPos + 1;else {\n                if (void 0 === i || 1 === this._parseStack.state) throw this._parseStack.state = 1, new Error(\"improper continuation due to previous async handler, giving up parsing\");\n                const t = this._parseStack.handlers;\n                let n = this._parseStack.handlerPos - 1;\n                switch (this._parseStack.state) {\n                  case 3:\n                    if (!1 === i && n > -1) for (; n >= 0 && (s = t[n](this._params), !0 !== s); n--) if (s instanceof Promise) return this._parseStack.handlerPos = n, s;\n                    this._parseStack.handlers = [];\n                    break;\n                  case 4:\n                    if (!1 === i && n > -1) for (; n >= 0 && (s = t[n](), !0 !== s); n--) if (s instanceof Promise) return this._parseStack.handlerPos = n, s;\n                    this._parseStack.handlers = [];\n                    break;\n                  case 6:\n                    if (r = e[this._parseStack.chunkPos], s = this._dcsParser.unhook(24 !== r && 26 !== r, i), s) return s;\n                    27 === r && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;\n                    break;\n                  case 5:\n                    if (r = e[this._parseStack.chunkPos], s = this._oscParser.end(24 !== r && 26 !== r, i), s) return s;\n                    27 === r && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;\n                }\n                this._parseStack.state = 0, o = this._parseStack.chunkPos + 1, this.precedingCodepoint = 0, this.currentState = 15 & this._parseStack.transition;\n              }\n              for (let i = o; i < t; ++i) {\n                switch (r = e[i], n = this._transitions.table[this.currentState << 8 | (r < 160 ? r : c)], n >> 4) {\n                  case 2:\n                    for (let s = i + 1;; ++s) {\n                      if (s >= t || (r = e[s]) < 32 || r > 126 && r < c) {\n                        this._printHandler(e, i, s), i = s - 1;\n                        break;\n                      }\n                      if (++s >= t || (r = e[s]) < 32 || r > 126 && r < c) {\n                        this._printHandler(e, i, s), i = s - 1;\n                        break;\n                      }\n                      if (++s >= t || (r = e[s]) < 32 || r > 126 && r < c) {\n                        this._printHandler(e, i, s), i = s - 1;\n                        break;\n                      }\n                      if (++s >= t || (r = e[s]) < 32 || r > 126 && r < c) {\n                        this._printHandler(e, i, s), i = s - 1;\n                        break;\n                      }\n                    }\n                    break;\n                  case 3:\n                    this._executeHandlers[r] ? this._executeHandlers[r]() : this._executeHandlerFb(r), this.precedingCodepoint = 0;\n                    break;\n                  case 0:\n                    break;\n                  case 1:\n                    if (this._errorHandler({\n                      position: i,\n                      code: r,\n                      currentState: this.currentState,\n                      collect: this._collect,\n                      params: this._params,\n                      abort: !1\n                    }).abort) return;\n                    break;\n                  case 7:\n                    const o = this._csiHandlers[this._collect << 8 | r];\n                    let a = o ? o.length - 1 : -1;\n                    for (; a >= 0 && (s = o[a](this._params), !0 !== s); a--) if (s instanceof Promise) return this._preserveStack(3, o, a, n, i), s;\n                    a < 0 && this._csiHandlerFb(this._collect << 8 | r, this._params), this.precedingCodepoint = 0;\n                    break;\n                  case 8:\n                    do {\n                      switch (r) {\n                        case 59:\n                          this._params.addParam(0);\n                          break;\n                        case 58:\n                          this._params.addSubParam(-1);\n                          break;\n                        default:\n                          this._params.addDigit(r - 48);\n                      }\n                    } while (++i < t && (r = e[i]) > 47 && r < 60);\n                    i--;\n                    break;\n                  case 9:\n                    this._collect <<= 8, this._collect |= r;\n                    break;\n                  case 10:\n                    const h = this._escHandlers[this._collect << 8 | r];\n                    let l = h ? h.length - 1 : -1;\n                    for (; l >= 0 && (s = h[l](), !0 !== s); l--) if (s instanceof Promise) return this._preserveStack(4, h, l, n, i), s;\n                    l < 0 && this._escHandlerFb(this._collect << 8 | r), this.precedingCodepoint = 0;\n                    break;\n                  case 11:\n                    this._params.reset(), this._params.addParam(0), this._collect = 0;\n                    break;\n                  case 12:\n                    this._dcsParser.hook(this._collect << 8 | r, this._params);\n                    break;\n                  case 13:\n                    for (let s = i + 1;; ++s) if (s >= t || 24 === (r = e[s]) || 26 === r || 27 === r || r > 127 && r < c) {\n                      this._dcsParser.put(e, i, s), i = s - 1;\n                      break;\n                    }\n                    break;\n                  case 14:\n                    if (s = this._dcsParser.unhook(24 !== r && 26 !== r), s) return this._preserveStack(6, [], 0, n, i), s;\n                    27 === r && (n |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0;\n                    break;\n                  case 4:\n                    this._oscParser.start();\n                    break;\n                  case 5:\n                    for (let s = i + 1;; s++) if (s >= t || (r = e[s]) < 32 || r > 127 && r < c) {\n                      this._oscParser.put(e, i, s), i = s - 1;\n                      break;\n                    }\n                    break;\n                  case 6:\n                    if (s = this._oscParser.end(24 !== r && 26 !== r), s) return this._preserveStack(5, [], 0, n, i), s;\n                    27 === r && (n |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingCodepoint = 0;\n                }\n                this.currentState = 15 & n;\n              }\n            }\n          }\n          t.EscapeSequenceParser = l;\n        },\n        6242: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.OscHandler = t.OscParser = void 0;\n          const s = i(5770),\n            r = i(482),\n            n = [];\n          t.OscParser = class {\n            constructor() {\n              this._state = 0, this._active = n, this._id = -1, this._handlers = Object.create(null), this._handlerFb = () => {}, this._stack = {\n                paused: !1,\n                loopPosition: 0,\n                fallThrough: !1\n              };\n            }\n            registerHandler(e, t) {\n              void 0 === this._handlers[e] && (this._handlers[e] = []);\n              const i = this._handlers[e];\n              return i.push(t), {\n                dispose: () => {\n                  const e = i.indexOf(t);\n                  -1 !== e && i.splice(e, 1);\n                }\n              };\n            }\n            clearHandler(e) {\n              this._handlers[e] && delete this._handlers[e];\n            }\n            setHandlerFallback(e) {\n              this._handlerFb = e;\n            }\n            dispose() {\n              this._handlers = Object.create(null), this._handlerFb = () => {}, this._active = n;\n            }\n            reset() {\n              if (2 === this._state) for (let e = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; e >= 0; --e) this._active[e].end(!1);\n              this._stack.paused = !1, this._active = n, this._id = -1, this._state = 0;\n            }\n            _start() {\n              if (this._active = this._handlers[this._id] || n, this._active.length) for (let e = this._active.length - 1; e >= 0; e--) this._active[e].start();else this._handlerFb(this._id, \"START\");\n            }\n            _put(e, t, i) {\n              if (this._active.length) for (let s = this._active.length - 1; s >= 0; s--) this._active[s].put(e, t, i);else this._handlerFb(this._id, \"PUT\", (0, r.utf32ToString)(e, t, i));\n            }\n            start() {\n              this.reset(), this._state = 1;\n            }\n            put(e, t, i) {\n              if (3 !== this._state) {\n                if (1 === this._state) for (; t < i;) {\n                  const i = e[t++];\n                  if (59 === i) {\n                    this._state = 2, this._start();\n                    break;\n                  }\n                  if (i < 48 || 57 < i) return void (this._state = 3);\n                  -1 === this._id && (this._id = 0), this._id = 10 * this._id + i - 48;\n                }\n                2 === this._state && i - t > 0 && this._put(e, t, i);\n              }\n            }\n            end(e, t = !0) {\n              if (0 !== this._state) {\n                if (3 !== this._state) if (1 === this._state && this._start(), this._active.length) {\n                  let i = !1,\n                    s = this._active.length - 1,\n                    r = !1;\n                  if (this._stack.paused && (s = this._stack.loopPosition - 1, i = t, r = this._stack.fallThrough, this._stack.paused = !1), !r && !1 === i) {\n                    for (; s >= 0 && (i = this._active[s].end(e), !0 !== i); s--) if (i instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = s, this._stack.fallThrough = !1, i;\n                    s--;\n                  }\n                  for (; s >= 0; s--) if (i = this._active[s].end(!1), i instanceof Promise) return this._stack.paused = !0, this._stack.loopPosition = s, this._stack.fallThrough = !0, i;\n                } else this._handlerFb(this._id, \"END\", e);\n                this._active = n, this._id = -1, this._state = 0;\n              }\n            }\n          }, t.OscHandler = class {\n            constructor(e) {\n              this._handler = e, this._data = \"\", this._hitLimit = !1;\n            }\n            start() {\n              this._data = \"\", this._hitLimit = !1;\n            }\n            put(e, t, i) {\n              this._hitLimit || (this._data += (0, r.utf32ToString)(e, t, i), this._data.length > s.PAYLOAD_LIMIT && (this._data = \"\", this._hitLimit = !0));\n            }\n            end(e) {\n              let t = !1;\n              if (this._hitLimit) t = !1;else if (e && (t = this._handler(this._data), t instanceof Promise)) return t.then(e => (this._data = \"\", this._hitLimit = !1, e));\n              return this._data = \"\", this._hitLimit = !1, t;\n            }\n          };\n        },\n        8742: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.Params = void 0;\n          const i = 2147483647;\n          class s {\n            constructor(e = 32, t = 32) {\n              if (this.maxLength = e, this.maxSubParamsLength = t, t > 256) throw new Error(\"maxSubParamsLength must not be greater than 256\");\n              this.params = new Int32Array(e), this.length = 0, this._subParams = new Int32Array(t), this._subParamsLength = 0, this._subParamsIdx = new Uint16Array(e), this._rejectDigits = !1, this._rejectSubDigits = !1, this._digitIsSub = !1;\n            }\n            static fromArray(e) {\n              const t = new s();\n              if (!e.length) return t;\n              for (let i = Array.isArray(e[0]) ? 1 : 0; i < e.length; ++i) {\n                const s = e[i];\n                if (Array.isArray(s)) for (let e = 0; e < s.length; ++e) t.addSubParam(s[e]);else t.addParam(s);\n              }\n              return t;\n            }\n            clone() {\n              const e = new s(this.maxLength, this.maxSubParamsLength);\n              return e.params.set(this.params), e.length = this.length, e._subParams.set(this._subParams), e._subParamsLength = this._subParamsLength, e._subParamsIdx.set(this._subParamsIdx), e._rejectDigits = this._rejectDigits, e._rejectSubDigits = this._rejectSubDigits, e._digitIsSub = this._digitIsSub, e;\n            }\n            toArray() {\n              const e = [];\n              for (let t = 0; t < this.length; ++t) {\n                e.push(this.params[t]);\n                const i = this._subParamsIdx[t] >> 8,\n                  s = 255 & this._subParamsIdx[t];\n                s - i > 0 && e.push(Array.prototype.slice.call(this._subParams, i, s));\n              }\n              return e;\n            }\n            reset() {\n              this.length = 0, this._subParamsLength = 0, this._rejectDigits = !1, this._rejectSubDigits = !1, this._digitIsSub = !1;\n            }\n            addParam(e) {\n              if (this._digitIsSub = !1, this.length >= this.maxLength) this._rejectDigits = !0;else {\n                if (e < -1) throw new Error(\"values lesser than -1 are not allowed\");\n                this._subParamsIdx[this.length] = this._subParamsLength << 8 | this._subParamsLength, this.params[this.length++] = e > i ? i : e;\n              }\n            }\n            addSubParam(e) {\n              if (this._digitIsSub = !0, this.length) if (this._rejectDigits || this._subParamsLength >= this.maxSubParamsLength) this._rejectSubDigits = !0;else {\n                if (e < -1) throw new Error(\"values lesser than -1 are not allowed\");\n                this._subParams[this._subParamsLength++] = e > i ? i : e, this._subParamsIdx[this.length - 1]++;\n              }\n            }\n            hasSubParams(e) {\n              return (255 & this._subParamsIdx[e]) - (this._subParamsIdx[e] >> 8) > 0;\n            }\n            getSubParams(e) {\n              const t = this._subParamsIdx[e] >> 8,\n                i = 255 & this._subParamsIdx[e];\n              return i - t > 0 ? this._subParams.subarray(t, i) : null;\n            }\n            getSubParamsAll() {\n              const e = {};\n              for (let t = 0; t < this.length; ++t) {\n                const i = this._subParamsIdx[t] >> 8,\n                  s = 255 & this._subParamsIdx[t];\n                s - i > 0 && (e[t] = this._subParams.slice(i, s));\n              }\n              return e;\n            }\n            addDigit(e) {\n              let t;\n              if (this._rejectDigits || !(t = this._digitIsSub ? this._subParamsLength : this.length) || this._digitIsSub && this._rejectSubDigits) return;\n              const s = this._digitIsSub ? this._subParams : this.params,\n                r = s[t - 1];\n              s[t - 1] = ~r ? Math.min(10 * r + e, i) : e;\n            }\n          }\n          t.Params = s;\n        },\n        5741: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.AddonManager = void 0, t.AddonManager = class {\n            constructor() {\n              this._addons = [];\n            }\n            dispose() {\n              for (let e = this._addons.length - 1; e >= 0; e--) this._addons[e].instance.dispose();\n            }\n            loadAddon(e, t) {\n              const i = {\n                instance: t,\n                dispose: t.dispose,\n                isDisposed: !1\n              };\n              this._addons.push(i), t.dispose = () => this._wrappedAddonDispose(i), t.activate(e);\n            }\n            _wrappedAddonDispose(e) {\n              if (e.isDisposed) return;\n              let t = -1;\n              for (let i = 0; i < this._addons.length; i++) if (this._addons[i] === e) {\n                t = i;\n                break;\n              }\n              if (-1 === t) throw new Error(\"Could not dispose an addon that has not been loaded\");\n              e.isDisposed = !0, e.dispose.apply(e.instance), this._addons.splice(t, 1);\n            }\n          };\n        },\n        8771: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.BufferApiView = void 0;\n          const s = i(3785),\n            r = i(511);\n          t.BufferApiView = class {\n            constructor(e, t) {\n              this._buffer = e, this.type = t;\n            }\n            init(e) {\n              return this._buffer = e, this;\n            }\n            get cursorY() {\n              return this._buffer.y;\n            }\n            get cursorX() {\n              return this._buffer.x;\n            }\n            get viewportY() {\n              return this._buffer.ydisp;\n            }\n            get baseY() {\n              return this._buffer.ybase;\n            }\n            get length() {\n              return this._buffer.lines.length;\n            }\n            getLine(e) {\n              const t = this._buffer.lines.get(e);\n              if (t) return new s.BufferLineApiView(t);\n            }\n            getNullCell() {\n              return new r.CellData();\n            }\n          };\n        },\n        3785: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.BufferLineApiView = void 0;\n          const s = i(511);\n          t.BufferLineApiView = class {\n            constructor(e) {\n              this._line = e;\n            }\n            get isWrapped() {\n              return this._line.isWrapped;\n            }\n            get length() {\n              return this._line.length;\n            }\n            getCell(e, t) {\n              if (!(e < 0 || e >= this._line.length)) return t ? (this._line.loadCell(e, t), t) : this._line.loadCell(e, new s.CellData());\n            }\n            translateToString(e, t, i) {\n              return this._line.translateToString(e, t, i);\n            }\n          };\n        },\n        8285: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.BufferNamespaceApi = void 0;\n          const s = i(8771),\n            r = i(8460);\n          t.BufferNamespaceApi = class {\n            constructor(e) {\n              this._core = e, this._onBufferChange = new r.EventEmitter(), this._normal = new s.BufferApiView(this._core.buffers.normal, \"normal\"), this._alternate = new s.BufferApiView(this._core.buffers.alt, \"alternate\"), this._core.buffers.onBufferActivate(() => this._onBufferChange.fire(this.active));\n            }\n            get onBufferChange() {\n              return this._onBufferChange.event;\n            }\n            get active() {\n              if (this._core.buffers.active === this._core.buffers.normal) return this.normal;\n              if (this._core.buffers.active === this._core.buffers.alt) return this.alternate;\n              throw new Error(\"Active buffer is neither normal nor alternate\");\n            }\n            get normal() {\n              return this._normal.init(this._core.buffers.normal);\n            }\n            get alternate() {\n              return this._alternate.init(this._core.buffers.alt);\n            }\n          };\n        },\n        7975: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.ParserApi = void 0, t.ParserApi = class {\n            constructor(e) {\n              this._core = e;\n            }\n            registerCsiHandler(e, t) {\n              return this._core.registerCsiHandler(e, e => t(e.toArray()));\n            }\n            addCsiHandler(e, t) {\n              return this.registerCsiHandler(e, t);\n            }\n            registerDcsHandler(e, t) {\n              return this._core.registerDcsHandler(e, (e, i) => t(e, i.toArray()));\n            }\n            addDcsHandler(e, t) {\n              return this.registerDcsHandler(e, t);\n            }\n            registerEscHandler(e, t) {\n              return this._core.registerEscHandler(e, t);\n            }\n            addEscHandler(e, t) {\n              return this.registerEscHandler(e, t);\n            }\n            registerOscHandler(e, t) {\n              return this._core.registerOscHandler(e, t);\n            }\n            addOscHandler(e, t) {\n              return this.registerOscHandler(e, t);\n            }\n          };\n        },\n        7090: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.UnicodeApi = void 0, t.UnicodeApi = class {\n            constructor(e) {\n              this._core = e;\n            }\n            register(e) {\n              this._core.unicodeService.register(e);\n            }\n            get versions() {\n              return this._core.unicodeService.versions;\n            }\n            get activeVersion() {\n              return this._core.unicodeService.activeVersion;\n            }\n            set activeVersion(e) {\n              this._core.unicodeService.activeVersion = e;\n            }\n          };\n        },\n        744: function (e, t, i) {\n          var s = this && this.__decorate || function (e, t, i, s) {\n              var r,\n                n = arguments.length,\n                o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;\n              if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);else for (var a = e.length - 1; a >= 0; a--) (r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);\n              return n > 3 && o && Object.defineProperty(t, i, o), o;\n            },\n            r = this && this.__param || function (e, t) {\n              return function (i, s) {\n                t(i, s, e);\n              };\n            };\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.BufferService = t.MINIMUM_ROWS = t.MINIMUM_COLS = void 0;\n          const n = i(2585),\n            o = i(5295),\n            a = i(8460),\n            h = i(844);\n          t.MINIMUM_COLS = 2, t.MINIMUM_ROWS = 1;\n          let c = class extends h.Disposable {\n            constructor(e) {\n              super(), this.isUserScrolling = !1, this._onResize = new a.EventEmitter(), this._onScroll = new a.EventEmitter(), this.cols = Math.max(e.rawOptions.cols || 0, t.MINIMUM_COLS), this.rows = Math.max(e.rawOptions.rows || 0, t.MINIMUM_ROWS), this.buffers = new o.BufferSet(e, this);\n            }\n            get onResize() {\n              return this._onResize.event;\n            }\n            get onScroll() {\n              return this._onScroll.event;\n            }\n            get buffer() {\n              return this.buffers.active;\n            }\n            dispose() {\n              super.dispose(), this.buffers.dispose();\n            }\n            resize(e, t) {\n              this.cols = e, this.rows = t, this.buffers.resize(e, t), this.buffers.setupTabStops(this.cols), this._onResize.fire({\n                cols: e,\n                rows: t\n              });\n            }\n            reset() {\n              this.buffers.reset(), this.isUserScrolling = !1;\n            }\n            scroll(e, t = !1) {\n              const i = this.buffer;\n              let s;\n              s = this._cachedBlankLine, s && s.length === this.cols && s.getFg(0) === e.fg && s.getBg(0) === e.bg || (s = i.getBlankLine(e, t), this._cachedBlankLine = s), s.isWrapped = t;\n              const r = i.ybase + i.scrollTop,\n                n = i.ybase + i.scrollBottom;\n              if (0 === i.scrollTop) {\n                const e = i.lines.isFull;\n                n === i.lines.length - 1 ? e ? i.lines.recycle().copyFrom(s) : i.lines.push(s.clone()) : i.lines.splice(n + 1, 0, s.clone()), e ? this.isUserScrolling && (i.ydisp = Math.max(i.ydisp - 1, 0)) : (i.ybase++, this.isUserScrolling || i.ydisp++);\n              } else {\n                const e = n - r + 1;\n                i.lines.shiftElements(r + 1, e - 1, -1), i.lines.set(n, s.clone());\n              }\n              this.isUserScrolling || (i.ydisp = i.ybase), this._onScroll.fire(i.ydisp);\n            }\n            scrollLines(e, t, i) {\n              const s = this.buffer;\n              if (e < 0) {\n                if (0 === s.ydisp) return;\n                this.isUserScrolling = !0;\n              } else e + s.ydisp >= s.ybase && (this.isUserScrolling = !1);\n              const r = s.ydisp;\n              s.ydisp = Math.max(Math.min(s.ydisp + e, s.ybase), 0), r !== s.ydisp && (t || this._onScroll.fire(s.ydisp));\n            }\n            scrollPages(e) {\n              this.scrollLines(e * (this.rows - 1));\n            }\n            scrollToTop() {\n              this.scrollLines(-this.buffer.ydisp);\n            }\n            scrollToBottom() {\n              this.scrollLines(this.buffer.ybase - this.buffer.ydisp);\n            }\n            scrollToLine(e) {\n              const t = e - this.buffer.ydisp;\n              0 !== t && this.scrollLines(t);\n            }\n          };\n          c = s([r(0, n.IOptionsService)], c), t.BufferService = c;\n        },\n        7994: (e, t) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.CharsetService = void 0, t.CharsetService = class {\n            constructor() {\n              this.glevel = 0, this._charsets = [];\n            }\n            reset() {\n              this.charset = void 0, this._charsets = [], this.glevel = 0;\n            }\n            setgLevel(e) {\n              this.glevel = e, this.charset = this._charsets[e];\n            }\n            setgCharset(e, t) {\n              this._charsets[e] = t, this.glevel === e && (this.charset = t);\n            }\n          };\n        },\n        1753: function (e, t, i) {\n          var s = this && this.__decorate || function (e, t, i, s) {\n              var r,\n                n = arguments.length,\n                o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;\n              if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);else for (var a = e.length - 1; a >= 0; a--) (r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);\n              return n > 3 && o && Object.defineProperty(t, i, o), o;\n            },\n            r = this && this.__param || function (e, t) {\n              return function (i, s) {\n                t(i, s, e);\n              };\n            };\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.CoreMouseService = void 0;\n          const n = i(2585),\n            o = i(8460),\n            a = {\n              NONE: {\n                events: 0,\n                restrict: () => !1\n              },\n              X10: {\n                events: 1,\n                restrict: e => 4 !== e.button && 1 === e.action && (e.ctrl = !1, e.alt = !1, e.shift = !1, !0)\n              },\n              VT200: {\n                events: 19,\n                restrict: e => 32 !== e.action\n              },\n              DRAG: {\n                events: 23,\n                restrict: e => 32 !== e.action || 3 !== e.button\n              },\n              ANY: {\n                events: 31,\n                restrict: e => !0\n              }\n            };\n          function h(e, t) {\n            let i = (e.ctrl ? 16 : 0) | (e.shift ? 4 : 0) | (e.alt ? 8 : 0);\n            return 4 === e.button ? (i |= 64, i |= e.action) : (i |= 3 & e.button, 4 & e.button && (i |= 64), 8 & e.button && (i |= 128), 32 === e.action ? i |= 32 : 0 !== e.action || t || (i |= 3)), i;\n          }\n          const c = String.fromCharCode,\n            l = {\n              DEFAULT: e => {\n                const t = [h(e, !1) + 32, e.col + 32, e.row + 32];\n                return t[0] > 255 || t[1] > 255 || t[2] > 255 ? \"\" : `\u001b[M${c(t[0])}${c(t[1])}${c(t[2])}`;\n              },\n              SGR: e => {\n                const t = 0 === e.action && 4 !== e.button ? \"m\" : \"M\";\n                return `\u001b[<${h(e, !0)};${e.col};${e.row}${t}`;\n              },\n              SGR_PIXELS: e => {\n                const t = 0 === e.action && 4 !== e.button ? \"m\" : \"M\";\n                return `\u001b[<${h(e, !0)};${e.x};${e.y}${t}`;\n              }\n            };\n          let d = class {\n            constructor(e, t) {\n              this._bufferService = e, this._coreService = t, this._protocols = {}, this._encodings = {}, this._activeProtocol = \"\", this._activeEncoding = \"\", this._onProtocolChange = new o.EventEmitter(), this._lastEvent = null;\n              for (const e of Object.keys(a)) this.addProtocol(e, a[e]);\n              for (const e of Object.keys(l)) this.addEncoding(e, l[e]);\n              this.reset();\n            }\n            addProtocol(e, t) {\n              this._protocols[e] = t;\n            }\n            addEncoding(e, t) {\n              this._encodings[e] = t;\n            }\n            get activeProtocol() {\n              return this._activeProtocol;\n            }\n            get areMouseEventsActive() {\n              return 0 !== this._protocols[this._activeProtocol].events;\n            }\n            set activeProtocol(e) {\n              if (!this._protocols[e]) throw new Error(`unknown protocol \"${e}\"`);\n              this._activeProtocol = e, this._onProtocolChange.fire(this._protocols[e].events);\n            }\n            get activeEncoding() {\n              return this._activeEncoding;\n            }\n            set activeEncoding(e) {\n              if (!this._encodings[e]) throw new Error(`unknown encoding \"${e}\"`);\n              this._activeEncoding = e;\n            }\n            reset() {\n              this.activeProtocol = \"NONE\", this.activeEncoding = \"DEFAULT\", this._lastEvent = null;\n            }\n            get onProtocolChange() {\n              return this._onProtocolChange.event;\n            }\n            triggerMouseEvent(e) {\n              if (e.col < 0 || e.col >= this._bufferService.cols || e.row < 0 || e.row >= this._bufferService.rows) return !1;\n              if (4 === e.button && 32 === e.action) return !1;\n              if (3 === e.button && 32 !== e.action) return !1;\n              if (4 !== e.button && (2 === e.action || 3 === e.action)) return !1;\n              if (e.col++, e.row++, 32 === e.action && this._lastEvent && this._equalEvents(this._lastEvent, e, \"SGR_PIXELS\" === this._activeEncoding)) return !1;\n              if (!this._protocols[this._activeProtocol].restrict(e)) return !1;\n              const t = this._encodings[this._activeEncoding](e);\n              return t && (\"DEFAULT\" === this._activeEncoding ? this._coreService.triggerBinaryEvent(t) : this._coreService.triggerDataEvent(t, !0)), this._lastEvent = e, !0;\n            }\n            explainEvents(e) {\n              return {\n                down: !!(1 & e),\n                up: !!(2 & e),\n                drag: !!(4 & e),\n                move: !!(8 & e),\n                wheel: !!(16 & e)\n              };\n            }\n            _equalEvents(e, t, i) {\n              if (i) {\n                if (e.x !== t.x) return !1;\n                if (e.y !== t.y) return !1;\n              } else {\n                if (e.col !== t.col) return !1;\n                if (e.row !== t.row) return !1;\n              }\n              return e.button === t.button && e.action === t.action && e.ctrl === t.ctrl && e.alt === t.alt && e.shift === t.shift;\n            }\n          };\n          d = s([r(0, n.IBufferService), r(1, n.ICoreService)], d), t.CoreMouseService = d;\n        },\n        6975: function (e, t, i) {\n          var s = this && this.__decorate || function (e, t, i, s) {\n              var r,\n                n = arguments.length,\n                o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;\n              if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);else for (var a = e.length - 1; a >= 0; a--) (r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);\n              return n > 3 && o && Object.defineProperty(t, i, o), o;\n            },\n            r = this && this.__param || function (e, t) {\n              return function (i, s) {\n                t(i, s, e);\n              };\n            };\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.CoreService = void 0;\n          const n = i(2585),\n            o = i(8460),\n            a = i(1439),\n            h = i(844),\n            c = Object.freeze({\n              insertMode: !1\n            }),\n            l = Object.freeze({\n              applicationCursorKeys: !1,\n              applicationKeypad: !1,\n              bracketedPasteMode: !1,\n              origin: !1,\n              reverseWraparound: !1,\n              sendFocus: !1,\n              wraparound: !0\n            });\n          let d = class extends h.Disposable {\n            constructor(e, t, i, s) {\n              super(), this._bufferService = t, this._logService = i, this._optionsService = s, this.isCursorInitialized = !1, this.isCursorHidden = !1, this._onData = this.register(new o.EventEmitter()), this._onUserInput = this.register(new o.EventEmitter()), this._onBinary = this.register(new o.EventEmitter()), this._scrollToBottom = e, this.register({\n                dispose: () => this._scrollToBottom = void 0\n              }), this.modes = (0, a.clone)(c), this.decPrivateModes = (0, a.clone)(l);\n            }\n            get onData() {\n              return this._onData.event;\n            }\n            get onUserInput() {\n              return this._onUserInput.event;\n            }\n            get onBinary() {\n              return this._onBinary.event;\n            }\n            reset() {\n              this.modes = (0, a.clone)(c), this.decPrivateModes = (0, a.clone)(l);\n            }\n            triggerDataEvent(e, t = !1) {\n              if (this._optionsService.rawOptions.disableStdin) return;\n              const i = this._bufferService.buffer;\n              i.ybase !== i.ydisp && this._scrollToBottom(), t && this._onUserInput.fire(), this._logService.debug(`sending data \"${e}\"`, () => e.split(\"\").map(e => e.charCodeAt(0))), this._onData.fire(e);\n            }\n            triggerBinaryEvent(e) {\n              this._optionsService.rawOptions.disableStdin || (this._logService.debug(`sending binary \"${e}\"`, () => e.split(\"\").map(e => e.charCodeAt(0))), this._onBinary.fire(e));\n            }\n          };\n          d = s([r(1, n.IBufferService), r(2, n.ILogService), r(3, n.IOptionsService)], d), t.CoreService = d;\n        },\n        9074: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.DecorationService = void 0;\n          const s = i(8055),\n            r = i(8460),\n            n = i(844),\n            o = i(6106),\n            a = {\n              xmin: 0,\n              xmax: 0\n            };\n          class h extends n.Disposable {\n            constructor() {\n              super(...arguments), this._decorations = new o.SortedList(e => null == e ? void 0 : e.marker.line), this._onDecorationRegistered = this.register(new r.EventEmitter()), this._onDecorationRemoved = this.register(new r.EventEmitter());\n            }\n            get onDecorationRegistered() {\n              return this._onDecorationRegistered.event;\n            }\n            get onDecorationRemoved() {\n              return this._onDecorationRemoved.event;\n            }\n            get decorations() {\n              return this._decorations.values();\n            }\n            registerDecoration(e) {\n              if (e.marker.isDisposed) return;\n              const t = new c(e);\n              if (t) {\n                const e = t.marker.onDispose(() => t.dispose());\n                t.onDispose(() => {\n                  t && (this._decorations.delete(t) && this._onDecorationRemoved.fire(t), e.dispose());\n                }), this._decorations.insert(t), this._onDecorationRegistered.fire(t);\n              }\n              return t;\n            }\n            reset() {\n              for (const e of this._decorations.values()) e.dispose();\n              this._decorations.clear();\n            }\n            *getDecorationsAtCell(e, t, i) {\n              var s, r, n;\n              let o = 0,\n                a = 0;\n              for (const h of this._decorations.getKeyIterator(t)) o = null !== (s = h.options.x) && void 0 !== s ? s : 0, a = o + (null !== (r = h.options.width) && void 0 !== r ? r : 1), e >= o && e < a && (!i || (null !== (n = h.options.layer) && void 0 !== n ? n : \"bottom\") === i) && (yield h);\n            }\n            forEachDecorationAtCell(e, t, i, s) {\n              this._decorations.forEachByKey(t, t => {\n                var r, n, o;\n                a.xmin = null !== (r = t.options.x) && void 0 !== r ? r : 0, a.xmax = a.xmin + (null !== (n = t.options.width) && void 0 !== n ? n : 1), e >= a.xmin && e < a.xmax && (!i || (null !== (o = t.options.layer) && void 0 !== o ? o : \"bottom\") === i) && s(t);\n              });\n            }\n            dispose() {\n              for (const e of this._decorations.values()) this._onDecorationRemoved.fire(e);\n              this.reset();\n            }\n          }\n          t.DecorationService = h;\n          class c extends n.Disposable {\n            constructor(e) {\n              super(), this.options = e, this.isDisposed = !1, this.onRenderEmitter = this.register(new r.EventEmitter()), this.onRender = this.onRenderEmitter.event, this._onDispose = this.register(new r.EventEmitter()), this.onDispose = this._onDispose.event, this._cachedBg = null, this._cachedFg = null, this.marker = e.marker, this.options.overviewRulerOptions && !this.options.overviewRulerOptions.position && (this.options.overviewRulerOptions.position = \"full\");\n            }\n            get backgroundColorRGB() {\n              return null === this._cachedBg && (this.options.backgroundColor ? this._cachedBg = s.css.toColor(this.options.backgroundColor) : this._cachedBg = void 0), this._cachedBg;\n            }\n            get foregroundColorRGB() {\n              return null === this._cachedFg && (this.options.foregroundColor ? this._cachedFg = s.css.toColor(this.options.foregroundColor) : this._cachedFg = void 0), this._cachedFg;\n            }\n            dispose() {\n              this._isDisposed || (this._isDisposed = !0, this._onDispose.fire(), super.dispose());\n            }\n          }\n        },\n        3730: function (e, t, i) {\n          var s = this && this.__decorate || function (e, t, i, s) {\n              var r,\n                n = arguments.length,\n                o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;\n              if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);else for (var a = e.length - 1; a >= 0; a--) (r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);\n              return n > 3 && o && Object.defineProperty(t, i, o), o;\n            },\n            r = this && this.__param || function (e, t) {\n              return function (i, s) {\n                t(i, s, e);\n              };\n            };\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.DirtyRowService = void 0;\n          const n = i(2585);\n          let o = class {\n            constructor(e) {\n              this._bufferService = e, this.clearRange();\n            }\n            get start() {\n              return this._start;\n            }\n            get end() {\n              return this._end;\n            }\n            clearRange() {\n              this._start = this._bufferService.buffer.y, this._end = this._bufferService.buffer.y;\n            }\n            markDirty(e) {\n              e < this._start ? this._start = e : e > this._end && (this._end = e);\n            }\n            markRangeDirty(e, t) {\n              if (e > t) {\n                const i = e;\n                e = t, t = i;\n              }\n              e < this._start && (this._start = e), t > this._end && (this._end = t);\n            }\n            markAllDirty() {\n              this.markRangeDirty(0, this._bufferService.rows - 1);\n            }\n          };\n          o = s([r(0, n.IBufferService)], o), t.DirtyRowService = o;\n        },\n        4348: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.InstantiationService = t.ServiceCollection = void 0;\n          const s = i(2585),\n            r = i(8343);\n          class n {\n            constructor(...e) {\n              this._entries = new Map();\n              for (const [t, i] of e) this.set(t, i);\n            }\n            set(e, t) {\n              const i = this._entries.get(e);\n              return this._entries.set(e, t), i;\n            }\n            forEach(e) {\n              this._entries.forEach((t, i) => e(i, t));\n            }\n            has(e) {\n              return this._entries.has(e);\n            }\n            get(e) {\n              return this._entries.get(e);\n            }\n          }\n          t.ServiceCollection = n, t.InstantiationService = class {\n            constructor() {\n              this._services = new n(), this._services.set(s.IInstantiationService, this);\n            }\n            setService(e, t) {\n              this._services.set(e, t);\n            }\n            getService(e) {\n              return this._services.get(e);\n            }\n            createInstance(e, ...t) {\n              const i = (0, r.getServiceDependencies)(e).sort((e, t) => e.index - t.index),\n                s = [];\n              for (const t of i) {\n                const i = this._services.get(t.id);\n                if (!i) throw new Error(`[createInstance] ${e.name} depends on UNKNOWN service ${t.id}.`);\n                s.push(i);\n              }\n              const n = i.length > 0 ? i[0].index : t.length;\n              if (t.length !== n) throw new Error(`[createInstance] First service dependency of ${e.name} at position ${n + 1} conflicts with ${t.length} static arguments`);\n              return new e(...[...t, ...s]);\n            }\n          };\n        },\n        7866: function (e, t, i) {\n          var s = this && this.__decorate || function (e, t, i, s) {\n              var r,\n                n = arguments.length,\n                o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;\n              if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);else for (var a = e.length - 1; a >= 0; a--) (r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);\n              return n > 3 && o && Object.defineProperty(t, i, o), o;\n            },\n            r = this && this.__param || function (e, t) {\n              return function (i, s) {\n                t(i, s, e);\n              };\n            };\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.LogService = void 0;\n          const n = i(2585),\n            o = {\n              debug: n.LogLevelEnum.DEBUG,\n              info: n.LogLevelEnum.INFO,\n              warn: n.LogLevelEnum.WARN,\n              error: n.LogLevelEnum.ERROR,\n              off: n.LogLevelEnum.OFF\n            };\n          let a = class {\n            constructor(e) {\n              this._optionsService = e, this.logLevel = n.LogLevelEnum.OFF, this._updateLogLevel(), this._optionsService.onOptionChange(e => {\n                \"logLevel\" === e && this._updateLogLevel();\n              });\n            }\n            _updateLogLevel() {\n              this.logLevel = o[this._optionsService.rawOptions.logLevel];\n            }\n            _evalLazyOptionalParams(e) {\n              for (let t = 0; t < e.length; t++) \"function\" == typeof e[t] && (e[t] = e[t]());\n            }\n            _log(e, t, i) {\n              this._evalLazyOptionalParams(i), e.call(console, \"xterm.js: \" + t, ...i);\n            }\n            debug(e, ...t) {\n              this.logLevel <= n.LogLevelEnum.DEBUG && this._log(console.log, e, t);\n            }\n            info(e, ...t) {\n              this.logLevel <= n.LogLevelEnum.INFO && this._log(console.info, e, t);\n            }\n            warn(e, ...t) {\n              this.logLevel <= n.LogLevelEnum.WARN && this._log(console.warn, e, t);\n            }\n            error(e, ...t) {\n              this.logLevel <= n.LogLevelEnum.ERROR && this._log(console.error, e, t);\n            }\n          };\n          a = s([r(0, n.IOptionsService)], a), t.LogService = a;\n        },\n        7302: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.OptionsService = t.DEFAULT_OPTIONS = void 0;\n          const s = i(8460),\n            r = i(6114);\n          t.DEFAULT_OPTIONS = {\n            cols: 80,\n            rows: 24,\n            cursorBlink: !1,\n            cursorStyle: \"block\",\n            cursorWidth: 1,\n            customGlyphs: !0,\n            drawBoldTextInBrightColors: !0,\n            fastScrollModifier: \"alt\",\n            fastScrollSensitivity: 5,\n            fontFamily: \"courier-new, courier, monospace\",\n            fontSize: 15,\n            fontWeight: \"normal\",\n            fontWeightBold: \"bold\",\n            lineHeight: 1,\n            letterSpacing: 0,\n            linkHandler: null,\n            logLevel: \"info\",\n            scrollback: 1e3,\n            scrollSensitivity: 1,\n            screenReaderMode: !1,\n            smoothScrollDuration: 0,\n            macOptionIsMeta: !1,\n            macOptionClickForcesSelection: !1,\n            minimumContrastRatio: 1,\n            disableStdin: !1,\n            allowProposedApi: !1,\n            allowTransparency: !1,\n            tabStopWidth: 8,\n            theme: {},\n            rightClickSelectsWord: r.isMac,\n            windowOptions: {},\n            windowsMode: !1,\n            wordSeparator: \" ()[]{}',\\\"`\",\n            altClickMovesCursor: !0,\n            convertEol: !1,\n            termName: \"xterm\",\n            cancelEvents: !1,\n            overviewRulerWidth: 0\n          };\n          const n = [\"normal\", \"bold\", \"100\", \"200\", \"300\", \"400\", \"500\", \"600\", \"700\", \"800\", \"900\"];\n          t.OptionsService = class {\n            constructor(e) {\n              this._onOptionChange = new s.EventEmitter();\n              const i = Object.assign({}, t.DEFAULT_OPTIONS);\n              for (const t in e) if (t in i) try {\n                const s = e[t];\n                i[t] = this._sanitizeAndValidateOption(t, s);\n              } catch (e) {\n                console.error(e);\n              }\n              this.rawOptions = i, this.options = Object.assign({}, i), this._setupOptions();\n            }\n            get onOptionChange() {\n              return this._onOptionChange.event;\n            }\n            _setupOptions() {\n              const e = e => {\n                  if (!(e in t.DEFAULT_OPTIONS)) throw new Error(`No option with key \"${e}\"`);\n                  return this.rawOptions[e];\n                },\n                i = (e, i) => {\n                  if (!(e in t.DEFAULT_OPTIONS)) throw new Error(`No option with key \"${e}\"`);\n                  i = this._sanitizeAndValidateOption(e, i), this.rawOptions[e] !== i && (this.rawOptions[e] = i, this._onOptionChange.fire(e));\n                };\n              for (const t in this.rawOptions) {\n                const s = {\n                  get: e.bind(this, t),\n                  set: i.bind(this, t)\n                };\n                Object.defineProperty(this.options, t, s);\n              }\n            }\n            _sanitizeAndValidateOption(e, i) {\n              switch (e) {\n                case \"cursorStyle\":\n                  if (i || (i = t.DEFAULT_OPTIONS[e]), !function (e) {\n                    return \"block\" === e || \"underline\" === e || \"bar\" === e;\n                  }(i)) throw new Error(`\"${i}\" is not a valid value for ${e}`);\n                  break;\n                case \"wordSeparator\":\n                  i || (i = t.DEFAULT_OPTIONS[e]);\n                  break;\n                case \"fontWeight\":\n                case \"fontWeightBold\":\n                  if (\"number\" == typeof i && 1 <= i && i <= 1e3) break;\n                  i = n.includes(i) ? i : t.DEFAULT_OPTIONS[e];\n                  break;\n                case \"cursorWidth\":\n                  i = Math.floor(i);\n                case \"lineHeight\":\n                case \"tabStopWidth\":\n                  if (i < 1) throw new Error(`${e} cannot be less than 1, value: ${i}`);\n                  break;\n                case \"minimumContrastRatio\":\n                  i = Math.max(1, Math.min(21, Math.round(10 * i) / 10));\n                  break;\n                case \"scrollback\":\n                  if ((i = Math.min(i, 4294967295)) < 0) throw new Error(`${e} cannot be less than 0, value: ${i}`);\n                  break;\n                case \"fastScrollSensitivity\":\n                case \"scrollSensitivity\":\n                  if (i <= 0) throw new Error(`${e} cannot be less than or equal to 0, value: ${i}`);\n                case \"rows\":\n                case \"cols\":\n                  if (!i && 0 !== i) throw new Error(`${e} must be numeric, value: ${i}`);\n              }\n              return i;\n            }\n          };\n        },\n        2660: function (e, t, i) {\n          var s = this && this.__decorate || function (e, t, i, s) {\n              var r,\n                n = arguments.length,\n                o = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;\n              if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) o = Reflect.decorate(e, t, i, s);else for (var a = e.length - 1; a >= 0; a--) (r = e[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, i, o) : r(t, i)) || o);\n              return n > 3 && o && Object.defineProperty(t, i, o), o;\n            },\n            r = this && this.__param || function (e, t) {\n              return function (i, s) {\n                t(i, s, e);\n              };\n            };\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.OscLinkService = void 0;\n          const n = i(2585);\n          let o = class {\n            constructor(e) {\n              this._bufferService = e, this._nextId = 1, this._entriesWithId = new Map(), this._dataByLinkId = new Map();\n            }\n            registerLink(e) {\n              const t = this._bufferService.buffer;\n              if (void 0 === e.id) {\n                const i = t.addMarker(t.ybase + t.y),\n                  s = {\n                    data: e,\n                    id: this._nextId++,\n                    lines: [i]\n                  };\n                return i.onDispose(() => this._removeMarkerFromLink(s, i)), this._dataByLinkId.set(s.id, s), s.id;\n              }\n              const i = e,\n                s = this._getEntryIdKey(i),\n                r = this._entriesWithId.get(s);\n              if (r) return this.addLineToLink(r.id, t.ybase + t.y), r.id;\n              const n = t.addMarker(t.ybase + t.y),\n                o = {\n                  id: this._nextId++,\n                  key: this._getEntryIdKey(i),\n                  data: i,\n                  lines: [n]\n                };\n              return n.onDispose(() => this._removeMarkerFromLink(o, n)), this._entriesWithId.set(o.key, o), this._dataByLinkId.set(o.id, o), o.id;\n            }\n            addLineToLink(e, t) {\n              const i = this._dataByLinkId.get(e);\n              if (i && i.lines.every(e => e.line !== t)) {\n                const e = this._bufferService.buffer.addMarker(t);\n                i.lines.push(e), e.onDispose(() => this._removeMarkerFromLink(i, e));\n              }\n            }\n            getLinkData(e) {\n              var t;\n              return null === (t = this._dataByLinkId.get(e)) || void 0 === t ? void 0 : t.data;\n            }\n            _getEntryIdKey(e) {\n              return `${e.id};;${e.uri}`;\n            }\n            _removeMarkerFromLink(e, t) {\n              const i = e.lines.indexOf(t);\n              -1 !== i && (e.lines.splice(i, 1), 0 === e.lines.length && (void 0 !== e.data.id && this._entriesWithId.delete(e.key), this._dataByLinkId.delete(e.id)));\n            }\n          };\n          o = s([r(0, n.IBufferService)], o), t.OscLinkService = o;\n        },\n        8343: (e, t) => {\n          function i(e, t, i) {\n            t.di$target === t ? t.di$dependencies.push({\n              id: e,\n              index: i\n            }) : (t.di$dependencies = [{\n              id: e,\n              index: i\n            }], t.di$target = t);\n          }\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.createDecorator = t.getServiceDependencies = t.serviceRegistry = void 0, t.serviceRegistry = new Map(), t.getServiceDependencies = function (e) {\n            return e.di$dependencies || [];\n          }, t.createDecorator = function (e) {\n            if (t.serviceRegistry.has(e)) return t.serviceRegistry.get(e);\n            const s = function (e, t, r) {\n              if (3 !== arguments.length) throw new Error(\"@IServiceName-decorator can only be used to decorate a parameter\");\n              i(s, e, r);\n            };\n            return s.toString = () => e, t.serviceRegistry.set(e, s), s;\n          };\n        },\n        2585: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.IDecorationService = t.IUnicodeService = t.IOscLinkService = t.IOptionsService = t.ILogService = t.LogLevelEnum = t.IInstantiationService = t.IDirtyRowService = t.ICharsetService = t.ICoreService = t.ICoreMouseService = t.IBufferService = void 0;\n          const s = i(8343);\n          var r;\n          t.IBufferService = (0, s.createDecorator)(\"BufferService\"), t.ICoreMouseService = (0, s.createDecorator)(\"CoreMouseService\"), t.ICoreService = (0, s.createDecorator)(\"CoreService\"), t.ICharsetService = (0, s.createDecorator)(\"CharsetService\"), t.IDirtyRowService = (0, s.createDecorator)(\"DirtyRowService\"), t.IInstantiationService = (0, s.createDecorator)(\"InstantiationService\"), (r = t.LogLevelEnum || (t.LogLevelEnum = {}))[r.DEBUG = 0] = \"DEBUG\", r[r.INFO = 1] = \"INFO\", r[r.WARN = 2] = \"WARN\", r[r.ERROR = 3] = \"ERROR\", r[r.OFF = 4] = \"OFF\", t.ILogService = (0, s.createDecorator)(\"LogService\"), t.IOptionsService = (0, s.createDecorator)(\"OptionsService\"), t.IOscLinkService = (0, s.createDecorator)(\"OscLinkService\"), t.IUnicodeService = (0, s.createDecorator)(\"UnicodeService\"), t.IDecorationService = (0, s.createDecorator)(\"DecorationService\");\n        },\n        1480: (e, t, i) => {\n          Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          }), t.UnicodeService = void 0;\n          const s = i(8460),\n            r = i(225);\n          t.UnicodeService = class {\n            constructor() {\n              this._providers = Object.create(null), this._active = \"\", this._onChange = new s.EventEmitter();\n              const e = new r.UnicodeV6();\n              this.register(e), this._active = e.version, this._activeProvider = e;\n            }\n            get onChange() {\n              return this._onChange.event;\n            }\n            get versions() {\n              return Object.keys(this._providers);\n            }\n            get activeVersion() {\n              return this._active;\n            }\n            set activeVersion(e) {\n              if (!this._providers[e]) throw new Error(`unknown Unicode version \"${e}\"`);\n              this._active = e, this._activeProvider = this._providers[e], this._onChange.fire(e);\n            }\n            register(e) {\n              this._providers[e.version] = e;\n            }\n            wcwidth(e) {\n              return this._activeProvider.wcwidth(e);\n            }\n            getStringCellWidth(e) {\n              let t = 0;\n              const i = e.length;\n              for (let s = 0; s < i; ++s) {\n                let r = e.charCodeAt(s);\n                if (55296 <= r && r <= 56319) {\n                  if (++s >= i) return t + this.wcwidth(r);\n                  const n = e.charCodeAt(s);\n                  56320 <= n && n <= 57343 ? r = 1024 * (r - 55296) + n - 56320 + 65536 : t += this.wcwidth(n);\n                }\n                t += this.wcwidth(r);\n              }\n              return t;\n            }\n          };\n        }\n      },\n      t = {};\n    function i(s) {\n      var r = t[s];\n      if (void 0 !== r) return r.exports;\n      var n = t[s] = {\n        exports: {}\n      };\n      return e[s].call(n.exports, n, n.exports, i), n.exports;\n    }\n    var s = {};\n    return (() => {\n      var e = s;\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      }), e.Terminal = void 0;\n      const t = i(3236),\n        r = i(9042),\n        n = i(7975),\n        o = i(7090),\n        a = i(5741),\n        h = i(8285),\n        c = [\"cols\", \"rows\"];\n      e.Terminal = class {\n        constructor(e) {\n          this._core = new t.Terminal(e), this._addonManager = new a.AddonManager(), this._publicOptions = Object.assign({}, this._core.options);\n          const i = e => this._core.options[e],\n            s = (e, t) => {\n              this._checkReadonlyOptions(e), this._core.options[e] = t;\n            };\n          for (const e in this._core.options) {\n            const t = {\n              get: i.bind(this, e),\n              set: s.bind(this, e)\n            };\n            Object.defineProperty(this._publicOptions, e, t);\n          }\n        }\n        _checkReadonlyOptions(e) {\n          if (c.includes(e)) throw new Error(`Option \"${e}\" can only be set in the constructor`);\n        }\n        _checkProposedApi() {\n          if (!this._core.optionsService.rawOptions.allowProposedApi) throw new Error(\"You must set the allowProposedApi option to true to use proposed API\");\n        }\n        get onBell() {\n          return this._core.onBell;\n        }\n        get onBinary() {\n          return this._core.onBinary;\n        }\n        get onCursorMove() {\n          return this._core.onCursorMove;\n        }\n        get onData() {\n          return this._core.onData;\n        }\n        get onKey() {\n          return this._core.onKey;\n        }\n        get onLineFeed() {\n          return this._core.onLineFeed;\n        }\n        get onRender() {\n          return this._core.onRender;\n        }\n        get onResize() {\n          return this._core.onResize;\n        }\n        get onScroll() {\n          return this._core.onScroll;\n        }\n        get onSelectionChange() {\n          return this._core.onSelectionChange;\n        }\n        get onTitleChange() {\n          return this._core.onTitleChange;\n        }\n        get onWriteParsed() {\n          return this._core.onWriteParsed;\n        }\n        get element() {\n          return this._core.element;\n        }\n        get parser() {\n          return this._checkProposedApi(), this._parser || (this._parser = new n.ParserApi(this._core)), this._parser;\n        }\n        get unicode() {\n          return this._checkProposedApi(), new o.UnicodeApi(this._core);\n        }\n        get textarea() {\n          return this._core.textarea;\n        }\n        get rows() {\n          return this._core.rows;\n        }\n        get cols() {\n          return this._core.cols;\n        }\n        get buffer() {\n          return this._checkProposedApi(), this._buffer || (this._buffer = new h.BufferNamespaceApi(this._core)), this._buffer;\n        }\n        get markers() {\n          return this._checkProposedApi(), this._core.markers;\n        }\n        get modes() {\n          const e = this._core.coreService.decPrivateModes;\n          let t = \"none\";\n          switch (this._core.coreMouseService.activeProtocol) {\n            case \"X10\":\n              t = \"x10\";\n              break;\n            case \"VT200\":\n              t = \"vt200\";\n              break;\n            case \"DRAG\":\n              t = \"drag\";\n              break;\n            case \"ANY\":\n              t = \"any\";\n          }\n          return {\n            applicationCursorKeysMode: e.applicationCursorKeys,\n            applicationKeypadMode: e.applicationKeypad,\n            bracketedPasteMode: e.bracketedPasteMode,\n            insertMode: this._core.coreService.modes.insertMode,\n            mouseTrackingMode: t,\n            originMode: e.origin,\n            reverseWraparoundMode: e.reverseWraparound,\n            sendFocusMode: e.sendFocus,\n            wraparoundMode: e.wraparound\n          };\n        }\n        get options() {\n          return this._publicOptions;\n        }\n        set options(e) {\n          for (const t in e) this._publicOptions[t] = e[t];\n        }\n        blur() {\n          this._core.blur();\n        }\n        focus() {\n          this._core.focus();\n        }\n        resize(e, t) {\n          this._verifyIntegers(e, t), this._core.resize(e, t);\n        }\n        open(e) {\n          this._core.open(e);\n        }\n        attachCustomKeyEventHandler(e) {\n          this._core.attachCustomKeyEventHandler(e);\n        }\n        registerLinkProvider(e) {\n          return this._checkProposedApi(), this._core.registerLinkProvider(e);\n        }\n        registerCharacterJoiner(e) {\n          return this._checkProposedApi(), this._core.registerCharacterJoiner(e);\n        }\n        deregisterCharacterJoiner(e) {\n          this._checkProposedApi(), this._core.deregisterCharacterJoiner(e);\n        }\n        registerMarker(e = 0) {\n          return this._verifyIntegers(e), this._core.addMarker(e);\n        }\n        registerDecoration(e) {\n          var t, i, s;\n          return this._checkProposedApi(), this._verifyPositiveIntegers(null !== (t = e.x) && void 0 !== t ? t : 0, null !== (i = e.width) && void 0 !== i ? i : 0, null !== (s = e.height) && void 0 !== s ? s : 0), this._core.registerDecoration(e);\n        }\n        hasSelection() {\n          return this._core.hasSelection();\n        }\n        select(e, t, i) {\n          this._verifyIntegers(e, t, i), this._core.select(e, t, i);\n        }\n        getSelection() {\n          return this._core.getSelection();\n        }\n        getSelectionPosition() {\n          return this._core.getSelectionPosition();\n        }\n        clearSelection() {\n          this._core.clearSelection();\n        }\n        selectAll() {\n          this._core.selectAll();\n        }\n        selectLines(e, t) {\n          this._verifyIntegers(e, t), this._core.selectLines(e, t);\n        }\n        dispose() {\n          this._addonManager.dispose(), this._core.dispose();\n        }\n        scrollLines(e) {\n          this._verifyIntegers(e), this._core.scrollLines(e);\n        }\n        scrollPages(e) {\n          this._verifyIntegers(e), this._core.scrollPages(e);\n        }\n        scrollToTop() {\n          this._core.scrollToTop();\n        }\n        scrollToBottom() {\n          this._core.scrollToBottom();\n        }\n        scrollToLine(e) {\n          this._verifyIntegers(e), this._core.scrollToLine(e);\n        }\n        clear() {\n          this._core.clear();\n        }\n        write(e, t) {\n          this._core.write(e, t);\n        }\n        writeln(e, t) {\n          this._core.write(e), this._core.write(\"\\r\\n\", t);\n        }\n        paste(e) {\n          this._core.paste(e);\n        }\n        refresh(e, t) {\n          this._verifyIntegers(e, t), this._core.refresh(e, t);\n        }\n        reset() {\n          this._core.reset();\n        }\n        clearTextureAtlas() {\n          this._core.clearTextureAtlas();\n        }\n        loadAddon(e) {\n          return this._addonManager.loadAddon(this, e);\n        }\n        static get strings() {\n          return r;\n        }\n        _verifyIntegers(...e) {\n          for (const t of e) if (t === 1 / 0 || isNaN(t) || t % 1 != 0) throw new Error(\"This API only accepts integers\");\n        }\n        _verifyPositiveIntegers(...e) {\n          for (const t of e) if (t && (t === 1 / 0 || isNaN(t) || t % 1 != 0 || t < 0)) throw new Error(\"This API only accepts positive integers\");\n        }\n      };\n    })(), s;\n  })();\n});\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/xterm/lib/xterm.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!./node_modules/xterm/css/xterm.css":
/*!****************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!./node_modules/xterm/css/xterm.css ***!
  \****************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/**\\n * Copyright (c) 2014 The xterm.js authors. All rights reserved.\\n * Copyright (c) 2012-2013, Christopher Jeffrey (MIT License)\\n * https://github.com/chjj/term.js\\n * @license MIT\\n *\\n * Permission is hereby granted, free of charge, to any person obtaining a copy\\n * of this software and associated documentation files (the \\\"Software\\\"), to deal\\n * in the Software without restriction, including without limitation the rights\\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the Software is\\n * furnished to do so, subject to the following conditions:\\n *\\n * The above copyright notice and this permission notice shall be included in\\n * all copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n * THE SOFTWARE.\\n *\\n * Originally forked from (with the author's permission):\\n *   Fabrice Bellard's javascript vt100 for jslinux:\\n *   http://bellard.org/jslinux/\\n *   Copyright (c) 2011 Fabrice Bellard\\n *   The original design remains. The terminal itself\\n *   has been extended to include xterm CSI codes, among\\n *   other features.\\n */\\n\\n/**\\n *  Default styles for xterm.js\\n */\\n\\n.xterm {\\n    cursor: text;\\n    position: relative;\\n    -moz-user-select: none;\\n         user-select: none;\\n    -ms-user-select: none;\\n    -webkit-user-select: none;\\n}\\n\\n.xterm.focus,\\n.xterm:focus {\\n    outline: none;\\n}\\n\\n.xterm .xterm-helpers {\\n    position: absolute;\\n    top: 0;\\n    /**\\n     * The z-index of the helpers must be higher than the canvases in order for\\n     * IMEs to appear on top.\\n     */\\n    z-index: 5;\\n}\\n\\n.xterm .xterm-helper-textarea {\\n    padding: 0;\\n    border: 0;\\n    margin: 0;\\n    /* Move textarea out of the screen to the far left, so that the cursor is not visible */\\n    position: absolute;\\n    opacity: 0;\\n    left: -9999em;\\n    top: 0;\\n    width: 0;\\n    height: 0;\\n    z-index: -5;\\n    /** Prevent wrapping so the IME appears against the textarea at the correct position */\\n    white-space: nowrap;\\n    overflow: hidden;\\n    resize: none;\\n}\\n\\n.xterm .composition-view {\\n    /* TODO: Composition position got messed up somewhere */\\n    background: #000;\\n    color: #FFF;\\n    display: none;\\n    position: absolute;\\n    white-space: nowrap;\\n    z-index: 1;\\n}\\n\\n.xterm .composition-view.active {\\n    display: block;\\n}\\n\\n.xterm .xterm-viewport {\\n    /* On OS X this is required in order for the scroll bar to appear fully opaque */\\n    background-color: #000;\\n    overflow-y: scroll;\\n    cursor: default;\\n    position: absolute;\\n    right: 0;\\n    left: 0;\\n    top: 0;\\n    bottom: 0;\\n}\\n\\n.xterm .xterm-screen {\\n    position: relative;\\n}\\n\\n.xterm .xterm-screen canvas {\\n    position: absolute;\\n    left: 0;\\n    top: 0;\\n}\\n\\n.xterm .xterm-scroll-area {\\n    visibility: hidden;\\n}\\n\\n.xterm-char-measure-element {\\n    display: inline-block;\\n    visibility: hidden;\\n    position: absolute;\\n    top: 0;\\n    left: -9999em;\\n    line-height: normal;\\n}\\n\\n.xterm.enable-mouse-events {\\n    /* When mouse events are enabled (eg. tmux), revert to the standard pointer cursor */\\n    cursor: default;\\n}\\n\\n.xterm.xterm-cursor-pointer,\\n.xterm .xterm-cursor-pointer {\\n    cursor: pointer;\\n}\\n\\n.xterm.column-select.focus {\\n    /* Column selection mode */\\n    cursor: crosshair;\\n}\\n\\n.xterm .xterm-accessibility,\\n.xterm .xterm-message {\\n    position: absolute;\\n    left: 0;\\n    top: 0;\\n    bottom: 0;\\n    right: 0;\\n    z-index: 10;\\n    color: transparent;\\n}\\n\\n.xterm .live-region {\\n    position: absolute;\\n    left: -9999px;\\n    width: 1px;\\n    height: 1px;\\n    overflow: hidden;\\n}\\n\\n.xterm-dim {\\n    opacity: 0.5;\\n}\\n\\n.xterm-underline-1 { text-decoration: underline; }\\n.xterm-underline-2 { -webkit-text-decoration: double underline; text-decoration: double underline; }\\n.xterm-underline-3 { -webkit-text-decoration: wavy underline; text-decoration: wavy underline; }\\n.xterm-underline-4 { -webkit-text-decoration: dotted underline; text-decoration: dotted underline; }\\n.xterm-underline-5 { -webkit-text-decoration: dashed underline; text-decoration: dashed underline; }\\n\\n.xterm-strikethrough {\\n    text-decoration: line-through;\\n}\\n\\n.xterm-screen .xterm-decoration-container .xterm-decoration {\\n\\tz-index: 6;\\n\\tposition: absolute;\\n}\\n\\n.xterm-decoration-overview-ruler {\\n    z-index: 7;\\n    position: absolute;\\n    top: 0;\\n    right: 0;\\n    pointer-events: none;\\n}\\n\\n.xterm-decoration-top {\\n    z-index: 2;\\n    position: relative;\\n}\\n\", \"\"]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/xterm/css/xterm.css?./node_modules/css-loader/dist/cjs.js??clonedRuleSet-14.use%5B1%5D!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-14.use%5B2%5D");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ (function(module) {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ (function(module) {

"use strict";
eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./node_modules/xterm/css/xterm.css":
/*!******************************************!*\
  !*** ./node_modules/xterm/css/xterm.css ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(/*! !!../../css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!../../postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!./xterm.css */ \"./node_modules/css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!./node_modules/xterm/css/xterm.css\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = (__webpack_require__(/*! !../../vue-style-loader/lib/addStylesClient.js */ \"./node_modules/vue-style-loader/lib/addStylesClient.js\")[\"default\"])\nvar update = add(\"1acb0214\", content, false, {\"sourceMap\":false,\"shadowMode\":false});\n// Hot Module Replacement\nif(false) {}\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/xterm/css/xterm.css?");

/***/ }),

/***/ "./node_modules/vue-style-loader/lib/addStylesClient.js":
/*!**************************************************************!*\
  !*** ./node_modules/vue-style-loader/lib/addStylesClient.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ addStylesClient; }\n/* harmony export */ });\n/* harmony import */ var _listToStyles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./listToStyles */ \"./node_modules/vue-style-loader/lib/listToStyles.js\");\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\n\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\nvar options = null\nvar ssrIdKey = 'data-vue-ssr-id'\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nfunction addStylesClient (parentId, list, _isProduction, _options) {\n  isProduction = _isProduction\n\n  options = _options || {}\n\n  var styles = (0,_listToStyles__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = (0,_listToStyles__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[' + ssrIdKey + '~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n  if (options.ssrId) {\n    styleElement.setAttribute(ssrIdKey, obj.id)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/vue-style-loader/lib/addStylesClient.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/a-callable.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/a-callable.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\nvar tryToString = __webpack_require__(/*! ../internals/try-to-string */ \"./node_modules/core-js/internals/try-to-string.js\");\n\nvar $TypeError = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nmodule.exports = function (argument) {\n  if (isCallable(argument)) return argument;\n  throw new $TypeError(tryToString(argument) + ' is not a function');\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/a-callable.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/a-possible-prototype.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/a-possible-prototype.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar isPossiblePrototype = __webpack_require__(/*! ../internals/is-possible-prototype */ \"./node_modules/core-js/internals/is-possible-prototype.js\");\n\nvar $String = String;\nvar $TypeError = TypeError;\n\nmodule.exports = function (argument) {\n  if (isPossiblePrototype(argument)) return argument;\n  throw new $TypeError(\"Can't set \" + $String(argument) + ' as a prototype');\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/a-possible-prototype.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/an-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/an-object.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar isObject = __webpack_require__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n\nvar $String = String;\nvar $TypeError = TypeError;\n\n// `Assert: Type(argument) is Object`\nmodule.exports = function (argument) {\n  if (isObject(argument)) return argument;\n  throw new $TypeError($String(argument) + ' is not an object');\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/an-object.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/array-buffer-basic-detection.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/internals/array-buffer-basic-detection.js ***!
  \************************************************************************/
/***/ (function(module) {

"use strict";
eval("\n// eslint-disable-next-line es/no-typed-arrays -- safe\nmodule.exports = typeof ArrayBuffer != 'undefined' && typeof DataView != 'undefined';\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/array-buffer-basic-detection.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/array-buffer-view-core.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/array-buffer-view-core.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar NATIVE_ARRAY_BUFFER = __webpack_require__(/*! ../internals/array-buffer-basic-detection */ \"./node_modules/core-js/internals/array-buffer-basic-detection.js\");\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar global = __webpack_require__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ \"./node_modules/core-js/internals/has-own-property.js\");\nvar classof = __webpack_require__(/*! ../internals/classof */ \"./node_modules/core-js/internals/classof.js\");\nvar tryToString = __webpack_require__(/*! ../internals/try-to-string */ \"./node_modules/core-js/internals/try-to-string.js\");\nvar createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\nvar defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ \"./node_modules/core-js/internals/define-built-in.js\");\nvar defineBuiltInAccessor = __webpack_require__(/*! ../internals/define-built-in-accessor */ \"./node_modules/core-js/internals/define-built-in-accessor.js\");\nvar isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ \"./node_modules/core-js/internals/object-is-prototype-of.js\");\nvar getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ \"./node_modules/core-js/internals/object-get-prototype-of.js\");\nvar setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ \"./node_modules/core-js/internals/object-set-prototype-of.js\");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\nvar uid = __webpack_require__(/*! ../internals/uid */ \"./node_modules/core-js/internals/uid.js\");\nvar InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ \"./node_modules/core-js/internals/internal-state.js\");\n\nvar enforceInternalState = InternalStateModule.enforce;\nvar getInternalState = InternalStateModule.get;\nvar Int8Array = global.Int8Array;\nvar Int8ArrayPrototype = Int8Array && Int8Array.prototype;\nvar Uint8ClampedArray = global.Uint8ClampedArray;\nvar Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;\nvar TypedArray = Int8Array && getPrototypeOf(Int8Array);\nvar TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);\nvar ObjectPrototype = Object.prototype;\nvar TypeError = global.TypeError;\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');\nvar TYPED_ARRAY_CONSTRUCTOR = 'TypedArrayConstructor';\n// Fixing native typed arrays in Opera Presto crashes the browser, see #595\nvar NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';\nvar TYPED_ARRAY_TAG_REQUIRED = false;\nvar NAME, Constructor, Prototype;\n\nvar TypedArrayConstructorsList = {\n  Int8Array: 1,\n  Uint8Array: 1,\n  Uint8ClampedArray: 1,\n  Int16Array: 2,\n  Uint16Array: 2,\n  Int32Array: 4,\n  Uint32Array: 4,\n  Float32Array: 4,\n  Float64Array: 8\n};\n\nvar BigIntArrayConstructorsList = {\n  BigInt64Array: 8,\n  BigUint64Array: 8\n};\n\nvar isView = function isView(it) {\n  if (!isObject(it)) return false;\n  var klass = classof(it);\n  return klass === 'DataView'\n    || hasOwn(TypedArrayConstructorsList, klass)\n    || hasOwn(BigIntArrayConstructorsList, klass);\n};\n\nvar getTypedArrayConstructor = function (it) {\n  var proto = getPrototypeOf(it);\n  if (!isObject(proto)) return;\n  var state = getInternalState(proto);\n  return (state && hasOwn(state, TYPED_ARRAY_CONSTRUCTOR)) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);\n};\n\nvar isTypedArray = function (it) {\n  if (!isObject(it)) return false;\n  var klass = classof(it);\n  return hasOwn(TypedArrayConstructorsList, klass)\n    || hasOwn(BigIntArrayConstructorsList, klass);\n};\n\nvar aTypedArray = function (it) {\n  if (isTypedArray(it)) return it;\n  throw new TypeError('Target is not a typed array');\n};\n\nvar aTypedArrayConstructor = function (C) {\n  if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C))) return C;\n  throw new TypeError(tryToString(C) + ' is not a typed array constructor');\n};\n\nvar exportTypedArrayMethod = function (KEY, property, forced, options) {\n  if (!DESCRIPTORS) return;\n  if (forced) for (var ARRAY in TypedArrayConstructorsList) {\n    var TypedArrayConstructor = global[ARRAY];\n    if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY)) try {\n      delete TypedArrayConstructor.prototype[KEY];\n    } catch (error) {\n      // old WebKit bug - some methods are non-configurable\n      try {\n        TypedArrayConstructor.prototype[KEY] = property;\n      } catch (error2) { /* empty */ }\n    }\n  }\n  if (!TypedArrayPrototype[KEY] || forced) {\n    defineBuiltIn(TypedArrayPrototype, KEY, forced ? property\n      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);\n  }\n};\n\nvar exportTypedArrayStaticMethod = function (KEY, property, forced) {\n  var ARRAY, TypedArrayConstructor;\n  if (!DESCRIPTORS) return;\n  if (setPrototypeOf) {\n    if (forced) for (ARRAY in TypedArrayConstructorsList) {\n      TypedArrayConstructor = global[ARRAY];\n      if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY)) try {\n        delete TypedArrayConstructor[KEY];\n      } catch (error) { /* empty */ }\n    }\n    if (!TypedArray[KEY] || forced) {\n      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable\n      try {\n        return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);\n      } catch (error) { /* empty */ }\n    } else return;\n  }\n  for (ARRAY in TypedArrayConstructorsList) {\n    TypedArrayConstructor = global[ARRAY];\n    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {\n      defineBuiltIn(TypedArrayConstructor, KEY, property);\n    }\n  }\n};\n\nfor (NAME in TypedArrayConstructorsList) {\n  Constructor = global[NAME];\n  Prototype = Constructor && Constructor.prototype;\n  if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;\n  else NATIVE_ARRAY_BUFFER_VIEWS = false;\n}\n\nfor (NAME in BigIntArrayConstructorsList) {\n  Constructor = global[NAME];\n  Prototype = Constructor && Constructor.prototype;\n  if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;\n}\n\n// WebKit bug - typed arrays constructors prototype is Object.prototype\nif (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {\n  // eslint-disable-next-line no-shadow -- safe\n  TypedArray = function TypedArray() {\n    throw new TypeError('Incorrect invocation');\n  };\n  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {\n    if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);\n  }\n}\n\nif (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {\n  TypedArrayPrototype = TypedArray.prototype;\n  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {\n    if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);\n  }\n}\n\n// WebKit bug - one more object in Uint8ClampedArray prototype chain\nif (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {\n  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);\n}\n\nif (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {\n  TYPED_ARRAY_TAG_REQUIRED = true;\n  defineBuiltInAccessor(TypedArrayPrototype, TO_STRING_TAG, {\n    configurable: true,\n    get: function () {\n      return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;\n    }\n  });\n  for (NAME in TypedArrayConstructorsList) if (global[NAME]) {\n    createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);\n  }\n}\n\nmodule.exports = {\n  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,\n  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,\n  aTypedArray: aTypedArray,\n  aTypedArrayConstructor: aTypedArrayConstructor,\n  exportTypedArrayMethod: exportTypedArrayMethod,\n  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,\n  getTypedArrayConstructor: getTypedArrayConstructor,\n  isView: isView,\n  isTypedArray: isTypedArray,\n  TypedArray: TypedArray,\n  TypedArrayPrototype: TypedArrayPrototype\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/array-buffer-view-core.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/array-from-constructor-and-list.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/internals/array-from-constructor-and-list.js ***!
  \***************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ \"./node_modules/core-js/internals/length-of-array-like.js\");\n\nmodule.exports = function (Constructor, list, $length) {\n  var index = 0;\n  var length = arguments.length > 2 ? $length : lengthOfArrayLike(list);\n  var result = new Constructor(length);\n  while (length > index) result[index] = list[index++];\n  return result;\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/array-from-constructor-and-list.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/array-includes.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-includes.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\nvar toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ \"./node_modules/core-js/internals/to-absolute-index.js\");\nvar lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ \"./node_modules/core-js/internals/length-of-array-like.js\");\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = lengthOfArrayLike(O);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el !== el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value !== value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/array-includes.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/array-set-length.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/array-set-length.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar isArray = __webpack_require__(/*! ../internals/is-array */ \"./node_modules/core-js/internals/is-array.js\");\n\nvar $TypeError = TypeError;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Safari < 13 does not throw an error in this case\nvar SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function () {\n  // makes no sense without proper strict mode support\n  if (this !== undefined) return true;\n  try {\n    // eslint-disable-next-line es/no-object-defineproperty -- safe\n    Object.defineProperty([], 'length', { writable: false }).length = 1;\n  } catch (error) {\n    return error instanceof TypeError;\n  }\n}();\n\nmodule.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function (O, length) {\n  if (isArray(O) && !getOwnPropertyDescriptor(O, 'length').writable) {\n    throw new $TypeError('Cannot set read only .length');\n  } return O.length = length;\n} : function (O, length) {\n  return O.length = length;\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/array-set-length.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/array-to-reversed.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/array-to-reversed.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ \"./node_modules/core-js/internals/length-of-array-like.js\");\n\n// https://tc39.es/proposal-change-array-by-copy/#sec-array.prototype.toReversed\n// https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toReversed\nmodule.exports = function (O, C) {\n  var len = lengthOfArrayLike(O);\n  var A = new C(len);\n  var k = 0;\n  for (; k < len; k++) A[k] = O[len - k - 1];\n  return A;\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/array-to-reversed.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/array-with.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/array-with.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ \"./node_modules/core-js/internals/length-of-array-like.js\");\nvar toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ \"./node_modules/core-js/internals/to-integer-or-infinity.js\");\n\nvar $RangeError = RangeError;\n\n// https://tc39.es/proposal-change-array-by-copy/#sec-array.prototype.with\n// https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.with\nmodule.exports = function (O, C, index, value) {\n  var len = lengthOfArrayLike(O);\n  var relativeIndex = toIntegerOrInfinity(index);\n  var actualIndex = relativeIndex < 0 ? len + relativeIndex : relativeIndex;\n  if (actualIndex >= len || actualIndex < 0) throw new $RangeError('Incorrect index');\n  var A = new C(len);\n  var k = 0;\n  for (; k < len; k++) A[k] = k === actualIndex ? value : O[k];\n  return A;\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/array-with.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/classof-raw.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/classof-raw.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ \"./node_modules/core-js/internals/function-uncurry-this.js\");\n\nvar toString = uncurryThis({}.toString);\nvar stringSlice = uncurryThis(''.slice);\n\nmodule.exports = function (it) {\n  return stringSlice(toString(it), 8, -1);\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/classof-raw.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/classof.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/classof.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ \"./node_modules/core-js/internals/to-string-tag-support.js\");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\nvar classofRaw = __webpack_require__(/*! ../internals/classof-raw */ \"./node_modules/core-js/internals/classof-raw.js\");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar $Object = Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) === 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nmodule.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) === 'Object' && isCallable(O.callee) ? 'Arguments' : result;\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/classof.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/copy-constructor-properties.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ \"./node_modules/core-js/internals/has-own-property.js\");\nvar ownKeys = __webpack_require__(/*! ../internals/own-keys */ \"./node_modules/core-js/internals/own-keys.js\");\nvar getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ \"./node_modules/core-js/internals/object-get-own-property-descriptor.js\");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\n\nmodule.exports = function (target, source, exceptions) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {\n      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  }\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/copy-constructor-properties.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/correct-prototype-getter.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/correct-prototype-getter.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n\nmodule.exports = !fails(function () {\n  function F() { /* empty */ }\n  F.prototype.constructor = null;\n  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing\n  return Object.getPrototypeOf(new F()) !== F.prototype;\n});\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/correct-prototype-getter.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/create-non-enumerable-property.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/create-non-enumerable-property.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\nvar createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ \"./node_modules/core-js/internals/create-property-descriptor.js\");\n\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/create-non-enumerable-property.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/create-property-descriptor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!
  \**********************************************************************/
/***/ (function(module) {

"use strict";
eval("\nmodule.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/create-property-descriptor.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/define-built-in-accessor.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/define-built-in-accessor.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar makeBuiltIn = __webpack_require__(/*! ../internals/make-built-in */ \"./node_modules/core-js/internals/make-built-in.js\");\nvar defineProperty = __webpack_require__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\n\nmodule.exports = function (target, name, descriptor) {\n  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });\n  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });\n  return defineProperty.f(target, name, descriptor);\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/define-built-in-accessor.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/define-built-in.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/define-built-in.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\nvar makeBuiltIn = __webpack_require__(/*! ../internals/make-built-in */ \"./node_modules/core-js/internals/make-built-in.js\");\nvar defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ \"./node_modules/core-js/internals/define-global-property.js\");\n\nmodule.exports = function (O, key, value, options) {\n  if (!options) options = {};\n  var simple = options.enumerable;\n  var name = options.name !== undefined ? options.name : key;\n  if (isCallable(value)) makeBuiltIn(value, name, options);\n  if (options.global) {\n    if (simple) O[key] = value;\n    else defineGlobalProperty(key, value);\n  } else {\n    try {\n      if (!options.unsafe) delete O[key];\n      else if (O[key]) simple = true;\n    } catch (error) { /* empty */ }\n    if (simple) O[key] = value;\n    else definePropertyModule.f(O, key, {\n      value: value,\n      enumerable: false,\n      configurable: !options.nonConfigurable,\n      writable: !options.nonWritable\n    });\n  } return O;\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/define-built-in.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/define-global-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/define-global-property.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar global = __webpack_require__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar defineProperty = Object.defineProperty;\n\nmodule.exports = function (key, value) {\n  try {\n    defineProperty(global, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global[key] = value;\n  } return value;\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/define-global-property.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/descriptors.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/descriptors.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n\n// Detect IE8's incomplete defineProperty implementation\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;\n});\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/descriptors.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/document-create-element.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/document-create-element.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar global = __webpack_require__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n\nvar document = global.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS = isObject(document) && isObject(document.createElement);\n\nmodule.exports = function (it) {\n  return EXISTS ? document.createElement(it) : {};\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/document-create-element.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/does-not-exceed-safe-integer.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/internals/does-not-exceed-safe-integer.js ***!
  \************************************************************************/
/***/ (function(module) {

"use strict";
eval("\nvar $TypeError = TypeError;\nvar MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991\n\nmodule.exports = function (it) {\n  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');\n  return it;\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/does-not-exceed-safe-integer.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/engine-user-agent.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-user-agent.js ***!
  \*************************************************************/
/***/ (function(module) {

"use strict";
eval("\nmodule.exports = typeof navigator != 'undefined' && String(navigator.userAgent) || '';\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/engine-user-agent.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/engine-v8-version.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-v8-version.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar global = __webpack_require__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\nvar userAgent = __webpack_require__(/*! ../internals/engine-user-agent */ \"./node_modules/core-js/internals/engine-user-agent.js\");\n\nvar process = global.process;\nvar Deno = global.Deno;\nvar versions = process && process.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent) {\n  match = userAgent.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nmodule.exports = version;\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/engine-v8-version.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/enum-bug-keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!
  \*********************************************************/
/***/ (function(module) {

"use strict";
eval("\n// IE8- don't enum bug keys\nmodule.exports = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/enum-bug-keys.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/export.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/export.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar global = __webpack_require__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\nvar getOwnPropertyDescriptor = (__webpack_require__(/*! ../internals/object-get-own-property-descriptor */ \"./node_modules/core-js/internals/object-get-own-property-descriptor.js\").f);\nvar createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\nvar defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ \"./node_modules/core-js/internals/define-built-in.js\");\nvar defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ \"./node_modules/core-js/internals/define-global-property.js\");\nvar copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ \"./node_modules/core-js/internals/copy-constructor-properties.js\");\nvar isForced = __webpack_require__(/*! ../internals/is-forced */ \"./node_modules/core-js/internals/is-forced.js\");\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global;\n  } else if (STATIC) {\n    target = global[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = (global[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(sourceProperty, 'sham', true);\n    }\n    defineBuiltIn(target, key, sourceProperty, options);\n  }\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/export.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/fails.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/internals/fails.js ***!
  \*************************************************/
/***/ (function(module) {

"use strict";
eval("\nmodule.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/fails.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/function-bind-native.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-bind-native.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es/no-function-prototype-bind -- safe\n  var test = (function () { /* empty */ }).bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/function-bind-native.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/function-call.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/function-call.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ \"./node_modules/core-js/internals/function-bind-native.js\");\n\nvar call = Function.prototype.call;\n\nmodule.exports = NATIVE_BIND ? call.bind(call) : function () {\n  return call.apply(call, arguments);\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/function-call.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/function-name.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/function-name.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ \"./node_modules/core-js/internals/has-own-property.js\");\n\nvar FunctionPrototype = Function.prototype;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn(FunctionPrototype, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));\n\nmodule.exports = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/function-name.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/function-uncurry-this-accessor.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/function-uncurry-this-accessor.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ \"./node_modules/core-js/internals/function-uncurry-this.js\");\nvar aCallable = __webpack_require__(/*! ../internals/a-callable */ \"./node_modules/core-js/internals/a-callable.js\");\n\nmodule.exports = function (object, key, method) {\n  try {\n    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n    return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));\n  } catch (error) { /* empty */ }\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/function-uncurry-this-accessor.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/function-uncurry-this.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-uncurry-this.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ \"./node_modules/core-js/internals/function-bind-native.js\");\n\nvar FunctionPrototype = Function.prototype;\nvar call = FunctionPrototype.call;\nvar uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);\n\nmodule.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {\n  return function () {\n    return call.apply(fn, arguments);\n  };\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/function-uncurry-this.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/get-built-in.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-built-in.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar global = __webpack_require__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\n\nvar aFunction = function (argument) {\n  return isCallable(argument) ? argument : undefined;\n};\n\nmodule.exports = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/get-built-in.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/get-method.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/get-method.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar aCallable = __webpack_require__(/*! ../internals/a-callable */ \"./node_modules/core-js/internals/a-callable.js\");\nvar isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ \"./node_modules/core-js/internals/is-null-or-undefined.js\");\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nmodule.exports = function (V, P) {\n  var func = V[P];\n  return isNullOrUndefined(func) ? undefined : aCallable(func);\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/get-method.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/global.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/global.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar check = function (it) {\n  return it && it.Math === Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nmodule.exports =\n  // eslint-disable-next-line es/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||\n  check(typeof this == 'object' && this) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/global.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/has-own-property.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/has-own-property.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ \"./node_modules/core-js/internals/function-uncurry-this.js\");\nvar toObject = __webpack_require__(/*! ../internals/to-object */ \"./node_modules/core-js/internals/to-object.js\");\n\nvar hasOwnProperty = uncurryThis({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es/no-object-hasown -- safe\nmodule.exports = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject(it), key);\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/has-own-property.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/hidden-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/hidden-keys.js ***!
  \*******************************************************/
/***/ (function(module) {

"use strict";
eval("\nmodule.exports = {};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/hidden-keys.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/ie8-dom-define.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\nvar createElement = __webpack_require__(/*! ../internals/document-create-element */ \"./node_modules/core-js/internals/document-create-element.js\");\n\n// Thanks to IE8 for its funny defineProperty\nmodule.exports = !DESCRIPTORS && !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement('div'), 'a', {\n    get: function () { return 7; }\n  }).a !== 7;\n});\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/ie8-dom-define.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/indexed-object.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/indexed-object.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ \"./node_modules/core-js/internals/function-uncurry-this.js\");\nvar fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\nvar classof = __webpack_require__(/*! ../internals/classof-raw */ \"./node_modules/core-js/internals/classof-raw.js\");\n\nvar $Object = Object;\nvar split = uncurryThis(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nmodule.exports = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof(it) === 'String' ? split(it, '') : $Object(it);\n} : $Object;\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/indexed-object.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/inspect-source.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/inspect-source.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ \"./node_modules/core-js/internals/function-uncurry-this.js\");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\nvar store = __webpack_require__(/*! ../internals/shared-store */ \"./node_modules/core-js/internals/shared-store.js\");\n\nvar functionToString = uncurryThis(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable(store.inspectSource)) {\n  store.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nmodule.exports = store.inspectSource;\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/inspect-source.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/internal-state.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/internal-state.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/weak-map-basic-detection */ \"./node_modules/core-js/internals/weak-map-basic-detection.js\");\nvar global = __webpack_require__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\nvar createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ \"./node_modules/core-js/internals/has-own-property.js\");\nvar shared = __webpack_require__(/*! ../internals/shared-store */ \"./node_modules/core-js/internals/shared-store.js\");\nvar sharedKey = __webpack_require__(/*! ../internals/shared-key */ \"./node_modules/core-js/internals/shared-key.js\");\nvar hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ \"./node_modules/core-js/internals/hidden-keys.js\");\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError = global.TypeError;\nvar WeakMap = global.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw new TypeError('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new WeakMap());\n  /* eslint-disable no-self-assign -- prototype methods protection */\n  store.get = store.get;\n  store.has = store.has;\n  store.set = store.set;\n  /* eslint-enable no-self-assign -- prototype methods protection */\n  set = function (it, metadata) {\n    if (store.has(it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    store.set(it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return store.get(it) || {};\n  };\n  has = function (it) {\n    return store.has(it);\n  };\n} else {\n  var STATE = sharedKey('state');\n  hiddenKeys[STATE] = true;\n  set = function (it, metadata) {\n    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return hasOwn(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn(it, STATE);\n  };\n}\n\nmodule.exports = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/internal-state.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/is-array.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/is-array.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar classof = __webpack_require__(/*! ../internals/classof-raw */ \"./node_modules/core-js/internals/classof-raw.js\");\n\n// `IsArray` abstract operation\n// https://tc39.es/ecma262/#sec-isarray\n// eslint-disable-next-line es/no-array-isarray -- safe\nmodule.exports = Array.isArray || function isArray(argument) {\n  return classof(argument) === 'Array';\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/is-array.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/is-big-int-array.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/is-big-int-array.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar classof = __webpack_require__(/*! ../internals/classof */ \"./node_modules/core-js/internals/classof.js\");\n\nmodule.exports = function (it) {\n  var klass = classof(it);\n  return klass === 'BigInt64Array' || klass === 'BigUint64Array';\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/is-big-int-array.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/is-callable.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/is-callable.js ***!
  \*******************************************************/
/***/ (function(module) {

"use strict";
eval("\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\nvar documentAll = typeof document == 'object' && document.all;\n\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\n// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing\nmodule.exports = typeof documentAll == 'undefined' && documentAll !== undefined ? function (argument) {\n  return typeof argument == 'function' || argument === documentAll;\n} : function (argument) {\n  return typeof argument == 'function';\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/is-callable.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/is-forced.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-forced.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value === POLYFILL ? true\n    : value === NATIVE ? false\n    : isCallable(detection) ? fails(detection)\n    : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\n\nmodule.exports = isForced;\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/is-forced.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/is-null-or-undefined.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/is-null-or-undefined.js ***!
  \****************************************************************/
/***/ (function(module) {

"use strict";
eval("\n// we can't use just `it == null` since of `document.all` special case\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec\nmodule.exports = function (it) {\n  return it === null || it === undefined;\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/is-null-or-undefined.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/is-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-object.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\n\nmodule.exports = function (it) {\n  return typeof it == 'object' ? it !== null : isCallable(it);\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/is-object.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/is-possible-prototype.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/is-possible-prototype.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar isObject = __webpack_require__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n\nmodule.exports = function (argument) {\n  return isObject(argument) || argument === null;\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/is-possible-prototype.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/is-pure.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/is-pure.js ***!
  \***************************************************/
/***/ (function(module) {

"use strict";
eval("\nmodule.exports = false;\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/is-pure.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/is-symbol.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-symbol.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\nvar isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ \"./node_modules/core-js/internals/object-is-prototype-of.js\");\nvar USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ \"./node_modules/core-js/internals/use-symbol-as-uid.js\");\n\nvar $Object = Object;\n\nmodule.exports = USE_SYMBOL_AS_UID ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn('Symbol');\n  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/is-symbol.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/length-of-array-like.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/length-of-array-like.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar toLength = __webpack_require__(/*! ../internals/to-length */ \"./node_modules/core-js/internals/to-length.js\");\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nmodule.exports = function (obj) {\n  return toLength(obj.length);\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/length-of-array-like.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/make-built-in.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/make-built-in.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ \"./node_modules/core-js/internals/function-uncurry-this.js\");\nvar fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ \"./node_modules/core-js/internals/has-own-property.js\");\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(/*! ../internals/function-name */ \"./node_modules/core-js/internals/function-name.js\").CONFIGURABLE);\nvar inspectSource = __webpack_require__(/*! ../internals/inspect-source */ \"./node_modules/core-js/internals/inspect-source.js\");\nvar InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ \"./node_modules/core-js/internals/internal-state.js\");\n\nvar enforceInternalState = InternalStateModule.enforce;\nvar getInternalState = InternalStateModule.get;\nvar $String = String;\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar defineProperty = Object.defineProperty;\nvar stringSlice = uncurryThis(''.slice);\nvar replace = uncurryThis(''.replace);\nvar join = uncurryThis([].join);\n\nvar CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {\n  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;\n});\n\nvar TEMPLATE = String(String).split('String');\n\nvar makeBuiltIn = module.exports = function (value, name, options) {\n  if (stringSlice($String(name), 0, 7) === 'Symbol(') {\n    name = '[' + replace($String(name), /^Symbol\\(([^)]*)\\)/, '$1') + ']';\n  }\n  if (options && options.getter) name = 'get ' + name;\n  if (options && options.setter) name = 'set ' + name;\n  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {\n    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });\n    else value.name = name;\n  }\n  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {\n    defineProperty(value, 'length', { value: options.arity });\n  }\n  try {\n    if (options && hasOwn(options, 'constructor') && options.constructor) {\n      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });\n    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n    } else if (value.prototype) value.prototype = undefined;\n  } catch (error) { /* empty */ }\n  var state = enforceInternalState(value);\n  if (!hasOwn(state, 'source')) {\n    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');\n  } return value;\n};\n\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn(function toString() {\n  return isCallable(this) && getInternalState(this).source || inspectSource(this);\n}, 'toString');\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/make-built-in.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/math-trunc.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/math-trunc.js ***!
  \******************************************************/
/***/ (function(module) {

"use strict";
eval("\nvar ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es/no-math-trunc -- safe\nmodule.exports = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? floor : ceil)(n);\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/math-trunc.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/object-define-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-property.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ \"./node_modules/core-js/internals/ie8-dom-define.js\");\nvar V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(/*! ../internals/v8-prototype-define-bug */ \"./node_modules/core-js/internals/v8-prototype-define-bug.js\");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\nvar toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ \"./node_modules/core-js/internals/to-property-key.js\");\n\nvar $TypeError = TypeError;\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nexports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  } return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/object-define-property.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-descriptor.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar call = __webpack_require__(/*! ../internals/function-call */ \"./node_modules/core-js/internals/function-call.js\");\nvar propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ \"./node_modules/core-js/internals/object-property-is-enumerable.js\");\nvar createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ \"./node_modules/core-js/internals/create-property-descriptor.js\");\nvar toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\nvar toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ \"./node_modules/core-js/internals/to-property-key.js\");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ \"./node_modules/core-js/internals/has-own-property.js\");\nvar IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ \"./node_modules/core-js/internals/ie8-dom-define.js\");\n\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nexports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPropertyKey(P);\n  if (IE8_DOM_DEFINE) try {\n    return $getOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/object-get-own-property-descriptor.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-names.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ \"./node_modules/core-js/internals/object-keys-internal.js\");\nvar enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ \"./node_modules/core-js/internals/enum-bug-keys.js\");\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es/no-object-getownpropertynames -- safe\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/object-get-own-property-names.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-symbols.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe\nexports.f = Object.getOwnPropertySymbols;\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/object-get-own-property-symbols.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/object-get-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-prototype-of.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ \"./node_modules/core-js/internals/has-own-property.js\");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\nvar toObject = __webpack_require__(/*! ../internals/to-object */ \"./node_modules/core-js/internals/to-object.js\");\nvar sharedKey = __webpack_require__(/*! ../internals/shared-key */ \"./node_modules/core-js/internals/shared-key.js\");\nvar CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ \"./node_modules/core-js/internals/correct-prototype-getter.js\");\n\nvar IE_PROTO = sharedKey('IE_PROTO');\nvar $Object = Object;\nvar ObjectPrototype = $Object.prototype;\n\n// `Object.getPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.getprototypeof\n// eslint-disable-next-line es/no-object-getprototypeof -- safe\nmodule.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {\n  var object = toObject(O);\n  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];\n  var constructor = object.constructor;\n  if (isCallable(constructor) && object instanceof constructor) {\n    return constructor.prototype;\n  } return object instanceof $Object ? ObjectPrototype : null;\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/object-get-prototype-of.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/object-is-prototype-of.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-is-prototype-of.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ \"./node_modules/core-js/internals/function-uncurry-this.js\");\n\nmodule.exports = uncurryThis({}.isPrototypeOf);\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/object-is-prototype-of.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/object-keys-internal.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys-internal.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ \"./node_modules/core-js/internals/function-uncurry-this.js\");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ \"./node_modules/core-js/internals/has-own-property.js\");\nvar toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\nvar indexOf = (__webpack_require__(/*! ../internals/array-includes */ \"./node_modules/core-js/internals/array-includes.js\").indexOf);\nvar hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ \"./node_modules/core-js/internals/hidden-keys.js\");\n\nvar push = uncurryThis([].push);\n\nmodule.exports = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn(O, key = names[i++])) {\n    ~indexOf(result, key) || push(result, key);\n  }\n  return result;\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/object-keys-internal.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/object-property-is-enumerable.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/object-property-is-enumerable.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/object-set-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n/* eslint-disable no-proto -- safe */\nvar uncurryThisAccessor = __webpack_require__(/*! ../internals/function-uncurry-this-accessor */ \"./node_modules/core-js/internals/function-uncurry-this-accessor.js\");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\nvar aPossiblePrototype = __webpack_require__(/*! ../internals/a-possible-prototype */ \"./node_modules/core-js/internals/a-possible-prototype.js\");\n\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n// eslint-disable-next-line es/no-object-setprototypeof -- safe\nmodule.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n  try {\n    setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');\n    setter(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    anObject(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/object-set-prototype-of.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/ordinary-to-primitive.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/ordinary-to-primitive.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar call = __webpack_require__(/*! ../internals/function-call */ \"./node_modules/core-js/internals/function-call.js\");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n\nvar $TypeError = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nmodule.exports = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;\n  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n  throw new $TypeError(\"Can't convert object to primitive value\");\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/ordinary-to-primitive.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/own-keys.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/own-keys.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ \"./node_modules/core-js/internals/function-uncurry-this.js\");\nvar getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ \"./node_modules/core-js/internals/object-get-own-property-names.js\");\nvar getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ \"./node_modules/core-js/internals/object-get-own-property-symbols.js\");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n\nvar concat = uncurryThis([].concat);\n\n// all object keys, includes non-enumerable and symbols\nmodule.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/own-keys.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/require-object-coercible.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/require-object-coercible.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ \"./node_modules/core-js/internals/is-null-or-undefined.js\");\n\nvar $TypeError = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nmodule.exports = function (it) {\n  if (isNullOrUndefined(it)) throw new $TypeError(\"Can't call method on \" + it);\n  return it;\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/require-object-coercible.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/shared-key.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/shared-key.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar shared = __webpack_require__(/*! ../internals/shared */ \"./node_modules/core-js/internals/shared.js\");\nvar uid = __webpack_require__(/*! ../internals/uid */ \"./node_modules/core-js/internals/uid.js\");\n\nvar keys = shared('keys');\n\nmodule.exports = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/shared-key.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/shared-store.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/shared-store.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar global = __webpack_require__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\nvar defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ \"./node_modules/core-js/internals/define-global-property.js\");\n\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || defineGlobalProperty(SHARED, {});\n\nmodule.exports = store;\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/shared-store.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/shared.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/shared.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar IS_PURE = __webpack_require__(/*! ../internals/is-pure */ \"./node_modules/core-js/internals/is-pure.js\");\nvar store = __webpack_require__(/*! ../internals/shared-store */ \"./node_modules/core-js/internals/shared-store.js\");\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.35.0',\n  mode: IS_PURE ? 'pure' : 'global',\n  copyright: '© 2014-2023 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.35.0/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/shared.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/symbol-constructor-detection.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/internals/symbol-constructor-detection.js ***!
  \************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n/* eslint-disable es/no-symbol -- required for testing */\nvar V8_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ \"./node_modules/core-js/internals/engine-v8-version.js\");\nvar fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\nvar global = __webpack_require__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n\nvar $String = global.String;\n\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n  var symbol = Symbol('symbol detection');\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,\n  // of course, fail.\n  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n});\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/symbol-constructor-detection.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/to-absolute-index.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-absolute-index.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ \"./node_modules/core-js/internals/to-integer-or-infinity.js\");\n\nvar max = Math.max;\nvar min = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nmodule.exports = function (index, length) {\n  var integer = toIntegerOrInfinity(index);\n  return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/to-absolute-index.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/to-big-int.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/to-big-int.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ \"./node_modules/core-js/internals/to-primitive.js\");\n\nvar $TypeError = TypeError;\n\n// `ToBigInt` abstract operation\n// https://tc39.es/ecma262/#sec-tobigint\nmodule.exports = function (argument) {\n  var prim = toPrimitive(argument, 'number');\n  if (typeof prim == 'number') throw new $TypeError(\"Can't convert number to bigint\");\n  // eslint-disable-next-line es/no-bigint -- safe\n  return BigInt(prim);\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/to-big-int.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/to-indexed-object.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-indexed-object.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ \"./node_modules/core-js/internals/indexed-object.js\");\nvar requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ \"./node_modules/core-js/internals/require-object-coercible.js\");\n\nmodule.exports = function (it) {\n  return IndexedObject(requireObjectCoercible(it));\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/to-indexed-object.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/to-integer-or-infinity.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/to-integer-or-infinity.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar trunc = __webpack_require__(/*! ../internals/math-trunc */ \"./node_modules/core-js/internals/math-trunc.js\");\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nmodule.exports = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/to-integer-or-infinity.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/to-length.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-length.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ \"./node_modules/core-js/internals/to-integer-or-infinity.js\");\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nmodule.exports = function (argument) {\n  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/to-length.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/to-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-object.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ \"./node_modules/core-js/internals/require-object-coercible.js\");\n\nvar $Object = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nmodule.exports = function (argument) {\n  return $Object(requireObjectCoercible(argument));\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/to-object.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/to-primitive.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/to-primitive.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar call = __webpack_require__(/*! ../internals/function-call */ \"./node_modules/core-js/internals/function-call.js\");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\nvar isSymbol = __webpack_require__(/*! ../internals/is-symbol */ \"./node_modules/core-js/internals/is-symbol.js\");\nvar getMethod = __webpack_require__(/*! ../internals/get-method */ \"./node_modules/core-js/internals/get-method.js\");\nvar ordinaryToPrimitive = __webpack_require__(/*! ../internals/ordinary-to-primitive */ \"./node_modules/core-js/internals/ordinary-to-primitive.js\");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n\nvar $TypeError = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nmodule.exports = function (input, pref) {\n  if (!isObject(input) || isSymbol(input)) return input;\n  var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = call(exoticToPrim, input, pref);\n    if (!isObject(result) || isSymbol(result)) return result;\n    throw new $TypeError(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/to-primitive.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/to-property-key.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/to-property-key.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ \"./node_modules/core-js/internals/to-primitive.js\");\nvar isSymbol = __webpack_require__(/*! ../internals/is-symbol */ \"./node_modules/core-js/internals/is-symbol.js\");\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nmodule.exports = function (argument) {\n  var key = toPrimitive(argument, 'string');\n  return isSymbol(key) ? key : key + '';\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/to-property-key.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/to-string-tag-support.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/to-string-tag-support.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG] = 'z';\n\nmodule.exports = String(test) === '[object z]';\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/to-string-tag-support.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/try-to-string.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/try-to-string.js ***!
  \*********************************************************/
/***/ (function(module) {

"use strict";
eval("\nvar $String = String;\n\nmodule.exports = function (argument) {\n  try {\n    return $String(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/try-to-string.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/uid.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/uid.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ \"./node_modules/core-js/internals/function-uncurry-this.js\");\n\nvar id = 0;\nvar postfix = Math.random();\nvar toString = uncurryThis(1.0.toString);\n\nmodule.exports = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/uid.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/use-symbol-as-uid.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/use-symbol-as-uid.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n/* eslint-disable es/no-symbol -- required for testing */\nvar NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ \"./node_modules/core-js/internals/symbol-constructor-detection.js\");\n\nmodule.exports = NATIVE_SYMBOL\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/use-symbol-as-uid.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/v8-prototype-define-bug.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/v8-prototype-define-bug.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nmodule.exports = DESCRIPTORS && fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () { /* empty */ }, 'prototype', {\n    value: 42,\n    writable: false\n  }).prototype !== 42;\n});\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/v8-prototype-define-bug.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/weak-map-basic-detection.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/weak-map-basic-detection.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar global = __webpack_require__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\nvar isCallable = __webpack_require__(/*! ../internals/is-callable */ \"./node_modules/core-js/internals/is-callable.js\");\n\nvar WeakMap = global.WeakMap;\n\nmodule.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/weak-map-basic-detection.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/well-known-symbol.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar global = __webpack_require__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\nvar shared = __webpack_require__(/*! ../internals/shared */ \"./node_modules/core-js/internals/shared.js\");\nvar hasOwn = __webpack_require__(/*! ../internals/has-own-property */ \"./node_modules/core-js/internals/has-own-property.js\");\nvar uid = __webpack_require__(/*! ../internals/uid */ \"./node_modules/core-js/internals/uid.js\");\nvar NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ \"./node_modules/core-js/internals/symbol-constructor-detection.js\");\nvar USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ \"./node_modules/core-js/internals/use-symbol-as-uid.js\");\n\nvar Symbol = global.Symbol;\nvar WellKnownSymbolsStore = shared('wks');\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;\n\nmodule.exports = function (name) {\n  if (!hasOwn(WellKnownSymbolsStore, name)) {\n    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)\n      ? Symbol[name]\n      : createWellKnownSymbol('Symbol.' + name);\n  } return WellKnownSymbolsStore[name];\n};\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/internals/well-known-symbol.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/es.array.push.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.push.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar $ = __webpack_require__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\nvar toObject = __webpack_require__(/*! ../internals/to-object */ \"./node_modules/core-js/internals/to-object.js\");\nvar lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ \"./node_modules/core-js/internals/length-of-array-like.js\");\nvar setArrayLength = __webpack_require__(/*! ../internals/array-set-length */ \"./node_modules/core-js/internals/array-set-length.js\");\nvar doesNotExceedSafeInteger = __webpack_require__(/*! ../internals/does-not-exceed-safe-integer */ \"./node_modules/core-js/internals/does-not-exceed-safe-integer.js\");\nvar fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n\nvar INCORRECT_TO_LENGTH = fails(function () {\n  return [].push.call({ length: 0x100000000 }, 1) !== 4294967297;\n});\n\n// V8 <= 121 and Safari <= 15.4; FF < 23 throws InternalError\n// https://bugs.chromium.org/p/v8/issues/detail?id=12681\nvar properErrorOnNonWritableLength = function () {\n  try {\n    // eslint-disable-next-line es/no-object-defineproperty -- safe\n    Object.defineProperty([], 'length', { writable: false }).push();\n  } catch (error) {\n    return error instanceof TypeError;\n  }\n};\n\nvar FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();\n\n// `Array.prototype.push` method\n// https://tc39.es/ecma262/#sec-array.prototype.push\n$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  push: function push(item) {\n    var O = toObject(this);\n    var len = lengthOfArrayLike(O);\n    var argCount = arguments.length;\n    doesNotExceedSafeInteger(len + argCount);\n    for (var i = 0; i < argCount; i++) {\n      O[len] = arguments[i];\n      len++;\n    }\n    setArrayLength(O, len);\n    return len;\n  }\n});\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/modules/es.array.push.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.to-reversed.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.to-reversed.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar arrayToReversed = __webpack_require__(/*! ../internals/array-to-reversed */ \"./node_modules/core-js/internals/array-to-reversed.js\");\nvar ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ \"./node_modules/core-js/internals/array-buffer-view-core.js\");\n\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\nvar getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;\n\n// `%TypedArray%.prototype.toReversed` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.toreversed\nexportTypedArrayMethod('toReversed', function toReversed() {\n  return arrayToReversed(aTypedArray(this), getTypedArrayConstructor(this));\n});\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/modules/es.typed-array.to-reversed.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.to-sorted.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.to-sorted.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ \"./node_modules/core-js/internals/array-buffer-view-core.js\");\nvar uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ \"./node_modules/core-js/internals/function-uncurry-this.js\");\nvar aCallable = __webpack_require__(/*! ../internals/a-callable */ \"./node_modules/core-js/internals/a-callable.js\");\nvar arrayFromConstructorAndList = __webpack_require__(/*! ../internals/array-from-constructor-and-list */ \"./node_modules/core-js/internals/array-from-constructor-and-list.js\");\n\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\nvar sort = uncurryThis(ArrayBufferViewCore.TypedArrayPrototype.sort);\n\n// `%TypedArray%.prototype.toSorted` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tosorted\nexportTypedArrayMethod('toSorted', function toSorted(compareFn) {\n  if (compareFn !== undefined) aCallable(compareFn);\n  var O = aTypedArray(this);\n  var A = arrayFromConstructorAndList(getTypedArrayConstructor(O), O);\n  return sort(A, compareFn);\n});\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/modules/es.typed-array.to-sorted.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.with.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.with.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar arrayWith = __webpack_require__(/*! ../internals/array-with */ \"./node_modules/core-js/internals/array-with.js\");\nvar ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ \"./node_modules/core-js/internals/array-buffer-view-core.js\");\nvar isBigIntArray = __webpack_require__(/*! ../internals/is-big-int-array */ \"./node_modules/core-js/internals/is-big-int-array.js\");\nvar toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ \"./node_modules/core-js/internals/to-integer-or-infinity.js\");\nvar toBigInt = __webpack_require__(/*! ../internals/to-big-int */ \"./node_modules/core-js/internals/to-big-int.js\");\n\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\n\nvar PROPER_ORDER = !!function () {\n  try {\n    // eslint-disable-next-line no-throw-literal, es/no-typed-arrays, es/no-array-prototype-with -- required for testing\n    new Int8Array(1)['with'](2, { valueOf: function () { throw 8; } });\n  } catch (error) {\n    // some early implementations, like WebKit, does not follow the final semantic\n    // https://github.com/tc39/proposal-change-array-by-copy/pull/86\n    return error === 8;\n  }\n}();\n\n// `%TypedArray%.prototype.with` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.with\nexportTypedArrayMethod('with', { 'with': function (index, value) {\n  var O = aTypedArray(this);\n  var relativeIndex = toIntegerOrInfinity(index);\n  var actualValue = isBigIntArray(O) ? toBigInt(value) : +value;\n  return arrayWith(O, getTypedArrayConstructor(O), relativeIndex, actualValue);\n} }['with'], !PROPER_ORDER);\n\n\n//# sourceURL=webpack://xterm5-ishell/./node_modules/core-js/modules/es.typed-array.with.js?");

/***/ })

}]);